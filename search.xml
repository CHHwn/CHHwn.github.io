<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Ajax</title>
    <url>/2022/08/02/Ajax/</url>
    <content><![CDATA[<h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><h2 id="ajax简介"><a href="#ajax简介" class="headerlink" title="ajax简介"></a>ajax简介</h2><ol>
<li>AJAX全称为Asynchronous JavaScript And XML，就是异步的JS和XML</li>
<li>通过AJAX可以在浏览器中向服务器发送异步请求，最大的优势：无刷新获取数据</li>
<li>AJAX不是新的编程语言，而是一种将现有的标准组合在一起使用的新方式</li>
<li>通过AJAX，可以创建更好、更快以及更友好的WEB应用程序</li>
<li>AJAX基于JavaScript和HTTP请求（HTTP requests）</li>
</ol>
<h2 id="XML简介"><a href="#XML简介" class="headerlink" title="XML简介"></a>XML简介</h2><ol>
<li>XML可扩展标记语言</li>
<li>XML被设计用来传输和存储数据</li>
<li>XML和HTML类似，不同的是HTML中都是预定义标签，而XML中没有预定义标签，全都是自定义标签，用来表示一些数据</li>
<li>目前已经被json代替了</li>
</ol>
<h2 id="Ajax基础"><a href="#Ajax基础" class="headerlink" title="Ajax基础"></a>Ajax基础</h2><h3 id="ajax的优点"><a href="#ajax的优点" class="headerlink" title="ajax的优点"></a>ajax的优点</h3><ol>
<li>可以无需刷新页面而与服务器端进行通信</li>
<li>允许你根据用户事件来更新部分页面内容</li>
</ol>
<h3 id="ajax的缺点"><a href="#ajax的缺点" class="headerlink" title="ajax的缺点"></a>ajax的缺点</h3><ol>
<li>没有浏览历史，不能回退</li>
<li>存在跨域问题</li>
<li>SEO不友好（搜索引擎优化，对爬虫不友好）</li>
</ol>
<h3 id="ajax的要点"><a href="#ajax的要点" class="headerlink" title="ajax的要点"></a>ajax的要点</h3><ol>
<li>AJAX的要点是XMLHttpRequest对象</li>
<li>不同的浏览器创建 XMLHttpRequest对象的方法是有差异的</li>
<li>IE浏览器使用ActiveXObject，而其他的浏览器使用名为XMLHttpRequest的JavaScript内置对象</li>
</ol>
<h3 id="XMLHttpRequest对象"><a href="#XMLHttpRequest对象" class="headerlink" title="XMLHttpRequest对象"></a>XMLHttpRequest对象</h3><ol>
<li><p>XMLHttpRequest对象的属性</p>
<ol>
<li><p>onreadystatechange事件：onreadystatechange属性存有处理服务器响应的函数。下面的代码定义一个空的函数，可同时对onreadystatechange属性进行设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xmlHttp.onreadystatechange = function () &#123;</span><br><span class="line">  if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123;</span><br><span class="line">    ..      </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>readyState属性：存有服务器响应的状态信息。每当readyState改变时，onreadystatechange函数就会被执行</p>
<ul>
<li><p>readyState属性可能的值</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>请求未初始化（在调用open()之前）</td>
</tr>
<tr>
<td>1</td>
<td>请求已提出（调用send()之前）</td>
</tr>
<tr>
<td>2</td>
<td>请求已发送（这里通常可以从响应的到内容头部）</td>
</tr>
<tr>
<td>3</td>
<td>请求处理中（响应中通常有部分数据可用，但是服务器还没有完成响应）</td>
</tr>
<tr>
<td>4</td>
<td>请求已完成（可以访问服务器响应并使用它）</td>
</tr>
</tbody></table>
</li>
<li><p>测试响应是否完成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xmlHttp.onreadystatechange = function () &#123;</span><br><span class="line">  if(xmlHttp.readyState == 4) &#123;</span><br><span class="line">    // 从服务器的response获得数据</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>responseText属性：通过responseText属性来取回由服务器返回的数据</p>
</li>
<li><p>status属性：响应状态码</p>
<ul>
<li>200: “OK”</li>
<li>404: 未找到页面</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="请求服务器"><a href="#请求服务器" class="headerlink" title="请求服务器"></a>请求服务器</h3><ol>
<li>要想把请求发送到服务器，我们就需要使用open()方法和send()方法</li>
<li>open()方法定义请求，需要三个参数<ol>
<li>get方式发送请求，数据写在open()函数（第二个参数url后面）中</li>
<li>第一个参数定义发送请求所使用的方法（GET还是POST）</li>
<li>第二个参数规定服务器端脚本的URL</li>
<li>第三个参数规定是否使用异步，默认使用异步（true)，使用同步（false)</li>
</ol>
</li>
<li>send()方法可将请求送往服务器<ol>
<li>post方式发送请求，数据写在send()函数中，书写方式：key&#x3D;value&amp;key2&#x3D;value2，为字符串</li>
<li>send(null);</li>
</ol>
</li>
</ol>
<h3 id="get请求和post请求"><a href="#get请求和post请求" class="headerlink" title="get请求和post请求"></a>get请求和post请求</h3><ol>
<li><p>与post相比，get更快也更简单，并且大部分情况下都可以使用</p>
</li>
<li><p>但在下列情况中，需要使用post</p>
<ol>
<li>无法使用缓存文件（更新服务器上的文件或数据库）</li>
<li>向服务器发送大量的数据（post没有数据量限制）</li>
<li>发送包含未知字符的用户输入时，post比get更稳定和可靠</li>
</ol>
</li>
<li><p>get请求</p>
<ol>
<li><p>一个简单的get请求</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xhr.open(&#x27;get&#x27;, &#x27;xxx.php&#x27;);</span><br><span class="line">xhr.send(null);</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过get发送信息请求，数据写在open()函数（第二个参数url后面）中，或者可在文件名后进行拼接字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xhr.open(&#x27;get&#x27;, &#x27;xxx.php?name=jack&amp;skill=swim&#x27;);</span><br><span class="line">xhr.send(null);</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>post请求</p>
<ol>
<li><p>一个简单的post请求</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xhr.open(&#x27;post&#x27;, &#x27;xxx.php&#x27;);</span><br><span class="line">xhr.send(null);</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过post发送数据，需要使用setRequestHeader()来添加HTTP头，然后在send()方法中规定发送的数据</p>
</li>
<li><p>post方式发送请求，数据写在send()函数中，书写方式：key&#x3D;value&amp;key2&#x3D;value2，为字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xhr.open(&#x27;post&#x27;, &#x27;xxx.php&#x27;);</span><br><span class="line">xhr.setRequestHeader(&#x27;Content-type&#x27;, &#x27;application/x-www-form-urlencoded&#x27;);</span><br><span class="line">xhr.send(&#x27;name=rose&amp;skill=painting&#x27;);</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a><strong>HTTP协议</strong></h2><ol>
<li>HTTP（hypertext transport protocol）协议，超文本传输协议</li>
<li>HTTP协议详细规定了浏览器和万维网服务器之间互相通信的规则</li>
<li>主要约定了两块内容：<strong>请求报文和响应报文</strong></li>
<li>浏览器中获取html页面css和js请求后台页面；<strong>发送的是请求报文，服务器返回的是响应报文，使用请求报文和响应报文这种方式进行数据交互称之为http协议</strong></li>
<li>通过利用AJAX，您的JavaScript会通过JavaScript的XMLHttpRequest对象，直接与服务器来通信<ol>
<li><strong>XMLHttpRequest：对象提供了在网页加载后与服务器进行通信的方法</strong></li>
</ol>
</li>
</ol>
<h3 id="请求报文（面试重点）"><a href="#请求报文（面试重点）" class="headerlink" title="请求报文（面试重点）"></a>请求报文（面试重点）</h3><ol>
<li><p>什么是请求报文：包括<strong>请求行，请求头，请求主体</strong>；主要有发送请求的方法，浏览器的信息，发送的数据</p>
</li>
<li><p>格式与参数（重点）</p>
<ol>
<li><p>请求行：包括三部分（请求方式、url路径、http协议版本）</p>
<ul>
<li>请求方式：日常使用GET和POST使用居多</li>
<li>url路径：如&#x2F;s?ie&#x3D;utf-8</li>
<li>http协议版本：如HTTP&#x2F;1.1</li>
</ul>
</li>
<li><p>请求头：包括（浏览器信息、接受的语言格式、想要发给服务器的信息）请求头有很多，不需要都记住，但是必须记住请求头格式 — 键名: 值</p>
<ul>
<li>Host：atguifu.com</li>
<li>Cookie: name&#x3D;guigu</li>
<li>User-Agent: chrome 83</li>
</ul>
</li>
<li><p>请求主体：</p>
<p>发送给服务器的数据内容</p>
<p>；可有可无，</p>
<p>若请求行的请求类型为GET，则请求体为空；若为POST，则可以不为空</p>
<ul>
<li>如：username&#x3D;admin&amp;password&#x3D;admin</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="响应报文（面试重点）"><a href="#响应报文（面试重点）" class="headerlink" title="响应报文（面试重点）"></a>响应报文（面试重点）</h3><ol>
<li><p>什么是响应报文：包括<strong>状态行，响应头，响应主体</strong>；主要包括服务的信息，浏览器中直接可以看到的内容</p>
</li>
<li><p>格式与参数（重点）</p>
<ol>
<li><p>状态行</p>
<p>：服务的信息，包括三部分（</p>
<p>HTTP协议版本、响应状态码、响应状态字符串（如ok）</p>
<p>）</p>
<ul>
<li><p>http协议版本：如HTTP&#x2F;1.1</p>
</li>
<li><p>响应状态码</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>200</td>
<td>表示OK</td>
</tr>
<tr>
<td>304</td>
<td>被缓存了</td>
</tr>
<tr>
<td>404</td>
<td>表示页面找不到</td>
</tr>
<tr>
<td>403</td>
<td>表示禁止</td>
</tr>
<tr>
<td>401</td>
<td>未授权</td>
</tr>
<tr>
<td>500</td>
<td>内部错误</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>响应头：请求头有很多，不需要都记住，但是必须记住请求头格式 — 名字: 值</p>
<ul>
<li>Host：atguifu.com</li>
<li>Cookie: name&#x3D;guigu</li>
<li>User-Agent: chrome 83</li>
</ul>
</li>
<li><p>响应主体：主要的返回结果</p>
<p>，用户看到的内容；如html内容放在响应报文的响应体中做传输，浏览器接收到响应结果后，把响应结果提取出来，对内容做解析，在页面进行渲染和呈现</p>
<h2 id="Ajax发送请求"><a href="#Ajax发送请求" class="headerlink" title="Ajax发送请求"></a>Ajax发送请求</h2><h3 id="XMLHTTPRequest对象基本使用"><a href="#XMLHTTPRequest对象基本使用" class="headerlink" title="XMLHTTPRequest对象基本使用"></a>XMLHTTPRequest对象基本使用</h3></li>
</ol>
</li>
<li><p>创建异步对象</p>
<p>（XMLHTTPRequset对象）</p>
<ol>
<li>例：var xhr &#x3D; new XMLHTTPRequset();</li>
</ol>
</li>
<li><p>请求行</p>
<ol>
<li>XMLHTTPRequest对象的open()方法：定义请求<ul>
<li>第一个参数定义发送请求所使用的方法（GET还是POST）</li>
<li>第二个参数规定服务器端脚本的URL</li>
<li>第三个参数规定应当对请求进行异步地处理</li>
</ul>
</li>
<li>xhr.open(‘get’, ‘hello.php’);</li>
</ol>
</li>
<li><p>请求头</p>
<ol>
<li>XMLHTTPRequest对象的setRequestHeader()方法：设置请求头<ul>
<li>第一个参数为键名</li>
<li>第二个参数为值</li>
</ul>
</li>
<li>xhr.setRequestHeader(‘hanzai’, ‘more and more fat’);</li>
<li>若为get请求头可以省略；若为post，若发送数据则不能省略，不发送数据则可以省略</li>
<li>这里可以注册回调函数</li>
</ol>
</li>
<li><p>请求主体</p>
<ol>
<li>XMLHTTPRequest对象的send()方法：发送请求</li>
</ol>
</li>
<li><p>案例：点击请求报文，不刷新页面<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211009003058.png" alt="img"><img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211009003109.png" alt="img"></p>
</li>
</ol>
<h2 id="fetch-使用"><a href="#fetch-使用" class="headerlink" title="fetch()使用"></a>fetch()使用</h2><h3 id="fetch-介绍"><a href="#fetch-介绍" class="headerlink" title="fetch()介绍"></a>fetch()介绍</h3><ol>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API">Fetch API</a> 提供了一个 JavaScript 接口，用于访问和操纵 HTTP 管道的一些具体部分，例如请求和响应。它还提供了一个全局 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/fetch"><code>fetch()</code></a> 方法，该方法提供了一种简单，合理的方式来跨网络异步获取资源</p>
</li>
<li><p>是XMLHTTPRequset理想的替代方案</p>
</li>
<li><p>fetch请求的简单设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fetch(&#x27;http://example.com/movies.json&#x27;)</span><br><span class="line">    // 获取到http响应，通过json()方法将http响应的body解析成JSON的promise</span><br><span class="line">    .then(response =&gt; response.json())</span><br><span class="line">    // JSON的promise成功返回调用then回调函数，得到data数据</span><br><span class="line">    .then(data =&gt; console.log(data));</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="fetch规范与-jQuery-ajax-的不同"><a href="#fetch规范与-jQuery-ajax-的不同" class="headerlink" title="fetch规范与 jQuery.ajax()的不同"></a>fetch规范与 jQuery.ajax()的不同</h3><ol>
<li>当接收到一个代表错误的 HTTP 状态码时，从fetch返回的 Promise <strong>不会被标记为 reject</strong>，即使响应的 HTTP 状态码是 404 或 500</li>
<li>相反，它会将 Promise 状态标记为 <strong>resolve</strong> （如果响应的 HTTP 状态码不在 200 - 299 的范围内，则设置 resolve 返回值的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Response/ok"><code>ok</code></a> 属性为 false ），仅当网络故障时或请求被阻止时，才会标记为 reject</li>
</ol>
<h2 id="Ajax封装"><a href="#Ajax封装" class="headerlink" title="Ajax封装"></a>Ajax封装</h2><h3 id="封装的目的"><a href="#封装的目的" class="headerlink" title="封装的目的"></a>封装的目的</h3><ol>
<li>让我们把精力集中在逻辑上，来完成页面的交互效果，基础的部分不用每次都写一遍</li>
</ol>
<h3 id="封装的步骤"><a href="#封装的步骤" class="headerlink" title="封装的步骤"></a>封装的步骤</h3><ol>
<li>抽取固不变定的部分</li>
<li>不固定的部分作为参数</li>
<li>若参数有很多，就使用对象来进行优化；让对象作为封装函数的唯一参数，将从封装函数内部抽取出来不固定的部分作为对象的属性，回调函数作为对象的方法</li>
</ol>
<h3 id="封装的好坏"><a href="#封装的好坏" class="headerlink" title="封装的好坏"></a>封装的好坏</h3><ol>
<li>功能能否正常执行</li>
<li>代码的可读性</li>
<li>考虑问题是否足够多，兼容性问题，异常处理<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211009003133.png" alt="img"></li>
</ol>
<h3 id="jQuery的ajax-方法使用"><a href="#jQuery的ajax-方法使用" class="headerlink" title="jQuery的ajax()方法使用"></a>jQuery的ajax()方法使用</h3><ol>
<li>打开jQuery的帮助文档，在里面有ajax的方法</li>
<li>使用时，直接在js代码中引入jQuery文件，然后使用ajax方法即可：$.ajax();<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211009003150.png" alt="img"></li>
<li>在$.ajax()方法中，可以人为的指定返回的数据格式：dataType: ‘json’;</li>
</ol>
<h2 id="模板引擎的使用"><a href="#模板引擎的使用" class="headerlink" title="模板引擎的使用"></a>模板引擎的使用</h2><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ol>
<li>引入模板引擎的js文件</li>
<li>定义模板<ol>
<li>定义模板：</li>
<li>type属性不写，或者写属性值为text&#x2F;javascript，则会被解析为js</li>
</ol>
</li>
<li>挖坑 —&gt; 给坑起名字<ol>
<li>挖坑标准语法：</li>
</ol>
</li>
<li>填坑 —&gt; 把对象与模板结合<ol>
<li>数据 -&gt; 服务器 -&gt; ajax</li>
<li>回调函数</li>
<li>template(‘id’, 数据);</li>
</ol>
</li>
<li>使用</li>
<li>例：<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211009003208.png" alt="img"></li>
</ol>
<h2 id="同源跨域"><a href="#同源跨域" class="headerlink" title="同源跨域"></a>同源跨域</h2><h3 id="同源"><a href="#同源" class="headerlink" title="同源"></a>同源</h3><ol>
<li>协议，域名（地址），端口，三者都相同就称之为同源</li>
<li>同源策略是一种安全协议，指一段脚本只能读取来自同一来源的窗口和文档的属性</li>
<li>不同源：协议，域名（地址），端口，三者有一个不一样就称之为不同源</li>
</ol>
<h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><ol>
<li>跨域：不同源的网站之间互相发送请求，称之为跨域访问</li>
<li>浏览器默认是跨域访问的，虽然被限制了，但是在开发中不可避免会出现跨域访问，为了解决跨域访问，就需要在后台(php)设置允许跨域访问：header(‘Access-Control-Allow-Origin: *’);</li>
<li>此方法只有html5才支持，为了兼容低版本浏览器，就使用另外一种解决方案jsonp</li>
</ol>
<h3 id="Jsonp原理（面试必问）"><a href="#Jsonp原理（面试必问）" class="headerlink" title="Jsonp原理（面试必问）"></a>Jsonp原理（面试必问）</h3><ol>
<li>json是一种数据格式，而jsonp是用来解决跨域获取数据的一种解决方案</li>
<li>jsonp原理：<ol>
<li>jsonp就是利用了<strong>src属性支持跨域获取资源</strong></li>
<li>script标签后面中src属性写上需要请求页面的网址，并且发送一个方法的方法名到服务器</li>
<li>服务器接收到方法名之后，拼接一个方法的调用，在方法的参数中传入需要给浏览器的数据</li>
<li>返回给浏览器，浏览器把数据当做js进行解析，解决跨域问题<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211009003228.png" alt="img"></li>
</ol>
</li>
<li><strong>缺点：此方法虽然巧妙，但是却比较鸡肋，因为使用此方法解决跨域问题只支持get请求方式</strong></li>
</ol>
]]></content>
      <categories>
        <category>Ajax</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>BOM</title>
    <url>/2022/08/01/BOM/</url>
    <content><![CDATA[<h1 id="BOM概述"><a href="#BOM概述" class="headerlink" title="BOM概述"></a>BOM概述</h1><h2 id="什么是BOM"><a href="#什么是BOM" class="headerlink" title="什么是BOM"></a>什么是BOM</h2><ol>
<li>BOM即浏览器对象模型，它提供了独立于内容而与浏览器窗口进行交互的对象，其核心对象是window</li>
<li>BOM由一系列相关的对象构成，并且每个对象都提供了很多方法与属性</li>
<li>BOM缺乏标准，JavaScript语法的标准化组织是ECMA，DOM的标准化组织是W3C，BOM最初是Netscape浏览器标准的一部分</li>
</ol>
<h3 id="DOM和BOM"><a href="#DOM和BOM" class="headerlink" title="DOM和BOM"></a>DOM和BOM</h3><ol>
<li>DOM<ol>
<li>文档对象模型</li>
<li>DOM就是把「文档」当做一个「对象」来看待</li>
<li>DOM的顶级对象是document</li>
<li>DOM主要学习的是操作页面先素</li>
<li>DOM是W3C标准规范</li>
</ol>
</li>
<li>BOM<ol>
<li>浏览器对象模型</li>
<li>把「浏览器」当做一个「对象」来看待</li>
<li>BOM的顶级对象是window</li>
<li>BOM学习的是浏览器窗口交互的一些对象</li>
<li>BOM是浏览器厂商在各自浏览器上定义的，兼容性较差</li>
<li>BOM比DOM更大，它包含DOM</li>
</ol>
</li>
</ol>
<h3 id="BOM的构成"><a href="#BOM的构成" class="headerlink" title="BOM的构成"></a>BOM的构成</h3><ol>
<li>window对象是浏览器的顶级对象，它具有双重角色<ol>
<li>它是JS访问浏览器窗口的一个接口</li>
<li>它是一个全局对象，定义在全局作用域中的变量，函数都会变成window对象的属性和方法</li>
</ol>
</li>
<li>在调用的时候可以省略window，前面学习的对话框都属于window对象方法，如alert()、prompt()等</li>
</ol>
<h1 id="Window对象的常见事件"><a href="#Window对象的常见事件" class="headerlink" title="Window对象的常见事件"></a>Window对象的常见事件</h1><h2 id="窗口加载事件"><a href="#窗口加载事件" class="headerlink" title="窗口加载事件"></a>窗口加载事件</h2><h3 id="onload"><a href="#onload" class="headerlink" title="onload"></a>onload</h3><ol>
<li>window.onload是窗口(页面)加载事件，当文档内容完全加载完成会触发该事件（包括图像、脚本文件、CSS文件等），就调用的处理函数</li>
<li>语法<ol>
<li>传统注册方式：window.onload &#x3D; function() {}</li>
<li>事件监听注册方式：window.addEventListener(‘load’, function() {});</li>
</ol>
</li>
<li>有了window.onload就可以把JS代码写到页面元素的上方，因为onload是等页面内容全部加载完毕，再去执行处理函数</li>
</ol>
<h3 id="DOMContentLoaded"><a href="#DOMContentLoaded" class="headerlink" title="DOMContentLoaded"></a>DOMContentLoaded</h3><ol>
<li>DOMContentLoaded事件触发时，仅当DOM加载完成，不包括样式表、图片、flash等等</li>
<li>IE9以上支持</li>
<li>如果页面的图片很多的话，从用户访问 到onload触发可能需要较长的时间，交互效果就不能实现，必然影响用户的体验，此时用DOMContentLoaded事件比较合适</li>
<li>语法<ol>
<li>事件监听注册方式：window.addEventListener(‘DOMContentLoaded’, function() {});</li>
</ol>
</li>
</ol>
<h2 id="调整窗口大小事件"><a href="#调整窗口大小事件" class="headerlink" title="调整窗口大小事件"></a>调整窗口大小事件</h2><ol>
<li>语法<ol>
<li>传统注册方式：Window.onresize &#x3D; function() {}</li>
<li>事件监听注册方式：window.addEventListener(‘resize’, function() {});</li>
</ol>
</li>
<li>Window.onresize是调整窗口大小加载事件，当触发时就调用的处理函数</li>
<li>注意：<ol>
<li>只要窗口大小发生像素变化，就会触发这个事件</li>
<li>经常利用这个事件完成响应式布局，window.innerWidth — 当前屏幕宽度</li>
</ol>
</li>
</ol>
<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><h3 id="setTimeout-定时器"><a href="#setTimeout-定时器" class="headerlink" title="setTimeout() 定时器"></a>setTimeout() 定时器</h3><ol>
<li><p>window.setTimeout(调用函数，延迟的毫秒数);</p>
<ol>
<li><p>window在调用时可以省略</p>
</li>
<li><p>延迟时间的单位是毫秒，但是可以省略，若省略默认为0</p>
</li>
<li><p>调用函数可以直接写函数，或者写函数名或者采用’函数名()’三种形式，第三种不推荐</p>
</li>
<li><p>定时器可能会有很多，所以经常给定时器赋值一个标识符（名字）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    // 方式一，直接写函数</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        console.log(&#x27;嘣嘣嘣~&#x27;);</span><br><span class="line">    &#125;, 3000);</span><br><span class="line"></span><br><span class="line">    // 方式二，调用函数</span><br><span class="line">    var b = function () &#123;</span><br><span class="line">        console.log(&#x27;嘣嘣嘣~&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    setTimeout(b, 5000);</span><br><span class="line"></span><br><span class="line">    // 方式三，&#x27;函数名()&#x27;</span><br><span class="line">    setTimeout(&#x27;b()&#x27;, 7000);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>停止定时器window.clearTimeout(timeoutID);</p>
<ol>
<li><p>window可以省略</p>
</li>
<li><p>里面的参数就是定时器的标识符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;button&gt;取消广告自动关闭&lt;/button&gt;</span><br><span class="line">    &lt;img src=&quot;images/ad.jpg&quot; alt=&quot;&quot; class=&quot;ad&quot;&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        // 广告三秒自动关闭</span><br><span class="line">        var ad = document.querySelector(&#x27;.ad&#x27;);</span><br><span class="line">        var timer = setTimeout(function () &#123;</span><br><span class="line">            ad.style.display = &#x27;none&#x27;;</span><br><span class="line">        &#125;, 3000);</span><br><span class="line"></span><br><span class="line">        // 清除定时器</span><br><span class="line">        var btn = document.querySelector(&#x27;button&#x27;);</span><br><span class="line">        btn.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">            clearTimeout(timer);</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="setInterval-定时器"><a href="#setInterval-定时器" class="headerlink" title="setInterval() 定时器"></a>setInterval() 定时器</h3><ol>
<li><p>setInterval(调用函数，重复调用时间间隔);</p>
<ol>
<li>该定时器属性和setTimeout()一样，如下：<ul>
<li>window在调用时可以省略</li>
<li>延迟时间的单位是毫秒，但是可以省略，若省略默认为0</li>
<li>调用函数可以直接写函数，或者写函数名或者采用’函数名()’三种形式，第三种不推荐</li>
<li>定时器可能会有很多，所以经常给定时器赋值一个标识符（名字）</li>
</ul>
</li>
<li>不同点在于：每隔设置的延时时间，就去调用这个回调函数，会调用很多次，重复调用这个函数；而setTimeout()只会调用一次就结束这个定时器</li>
</ol>
</li>
<li><p>停止定时器window.clearInterval(timeoutID);</p>
<ol>
<li><p>window可以省略</p>
</li>
<li><p>案例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;button class=&quot;start&quot;&gt;开始计时器&lt;/button&gt;</span><br><span class="line">&lt;button class=&quot;stop&quot;&gt;停止计时器&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var start = document.querySelector(&#x27;.start&#x27;);</span><br><span class="line">    var stop = document.querySelector(&#x27;.stop&#x27;);</span><br><span class="line">    var timer = null;</span><br><span class="line"></span><br><span class="line">    // 开始计时器</span><br><span class="line">    start.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">        // 不能在此处直接定义变量，因为此处定义则为局部变量</span><br><span class="line">        timer = setInterval(function () &#123;</span><br><span class="line">            console.log(&#x27;hello world!&#x27;);</span><br><span class="line">        &#125;, 1000)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    // 停止计时器</span><br><span class="line">    stop.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">        clearInterval(timer);</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h1 id="JS执行机制"><a href="#JS执行机制" class="headerlink" title="JS执行机制"></a>JS执行机制</h1><h2 id="JS是单线程"><a href="#JS是单线程" class="headerlink" title="JS是单线程"></a>JS是单线程</h2><ol>
<li>JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事；这是因为Javascript这门脚本语言诞生的使命所致一JavaScript是为处理页面中用户的交互，以及操作DOM而诞生的；比如我们对某个DOM元索进行添加和删除操作，不能同时进行；应该先进行添加，之后再删除</li>
<li>单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。这样所导致的问题是：如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉</li>
</ol>
<h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><ol>
<li>前一个任务结束后再执行后一个任务，程序的执行顺序与任务的排列顺序是一致的、同步的；比如做饭的同步做法：我们要烧水煮饭，等水开了（10分钟之后），再去切菜，炒菜</li>
<li>同步任务<ol>
<li>同步任务都在主线程上执行，形成一个执行栈</li>
</ol>
</li>
</ol>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><ol>
<li>你在做一件事情时，因为这件事情会花费很长时间，在做这件事的同时，你还可以去处理其他事情。比如做饭的异步做法，我们在烧水的同时，利用这10分钟，去切菜，炒菜</li>
<li>异步任务<ol>
<li>JS的异步是通过回调函数实现的，一般而言，异步任务有以下三种类型<ul>
<li>普通事件，如click等</li>
<li>资源加载，如load，error等</li>
<li>定时器，如setInterval，setTimeout等</li>
</ul>
</li>
<li>异步任务相关回调函数添加到任务队列中（任务队列也称为消息队列）</li>
</ol>
</li>
</ol>
<h3 id="JS执行机制-1"><a href="#JS执行机制-1" class="headerlink" title="JS执行机制"></a>JS执行机制</h3><ol>
<li>由于主线程不断的重复获得任务、执行任务、再获取任务、再执行，所以这种机制被称为事件循环(event loop)<br><img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20210929112103.png" alt="img"></li>
</ol>
<h1 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h1><h2 id="什么是location对象"><a href="#什么是location对象" class="headerlink" title="什么是location对象"></a>什么是location对象</h2><ol>
<li><p>window对象给我们提供了一个location属性用于获取或设置窗体的URL，并且可以用于解析URL；因为这个属性返回的是一个对象，所以我们将这个属性也称为location对象</p>
<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2></li>
<li><p>统一资源定位符(Uniform Resource Locator，URL)是互联网上标准资源的地址；互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它</p>
</li>
<li><p>语法格式</p>
<ol>
<li><p>protocol:&#x2F;&#x2F;host[:port]&#x2F;path&#x2F;[?query]#fragment</p>
</li>
<li><p>例：</p>
<p><a href="http://www.itcast.cn/index.html?name=andy&amp;age=18#link">http://www.itcast.cn/index.html?name=andy&amp;age=18#link</a></p>
<table>
<thead>
<tr>
<th>组成</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>protocol</td>
<td>通信协议 常用的http,ftp,maito等</td>
</tr>
<tr>
<td>host</td>
<td>主机（域名） <a href="http://www.itheima.com/">www.itheima.com</a></td>
</tr>
<tr>
<td>port</td>
<td>端口号 可选，省略时使用方案的默认端口 如http的默认端口为80</td>
</tr>
<tr>
<td>path</td>
<td>路径由零或多个’&#x2F;‘符号隔开的字符串，一般用来表示主机上的一个目录或文件地址</td>
</tr>
<tr>
<td>query</td>
<td>参数 以键值对的形式，通过&amp;符号分隔开来</td>
</tr>
<tr>
<td>fragment</td>
<td>片段 #后面内容 常见于链接 锚点</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ol>
<h3 id="location对象的属性"><a href="#location对象的属性" class="headerlink" title="location对象的属性"></a>location对象的属性</h3><table>
<thead>
<tr>
<th>location对象属性</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>location.href</td>
<td>获取或者设置整个URL</td>
</tr>
<tr>
<td>location.host</td>
<td>返回主机（域名） <a href="http://www.itheima.com/">www.itheima.com</a></td>
</tr>
<tr>
<td>location.port</td>
<td>返回端口号，如果未写返回空字符串</td>
</tr>
<tr>
<td>location.pathname</td>
<td>返回路径</td>
</tr>
<tr>
<td>location.search</td>
<td>返回参数</td>
</tr>
<tr>
<td>location.hash</td>
<td>返回片段，#后面内容常见与链接，锚点</td>
</tr>
</tbody></table>
<h3 id="location对象的方法"><a href="#location对象的方法" class="headerlink" title="location对象的方法"></a>location对象的方法</h3><ol>
<li><p>location对象方法 返回值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location.assign()    跟href一样，可以跳转页面（也称为重定向页面），记录历史，可以后退</span><br><span class="line">location.replace()    替换当前页面，因为不记录历史，所以不能后退页面</span><br><span class="line">location.reload()    重新加载页面，相当于刷新按钮或f5，如果参数为true，强制刷新ctrl+f5</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="navigator对象（了解）"><a href="#navigator对象（了解）" class="headerlink" title="navigator对象（了解）"></a>navigator对象（了解）</h1><ol>
<li><p>navigator对象包含有关浏览器的信息，它有很多属性，我们最常用的是userAgent，该属性可以返回由客户机发送服务器的user-agent头部的值</p>
</li>
<li><p>下面代码可以判断永和用哪个终端打开的页面，实现跳转</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if ((navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))) &#123;</span><br><span class="line"> window.location.href = &quot;../H5/index1.html&quot;; //手机</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  window.location.href = &quot;../H5/index2.html&quot;; //电脑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h1><ol>
<li><p>window对象给我们提供了一个history对象，与浏览器历史记录进行交互；该对象包含用户(在浏览器窗口中)访问过的URL</p>
<table>
<thead>
<tr>
<th>history对象方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>back()</td>
<td>后退功能 — history.back();</td>
</tr>
<tr>
<td>forward()</td>
<td>前进功能 — history.forward();</td>
</tr>
<tr>
<td>go(参数）</td>
<td>前进后退功能，参数如果是1，前进1一个页面；如果是-1，后退一个页面</td>
</tr>
</tbody></table>
</li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS三大特性、盒子模型和其他样式</title>
    <url>/2022/08/01/CSS%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E3%80%81%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%85%B6%E4%BB%96%E6%A0%B7%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="CSS三大特性"><a href="#CSS三大特性" class="headerlink" title="CSS三大特性"></a>CSS三大特性</h1><h2 id="层叠性"><a href="#层叠性" class="headerlink" title="层叠性"></a>层叠性</h2><ol>
<li>相同选择器给设置相同的样式，此时一个样式就会覆盖（层叠）另一个冲突的样式。层叠性主要解决样式冲突的问题</li>
<li>层叠性原则:<ol>
<li>样式冲突，遵循的原则是就近原则，哪个样式离结构近，就执行哪个样式</li>
<li>样式不冲突，不会层叠</li>
</ol>
</li>
</ol>
<h2 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h2><ol>
<li><p>CSS中的继承: 子标签会继承父标签的某些样式，如文本颜色和字号。恰当地使用继承可以简化代码，降低 CSS 样式的复杂性。</p>
</li>
<li><p>子元素可以继承父元素的样式：（text-，font-，line-这些元素开头的可以继承，以及color属性）</p>
</li>
<li><p>行高的继承性：</p>
<ol>
<li>代码</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line"> font:12px/1.5 Microsoft YaHei;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>行高可以跟单位也可以不跟单位</li>
<li>如果子元素没有设置行高，则会继承父元素的行高为 1.5</li>
<li>此时子元素的行高是：当前子元素的文字大小 * 1.5</li>
<li>body行高1.5这样写法最大的优势就是里面子元素可以根据自己文字大小自动调整行高</li>
</ol>
</li>
</ol>
<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>当同一个元素指定多个选择器，就会有优先级的产生。</p>
<ul>
<li>选择器相同，则执行层叠性</li>
<li>选择器不同，则根据选择器权重执行</li>
</ul>
<table>
<thead>
<tr>
<th>选择器</th>
<th>选择器权重</th>
</tr>
</thead>
<tbody><tr>
<td>继承或*</td>
<td>0,0,0,0</td>
</tr>
<tr>
<td>元素选择器</td>
<td>0,0,0,1</td>
</tr>
<tr>
<td>类选择器</td>
<td>伪类选择器 0,0,1,0</td>
</tr>
<tr>
<td>ID选择器</td>
<td>0,1,0,0</td>
</tr>
<tr>
<td>行内样式</td>
<td>style&#x3D;”” 1,0,0,0</td>
</tr>
<tr>
<td>!important</td>
<td>重要的 无穷大</td>
</tr>
</tbody></table>
<h2 id="权重"><a href="#权重" class="headerlink" title="权重"></a>权重</h2><ol>
<li><p>权重是有4组数字组成,但是不会有进位。</p>
</li>
<li><p>可以理解为类选择器永远大于元素选择器, id选择器永远大于类选择器,以此类推..</p>
</li>
<li><p>等级判断从左向右，如果某一位数值相同，则判断下一位数值。</p>
</li>
<li><p>可以简单记忆法:  通配符和继承权重为0, 标签选择器为1,类(伪类)选择器为 10, id选择器 100, 行内样式表为 1000, !important 无穷大.</p>
</li>
<li><p>继承的权重是0， 如果该元素没有直接选中，不管父元素权重多高，子元素得到的权重都是 0。</p>
</li>
</ol>
<h3 id="权重的叠加"><a href="#权重的叠加" class="headerlink" title="权重的叠加"></a>权重的叠加</h3><ol>
<li>权重叠加：如果是复合选择器，则会有权重叠加，需要计算权重。</li>
<li>计算</li>
</ol>
<table>
<thead>
<tr>
<th>复合选择器</th>
<th>权重</th>
</tr>
</thead>
<tbody><tr>
<td>div ul li</td>
<td>0,0,0,3</td>
</tr>
<tr>
<td>.nav ul li</td>
<td>0,0,1,2</td>
</tr>
<tr>
<td>a:hover</td>
<td>0,0,1,1</td>
</tr>
<tr>
<td>.nav a</td>
<td>0,0,1,1</td>
</tr>
</tbody></table>
<h1 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h1><h2 id="网页布局的本质"><a href="#网页布局的本质" class="headerlink" title="网页布局的本质"></a>网页布局的本质</h2><ol>
<li>网页布局的核心本质： 就是利用 CSS 摆盒子。</li>
<li>网页布局过程：<ol>
<li>先准备好相关的网页元素，网页元素基本都是盒子 Box 。</li>
<li>利用 CSS 设置好盒子样式，然后摆放到相应位置。</li>
<li>往盒子里面装内容</li>
</ol>
</li>
</ol>
<h2 id="盒子模型（Box-Model）组成"><a href="#盒子模型（Box-Model）组成" class="headerlink" title="盒子模型（Box Model）组成"></a>盒子模型（Box Model）组成</h2><ol>
<li>盒子模型：把 HTML 页面中的布局元素看作是一个矩形的盒子，也就是一个盛装内容的容器。</li>
<li>CSS 盒子模型本质上是一个盒子，封装周围的 HTML 元素，它包括：<strong>边框</strong>、<strong>外边距</strong>、<strong>内边距</strong>、和 <strong>实际内容</strong></li>
</ol>
<h2 id="边框（border）"><a href="#边框（border）" class="headerlink" title="边框（border）"></a>边框（border）</h2><ol>
<li><p>border可以设置元素的边框。边框有三部分组成：边框宽度(粗细) 边框样式  边框颜色；</p>
</li>
<li><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">border : border-width || border-style || border-color;   </span><br></pre></td></tr></table></figure>
</li>
<li><p>边框样式 border-style 可以设置如下值：</p>
<ol>
<li>none：没有边框即忽略所有边框的宽度（默认值）</li>
<li>solid：边框为单实线(最为常用的)</li>
<li>dashed：边框为虚线  </li>
<li>dotted：边框为点线</li>
</ol>
</li>
<li><p>边框的合写分写</p>
<ol>
<li>边框简写：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">border: 1px solid red;  </span><br></pre></td></tr></table></figure>

<ol start="2">
<li>边框分开写法：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">border-top: 1px solid red;  /* 只设定上边框， 其余同理 */   </span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="表格的细线边框"><a href="#表格的细线边框" class="headerlink" title="表格的细线边框"></a>表格的细线边框</h2><ol>
<li><p>border-collapse 属性控制浏览器绘制表格边框的方式。它控制相邻单元格的边框。</p>
</li>
<li><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">border-collapse:collapse; </span><br></pre></td></tr></table></figure></li>
</ol>
<p>collapse 单词是合并的意思,所以border-collapse: collapse; 表示相邻边框合并在一起</p>
<h2 id="边框会影响盒子实际大小"><a href="#边框会影响盒子实际大小" class="headerlink" title="边框会影响盒子实际大小"></a>边框会影响盒子实际大小</h2><ol>
<li>边框会额外增加盒子的实际大小。有两种方案解决：<ol>
<li>测量盒子大小的时候,不量边框。</li>
<li>如果测量的时候包含了边框,则需要 width&#x2F;height 减去边框宽度</li>
</ol>
</li>
</ol>
<h2 id="内边距（padding）"><a href="#内边距（padding）" class="headerlink" title="内边距（padding）"></a>内边距（padding）</h2><ol>
<li><p>padding 属性用于设置内边距，即边框与内容之间的距离。</p>
</li>
<li><p>语法：</p>
<ol>
<li><p>padding：上下左右四边距统一设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">padding: 20px;</span><br></pre></td></tr></table></figure>
</li>
<li><p>各边距分别设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">padding-top（上）</span><br><span class="line">padding-bottom（下）</span><br><span class="line">padding-left（左）</span><br><span class="line">padding-right（右）</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="padding的复合属性"><a href="#padding的复合属性" class="headerlink" title="padding的复合属性"></a>padding的复合属性</h3><ol>
<li>padding属性（简写属性）可以右一到四个值</li>
</ol>
<table>
<thead>
<tr>
<th>值的个数</th>
<th>表达意思</th>
</tr>
</thead>
<tbody><tr>
<td>padding:5px</td>
<td>1个值，代表上下左右都有5px像素内边距</td>
</tr>
<tr>
<td>padding:5px 10px</td>
<td>2个值，代表上下内边距是5像素左右内边距是10像素</td>
</tr>
<tr>
<td>padding:5px 10px 20px</td>
<td>代表上内边距5像素左右内边距10像素下内边距20像素</td>
</tr>
<tr>
<td>padding:5px 10px 20px 30px</td>
<td>上是5像素右10像素下20像素左是30像素 顺时针</td>
</tr>
</tbody></table>
<h2 id="内边距会影响盒子实际大小"><a href="#内边距会影响盒子实际大小" class="headerlink" title="内边距会影响盒子实际大小"></a>内边距会影响盒子实际大小</h2><ol>
<li><p>当我们给盒子指定 padding 值之后，发生了 2 件事情：</p>
<ol>
<li>内容和边框有了距离，添加了内边距。</li>
<li>padding影响了盒子实际大小。</li>
</ol>
</li>
<li><p>内边距对盒子大小的影响：</p>
<ol>
<li>如果盒子已经有了宽度和高度，此时再指定内边框，会撑大盒子。</li>
<li>如何盒子本身没有指定width&#x2F;height属性, 则此时padding不会撑开盒子大小。</li>
</ol>
</li>
<li><p>解决方案：</p>
<ol>
<li>如果保证盒子跟效果图大小保持一致，则让 width&#x2F;height 减去多出来的内边距大小即可。</li>
</ol>
</li>
</ol>
<h2 id="外边距（margin）"><a href="#外边距（margin）" class="headerlink" title="外边距（margin）"></a>外边距（margin）</h2><ol>
<li><p>margin 属性用于设置外边距，即控制盒子和盒子之间的距离。</p>
</li>
<li><p>语法：</p>
<ol>
<li><p>margin：上下左右四边距统一设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">margin: 20px;</span><br></pre></td></tr></table></figure>
</li>
<li><p>各边距分别设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">margin-top（上）</span><br><span class="line">margin-bottom（下）</span><br><span class="line">margin-left（左）</span><br><span class="line">margin-right（右）</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="外边距典型应用"><a href="#外边距典型应用" class="headerlink" title="外边距典型应用"></a>外边距典型应用</h2><ol>
<li><p>外边距可以让块级盒子水平居中的两个条件：</p>
<ol>
<li>盒子必须指定了宽度（width）</li>
<li>盒子左右的外边距都设置为 auto</li>
</ol>
</li>
<li><p>常见的写法有三种：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">margin-left: auto;   margin-right: auto;</span><br><span class="line">margin: auto;</span><br><span class="line">margin: 0 auto;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意：以上方法是让块级元素水平居中，行内元素或者行内块元素水平居中给其父元素添加 text-align:center 即可。</p>
</li>
</ol>
<h2 id="嵌套块元素垂直外边距的塌陷"><a href="#嵌套块元素垂直外边距的塌陷" class="headerlink" title="嵌套块元素垂直外边距的塌陷"></a>嵌套块元素垂直外边距的塌陷</h2><ol>
<li><p>对于两个嵌套关系（父子关系）的块元素，父元素有上外边距同时子元素也有上外边距，此时父元素会塌陷较大的外边距值。</p>
</li>
<li><p>解决方案：</p>
<ol>
<li>可以为父元素定义上边框。</li>
<li>可以为父元素定义上内边距。</li>
<li>可以为父元素添加 overflow:hidden。</li>
</ol>
</li>
</ol>
<h2 id="清除内外边距"><a href="#清除内外边距" class="headerlink" title="清除内外边距"></a>清除内外边距</h2><ol>
<li><p>网页元素很多都带有默认的内外边距，而且不同浏览器默认的也不一致。因此我们在布局前，首先要清除下网页元素的内外边距。</p>
</li>
<li><p>语法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  padding:0;   /* 清除内边距 */</span><br><span class="line">  margin:0;    /* 清除外边距 */</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意：行内元素为了照顾兼容性，尽量只设置左右内外边距，不要设置上下内外边距。</p>
</li>
</ol>
<h1 id="其他样式"><a href="#其他样式" class="headerlink" title="其他样式"></a>其他样式</h1><h2 id="圆角边框"><a href="#圆角边框" class="headerlink" title="圆角边框"></a>圆角边框</h2><ol>
<li><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">border-radius:length;    </span><br></pre></td></tr></table></figure>

<ol>
<li>参数值可以为数值或百分比的形式</li>
<li>如果是正方形想要设置为一个圆就把数值修改为高度或者宽度的一半，或者直接写为 50%</li>
<li>该属性是一个简写属性，可以跟四个值，分别代表左上角、右上角、右下角、左下角</li>
<li>分开写：border-top-left-radius、border-top-right-radius、border-bottom-right-radius 和border-bottom-left-radius</li>
</ol>
</li>
</ol>
<h3 id="盒子阴影"><a href="#盒子阴影" class="headerlink" title="盒子阴影"></a>盒子阴影</h3><ol>
<li><p>CSS3 中新增了盒子阴影，我们可以使用 box-shadow 属性为盒子添加阴影。</p>
</li>
<li><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">box-shadow: h-shadow v-shadow blur spread color inset; </span><br></pre></td></tr></table></figure>
</li>
<li><p>属性</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>h-shadow</td>
<td>必需水平阴影的位置，允许负值</td>
</tr>
<tr>
<td>v-shadow</td>
<td>必需垂直阴影的位置，允许负值</td>
</tr>
<tr>
<td>blur</td>
<td>可选模糊距离（阴影实虚）</td>
</tr>
<tr>
<td>spread</td>
<td>可选阴影的尺寸（阴影大小）</td>
</tr>
<tr>
<td>color</td>
<td>可选阴影的颜色，参阅CSS颜色值</td>
</tr>
<tr>
<td>inset</td>
<td>可选将外部阴影（outset）改为内部阴影</td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="文字阴影"><a href="#文字阴影" class="headerlink" title="文字阴影"></a>文字阴影</h3><ol>
<li><p>在CSS3中，我们可以使用text-shadow属性将阴影应用于文本。</p>
</li>
<li><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">text-shadow: h-shadow v-shadow blur color;</span><br></pre></td></tr></table></figure>
</li>
<li><p>属性</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>h-shadow</td>
<td>必需水平阴影的位置，允许负值</td>
</tr>
<tr>
<td>v-shadow</td>
<td>必需垂直阴影的位置，允许负值</td>
</tr>
<tr>
<td>blur</td>
<td>可选模糊距离（阴影实虚）</td>
</tr>
<tr>
<td>color</td>
<td>可选阴影颜色，参阅CSS颜色值</td>
</tr>
</tbody></table>
</li>
</ol>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS传统网页布局的三种方式和书写规范</title>
    <url>/2022/08/01/CSS%E4%BC%A0%E7%BB%9F%E7%BD%91%E9%A1%B5%E5%B8%83%E5%B1%80%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%92%8C%E4%B9%A6%E5%86%99%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h1 id="传统网页布局的三种方式"><a href="#传统网页布局的三种方式" class="headerlink" title="传统网页布局的三种方式"></a>传统网页布局的三种方式</h1><ol>
<li>CSS 提供了三种传统布局方式(简单说,就是盒子如何进行排列顺序)：<ol>
<li>普通流（标准流）</li>
<li>浮动</li>
<li>定位</li>
</ol>
</li>
</ol>
<h2 id="标准流（普通流-x2F-文档流）"><a href="#标准流（普通流-x2F-文档流）" class="headerlink" title="标准流（普通流&#x2F;文档流）"></a>标准流（普通流&#x2F;文档流）</h2><ol>
<li>块级元素会独占一行，从上向下顺序排列。常用元素：div、hr、p、h1~h6、ul、ol、dl、form、table</li>
<li>行内元素会按照顺序，从左到右顺序排列，碰到父元素边缘则自动换行。常用元素：span、a、i、em 等</li>
</ol>
<h2 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h2><ol>
<li><p>float 属性用于创建浮动框，将其移动到一边，直到左边缘或右边缘触及包含块或另一个浮动框的边缘。</p>
</li>
<li><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">选择器 &#123; float: 属性值; &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="浮动特性"><a href="#浮动特性" class="headerlink" title="浮动特性"></a>浮动特性</h3><ol>
<li>浮动元素会脱离标准流(脱标：浮动的盒子不再保留原先的位置)</li>
</ol>
<p><img src="/2022/08/01/CSS%E4%BC%A0%E7%BB%9F%E7%BD%91%E9%A1%B5%E5%B8%83%E5%B1%80%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%92%8C%E4%B9%A6%E5%86%99%E8%A7%84%E8%8C%83/image-30.png" alt="image-30"></p>
<ol start="2">
<li><p>浮动的元素会一行内显示并且元素顶部对齐</p>
<ol>
<li>注意：浮动的元素是互相贴靠在一起的（不会有缝隙），如果父级宽度装不下这些浮动的盒子，多出的盒子会另起一行对齐。</li>
</ol>
</li>
</ol>
<p>3、浮动的元素会具有行内块元素的特性</p>
<ol>
<li>浮动元素的大小根据内容来决定</li>
<li>浮动的盒子中间是没有缝隙的</li>
</ol>
<h3 id="浮动元素经常和标准流父级搭配使用"><a href="#浮动元素经常和标准流父级搭配使用" class="headerlink" title="浮动元素经常和标准流父级搭配使用"></a>浮动元素经常和标准流父级搭配使用</h3><ol>
<li>先用标准流父元素排列上下位置, 之后内部子元素采取浮动排列左右位置.  符合网页布局第一准侧</li>
</ol>
<p><img src="/2022/08/01/CSS%E4%BC%A0%E7%BB%9F%E7%BD%91%E9%A1%B5%E5%B8%83%E5%B1%80%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%92%8C%E4%B9%A6%E5%86%99%E8%A7%84%E8%8C%83/image-31.png" alt="image-31"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line"> .box &#123;</span><br><span class="line">     width: 1200px;</span><br><span class="line">     height: 400px;</span><br><span class="line">     background: bisque;</span><br><span class="line">     margin: 20px auto;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> .left &#123;</span><br><span class="line">     float: left;</span><br><span class="line">     width: 230px;</span><br><span class="line">     height: 400px;</span><br><span class="line">     background: pink;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> .right &#123;</span><br><span class="line">     float: left;</span><br><span class="line">     width: 970px;</span><br><span class="line">     height: 400px;</span><br><span class="line">     background: skyblue;</span><br><span class="line"> &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><ol>
<li>由于父级盒子很多情况下，不方便给高度，但是子盒子浮动又不占有位置，最后父级盒子高度为 0时，就会影响下面的标准流盒子。</li>
</ol>
<h3 id="清除浮动本质"><a href="#清除浮动本质" class="headerlink" title="清除浮动本质"></a>清除浮动本质</h3><ol>
<li><p>清除浮动的本质是清除浮动元素造成的影响：浮动的子标签无法撑开父盒子的高度</p>
</li>
<li><p>注意：</p>
<ol>
<li>如果父盒子本身有高度，则不需要清除浮动</li>
<li>清除浮动之后，父级就会根据浮动的子盒子自动检测高度。</li>
<li>父级有了高度，就不会影响下面的标准流了</li>
</ol>
</li>
</ol>
<h3 id="清除浮动样式"><a href="#清除浮动样式" class="headerlink" title="清除浮动样式"></a>清除浮动样式</h3><ol>
<li><p>语法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器&#123;<span class="attribute">clear</span>:属性值;&#125; </span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>left</td>
<td>不允许左侧有浮动元素（清除左侧浮动的影响）</td>
</tr>
<tr>
<td>right</td>
<td>不允许右侧有浮动元素（清除右侧浮动的影响）</td>
</tr>
<tr>
<td>both</td>
<td>同时清除左右两侧浮动的影响</td>
</tr>
</tbody></table>
</li>
</ol>
<ul>
<li>我们实际工作中，几乎只用 clear: both;</li>
</ul>
<ol start="2">
<li><p>清除浮动的多种方式</p>
<ol>
<li><p>额外标签法,额外标签法也称为隔墙法，是W3C推荐的做法。</p>
<ul>
<li>使用方式：额外标签法会在浮动元素末尾添加一个空的标签。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例如 &lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt;，或者其他标签（如&lt;br /&gt;等）</span><br></pre></td></tr></table></figure>

<ol>
<li>优点：通俗易懂，书写方便</li>
<li>缺点：添加许多无意义的标签，结构化较差</li>
<li>注意：要求这个新的空标签必须是块级元素。</li>
</ol>
</li>
</ol>
</li>
<li><p>父级添加overflow属性</p>
<p>1.给父级添加 overflow 属性，将其属性值设置为 hidden、 auto 或 scroll 。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">overflow:hidden | auto | scroll;</span><br></pre></td></tr></table></figure>

<ol>
<li>优点：代码简洁</li>
<li>缺点：无法显示溢出的部分</li>
<li>注意：是给父元素添加代码</li>
</ol>
</li>
<li><p>父级添加after伪元素</p>
<ol>
<li>:after 方式是额外标签法的升级版。给父元素添加：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.clearfix:after &#123;  </span><br><span class="line">content: &quot;&quot;; </span><br><span class="line">display: block; </span><br><span class="line">height: 0; </span><br><span class="line">clear: both; </span><br><span class="line">visibility: hidden;  </span><br><span class="line">&#125; </span><br><span class="line">.clearfix &#123;   </span><br><span class="line">*zoom: 1;    /* IE6、7 专有 */</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<ol>
<li>优点：没有增加标签，结构更简单</li>
<li>缺点：照顾低版本浏览器</li>
</ol>
</li>
<li><p>父级添加双伪元素</p>
<ul>
<li>给父元素添加</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.clearfix:before,.clearfix:after &#123;</span><br><span class="line">content:&quot;&quot;;</span><br><span class="line">display:table; </span><br><span class="line">&#125;</span><br><span class="line">.clearfix:after &#123;</span><br><span class="line">clear:both;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix &#123;</span><br><span class="line">*zoom:1;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<ol>
<li>优点：代码更简洁</li>
<li>缺点：照顾低版本浏览器</li>
</ol>
</li>
</ol>
<h1 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h1><h2 id="定位简介"><a href="#定位简介" class="headerlink" title="定位简介"></a>定位简介</h2><h3 id="为什么需要定位"><a href="#为什么需要定位" class="headerlink" title="为什么需要定位"></a>为什么需要定位</h3><ol>
<li>浮动可以让多个块级盒子一行没有缝隙排列显示，经常用于横向排列盒子</li>
<li>定位则是可以让盒子自由的在某个盒子内移动位置或者固定屏幕中某个位置，并且可以压住其他盒子</li>
</ol>
<h3 id="定位的组成"><a href="#定位的组成" class="headerlink" title="定位的组成"></a>定位的组成</h3><ol>
<li>定位：将盒子定在某一个位置，所以定位也是在摆放盒子，按照定位的方式移动盒子。</li>
<li>定位 &#x3D; 定位模式 + 边偏移<ol>
<li>定位模式用于指定一个元素在文档中的定位方式。边偏移则决定了该元素的最终位置</li>
</ol>
</li>
</ol>
<h2 id="定位模式与边偏移"><a href="#定位模式与边偏移" class="headerlink" title="定位模式与边偏移"></a>定位模式与边偏移</h2><h3 id="边偏移"><a href="#边偏移" class="headerlink" title="边偏移"></a>边偏移</h3><ol>
<li><p>边偏移：定位的盒子移动到最终位置</p>
<ul>
<li>属性（4个）：top bottom left reght</li>
</ul>
<table>
<thead>
<tr>
<th>边偏移属性</th>
<th>示例</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>top</td>
<td>top: 80px</td>
<td>顶端偏移量，定义元素相对于其父元素上边线的距离</td>
</tr>
<tr>
<td>bottom</td>
<td>bottom：80px</td>
<td>底部偏移量，定义元素相对于其父元素下边线的距离</td>
</tr>
<tr>
<td>left</td>
<td>left: 80px</td>
<td>左部偏移量，定义元素相对于其父元素左边线的距离</td>
</tr>
<tr>
<td>right</td>
<td>right: 80px</td>
<td>右部偏移量，定义元素相对于其父元素右边线的距离</td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="静态定位"><a href="#静态定位" class="headerlink" title="静态定位"></a>静态定位</h3><ol>
<li>静态定位是元素的默认定位方式，无定位的意思；按照标准流特性摆放位置，没有偏移量，很少使用</li>
<li>语法：选择器 {position: static;}</li>
</ol>
<h3 id="相对定位（重要）"><a href="#相对定位（重要）" class="headerlink" title="相对定位（重要）"></a>相对定位（重要）</h3><ol>
<li>相对定位：元素在移动位置的时候，是相对于它原来的位置移动</li>
<li>语法：选择器 {position: relative;}</li>
<li>相对定位的特点：（牢记）<ol>
<li>是相对于自己原来的位置来移动（移动位置的时候参照点为原来的位置）</li>
<li>原来在标准流的位置继续占有，后面的盒子仍然以标准流的方式对待它（不脱标，继续保留原来位置）</li>
</ol>
</li>
</ol>
<h3 id="绝对定位（重要）"><a href="#绝对定位（重要）" class="headerlink" title="绝对定位（重要）"></a>绝对定位（重要）</h3><ol>
<li>绝对定位：元素在移动位置时，是相对于它的祖先元素的位置移动（拼爹型）</li>
<li>语法：选择器 {position: absolute;}</li>
<li>绝对定位特点：（牢记）<ol>
<li>如果没有祖先元素或者祖先元素没有定位，则以浏览器为准定位</li>
<li>如果祖先元素有定位（相对，绝对，固定定位），则以最近一级的有定位祖先元素为参考点移动位置</li>
<li>绝对定位不再占有原先的位置（脱标）</li>
</ol>
</li>
</ol>
<h3 id="子绝父相（重要）"><a href="#子绝父相（重要）" class="headerlink" title="子绝父相（重要）"></a>子绝父相（重要）</h3><ol>
<li>意思：子级使用绝对定位，父级则需要相对定位</li>
<li>口诀：绝对定位与相对定位的使用场景</li>
</ol>
<h3 id="固定定位（重要）"><a href="#固定定位（重要）" class="headerlink" title="固定定位（重要）"></a>固定定位（重要）</h3><ol>
<li>固定定位：元素固定于浏览器可视区的位置</li>
<li>主要使用场景：可以在浏览器页面滚动时元素的位置不会改变</li>
<li>语法： {position: fixed;}</li>
<li>固定定位的特点：（牢记）<ol>
<li>以浏览器的可视窗口为参照点移动元素<ul>
<li>跟父元素没有任何关系</li>
<li>不随滚动条滚动</li>
</ul>
</li>
<li>固定定位不占有原来的位置<ul>
<li>固定定位也是脱标的，其实固定定位也可以看做是一种特殊的绝对定位</li>
</ul>
</li>
</ol>
</li>
<li>固定定位小技巧：固定在版心右侧位置<ol>
<li>小算法<ul>
<li>让固定定位的盒子left: 50%，走到浏览器可视区（可看作版心）一半的位置</li>
<li>让固定定位的盒子margin-left: 版心宽度一半距离</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="粘性定位（了解）"><a href="#粘性定位（了解）" class="headerlink" title="粘性定位（了解）"></a>粘性定位（了解）</h3><ol>
<li>粘性定位：相对定位和固定定位的混合</li>
<li>语法：选择器 {position: sticky; top: 10px;}</li>
<li>粘性定位特点：<ol>
<li>以浏览器的可视窗口为参照点移动元素（固定定位特点）</li>
<li>粘性定位占有原先的位置（相对定位特点）</li>
<li>必须添加top，left，right，bottom其中一个才有效</li>
</ol>
</li>
<li>与页面滚动相搭配使用，兼容性较差，IE不支持</li>
</ol>
<h3 id="定位小结"><a href="#定位小结" class="headerlink" title="定位小结"></a>定位小结</h3><table>
<thead>
<tr>
<th>定位模式</th>
<th>是否脱标</th>
<th>移动位置</th>
<th>是否常用</th>
</tr>
</thead>
<tbody><tr>
<td>static</td>
<td>静态定位</td>
<td>否（占有位置）</td>
<td>不能使用边偏移</td>
</tr>
<tr>
<td>relative</td>
<td>相对定位</td>
<td>否（占有位置）</td>
<td>相对于自身位置移动</td>
</tr>
<tr>
<td>absolute</td>
<td>绝对定位</td>
<td>是（不占有位置）</td>
<td>带有定位的父级</td>
</tr>
<tr>
<td>fixed</td>
<td>固定定位</td>
<td>是（不占有位置）</td>
<td>浏览器可视区</td>
</tr>
<tr>
<td>sticky</td>
<td>粘性位置</td>
<td>否（占有位置）</td>
<td>浏览器可视区</td>
</tr>
</tbody></table>
<ol>
<li>需要记住的两大特点<ol>
<li>是否脱标</li>
<li>以谁为基准点移动位置</li>
</ol>
</li>
<li>重点：子绝父相</li>
</ol>
<h2 id="定位的拓展"><a href="#定位的拓展" class="headerlink" title="定位的拓展"></a>定位的拓展</h2><h3 id="定位叠放次序-z-index"><a href="#定位叠放次序-z-index" class="headerlink" title="定位叠放次序 z-index"></a>定位叠放次序 z-index</h3><ol>
<li>使用定位布局时，可能会出现盒子重叠的情况。此时，可以使用z-index来来控制盒子的前后次序（z轴）</li>
<li>语法：选择器 {z-index: 1;}</li>
</ol>
<h2 id="绝对定位的盒子居中"><a href="#绝对定位的盒子居中" class="headerlink" title="绝对定位的盒子居中"></a>绝对定位的盒子居中</h2><ol>
<li>加了绝对定位的盒子不能通过margin: 0 auto; 水平居中，但是可以通过以下算法实现水平和垂直居中<ol>
<li>left: 50%; ：让盒子的左侧移动到父级元素（可视区）的水平中心位置</li>
<li>margin-left: -100px; ：让盒子向左移动自身宽度的一半</li>
</ol>
</li>
</ol>
<h2 id="定位的特殊特性"><a href="#定位的特殊特性" class="headerlink" title="定位的特殊特性"></a>定位的特殊特性</h2><ol>
<li>绝对定位和固定定位也和浮动类似<ol>
<li>行内元素添加绝对或者固定定位，可以直接设置高度和宽度</li>
<li>块级元素添加绝对或者固定定位，如果不給宽度或者高度，默认大小是内容大小</li>
</ol>
</li>
</ol>
<h2 id="绝对（固定）定位会完全压住盒子的一切内容"><a href="#绝对（固定）定位会完全压住盒子的一切内容" class="headerlink" title="绝对（固定）定位会完全压住盒子的一切内容"></a>绝对（固定）定位会完全压住盒子的一切内容</h2><ol>
<li>浮动元素：只会压住下面标准流的盒子，但是不会压住标准流内的文字（图片）<ul>
<li>因为浮动最初产生的目的就是文字环绕效果</li>
</ul>
</li>
<li>绝对定位（固定定位）：会压住下面标准流的全部内容</li>
</ol>
<h2 id="网页布局总结"><a href="#网页布局总结" class="headerlink" title="网页布局总结"></a>网页布局总结</h2><ol>
<li>标准流<ul>
<li>让盒子上下排列或者左右排列，垂直的块级盒子显示就是用标准流布局</li>
</ul>
</li>
<li>浮动<ul>
<li>可以让多个块级元素一行显示或者左右对齐盒子，多个块级盒子水平显示就用浮动布局</li>
</ul>
</li>
<li>定位<ul>
<li>定位最大的特点是有层叠的概念，就是可以让多个盒子前后叠压来显示，如果元素自由在某个盒子内移动就用定位布局</li>
</ul>
</li>
</ol>
<h2 id="元素的显示与隐藏"><a href="#元素的显示与隐藏" class="headerlink" title="元素的显示与隐藏"></a>元素的显示与隐藏</h2><h3 id="display属性（重点）"><a href="#display属性（重点）" class="headerlink" title="display属性（重点）"></a>display属性（重点）</h3><ol>
<li>display属性用于设置一个元素应该如何显示<ol>
<li>display: none; 除了转换为块级元素之外，同时还有显示元素的意思</li>
<li>display: block; 除了转换为块级元素之外，同时还有显示元素的意思</li>
</ol>
</li>
<li>display隐藏元素后，不再占有原来的位置</li>
<li>应用非常广泛，搭配JS可以做很多网页特效</li>
</ol>
<h3 id="visibility属性"><a href="#visibility属性" class="headerlink" title="visibility属性"></a>visibility属性</h3><ol>
<li>visibility属性用于指定一个元素可见还是隐藏<ol>
<li>visibility：visible; 元素可视</li>
<li>visibility: hidden; 元素隐藏</li>
</ol>
</li>
<li>visibility隐藏元素后，继续占有原来的位置</li>
</ol>
<h3 id="overflow溢出"><a href="#overflow溢出" class="headerlink" title="overflow溢出"></a>overflow溢出</h3><table>
<thead>
<tr>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>visible</td>
<td>不剪切内容也不添加滚动条</td>
</tr>
<tr>
<td>hidden</td>
<td>不显示超过对象尺寸的内容，超出的部分隐藏掉</td>
</tr>
<tr>
<td>scroll</td>
<td>不管是否超出内容，总是显示滚动条</td>
</tr>
<tr>
<td>auto</td>
<td>超出内容自动显示滚动条，不超出不显示滚动条</td>
</tr>
</tbody></table>
<h3 id="案例：视频播放黑色遮罩层"><a href="#案例：视频播放黑色遮罩层" class="headerlink" title="案例：视频播放黑色遮罩层"></a>案例：视频播放黑色遮罩层</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .box &#123;</span><br><span class="line">            position: relative;</span><br><span class="line">            width: 422px;</span><br><span class="line">            height: 280px;</span><br><span class="line">            margin: 20px auto;</span><br><span class="line">            background-color: blanchedalmond;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .box img &#123;</span><br><span class="line">            width: 100%;</span><br><span class="line">            height: 100%;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .box .black &#123;</span><br><span class="line">            display: none;</span><br><span class="line">            position: absolute;</span><br><span class="line">            top: 0;</span><br><span class="line">            left: 0;</span><br><span class="line">            width: 422px;</span><br><span class="line">            height: 280px;</span><br><span class="line">            background: rgba(0, 0, 0, 0.4) url(images/paly.jpg) no-repeat center;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .box:hover .black &#123;</span><br><span class="line">            display: block;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;box&quot;&gt;</span><br><span class="line">        &lt;img src=&quot;images/promo.jpg&quot; alt=&quot;&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;black&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>



<h1 id="书写案例"><a href="#书写案例" class="headerlink" title="书写案例"></a>书写案例</h1><ol>
<li>采取结构与样式相分离的思想</li>
</ol>
<h2 id="案例准备工作"><a href="#案例准备工作" class="headerlink" title="案例准备工作"></a>案例准备工作</h2><ol start="2">
<li><p>创建目录文件夹（用于存放案例页面的相关内容）</p>
</li>
<li><p>用vscode打开这个目录文件夹</p>
</li>
<li><p>目录文件夹内新建images文件夹，用于保存图片</p>
</li>
<li><p>新建首页文件index.html（以后我们的网站首页统一规定为index.html）<br>新建style.css样式文件，采用外链样式表</p>
</li>
<li><p>将样式表引入到HTML页面中</p>
</li>
<li><p>样式表写入清除内外边距的样式，来检测样式表是否引入成功</p>
</li>
</ol>
<h2 id="CSS属性书写顺序（重点）"><a href="#CSS属性书写顺序（重点）" class="headerlink" title="CSS属性书写顺序（重点）"></a>CSS属性书写顺序（重点）</h2><ol>
<li><p>遵循以下顺序</p>
<ol>
<li><p>布局定位属性：display, position, float, clear, visibility, overflow(建议display第一个写，关系到)</p>
</li>
<li><p>自身属性：width, height, margin, padding, border, background</p>
</li>
<li><p>文本属性：color, font, text-decoration, text-align, vertical-align, white-space, break-word</p>
</li>
<li><p>其他属性（CSS3）：content, cursor, border-radius, box-shadow, text-shadow,background: linear-gradient, ..</p>
</li>
</ol>
</li>
</ol>
<h2 id="页面布局整体思路"><a href="#页面布局整体思路" class="headerlink" title="页面布局整体思路"></a>页面布局整体思路</h2><ol>
<li>必须确定页面的版心（可视区），我们测量可得知</li>
<li>分析页面中的行模块，以及每个行模块中的列模块（页面布局第一准则）</li>
<li>一行中的列模块经常浮动布局，先确定每个列的大小，之后确定列的位置（页面布局第二准则）</li>
<li>制作HTML页面。遵循先有结构，后有样式的原则，结构永远最重要</li>
<li>先理清楚布局结构，再写代码尤为重要，需要我们多写多积累</li>
</ol>
<h2 id="实际案例制作注意"><a href="#实际案例制作注意" class="headerlink" title="实际案例制作注意"></a>实际案例制作注意</h2><h3 id="导航栏"><a href="#导航栏" class="headerlink" title="导航栏"></a>导航栏</h3><ol>
<li>实际开发中，不会直接用链接a而是用li包含（li+a）的做法<ol>
<li>li + a语义更加清晰</li>
<li>直接用搜索引擎容易辨别为右堆砌关键字嫌疑（故意堆砌关键字容易被搜索引擎）影响网站排名</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS3和HTML5的新特性</title>
    <url>/2022/08/01/CSS3%E5%92%8CHTML5%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h1 id="HTML5新特性"><a href="#HTML5新特性" class="headerlink" title="HTML5新特性"></a>HTML5新特性</h1><h2 id="CSS初始化"><a href="#CSS初始化" class="headerlink" title="CSS初始化"></a>CSS初始化</h2><ol>
<li><p>不同浏览器对有些标签的默认值是不同的，为了消除不同浏览器对HTML文本呈现的差异，照顾浏览器的兼容，我们需要对CSS初始化</p>
</li>
<li><p>简单理解: CSS初始化是指重设浏览器的样式（也称为CSS reset）</p>
</li>
<li><p>每个网页都必须首先进行CSS初始化。</p>
</li>
</ol>
<h2 id="HTML5新特性-1"><a href="#HTML5新特性-1" class="headerlink" title="HTML5新特性"></a>HTML5新特性</h2><ol>
<li>HTML5 的新增特性主要是针对于以前的不足，增加了一些新的标签、新的表单和新的表单属性等。</li>
</ol>
<h2 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a>语义化标签</h2><ol>
<li><code>&lt;header&gt;</code> 头部标签</li>
<li><code>&lt;nav&gt;</code> 导航标签</li>
<li><code>&lt;article&gt;</code> 内容标签</li>
<li><code>&lt;section&gt;</code> 定义文档某个区域</li>
<li><code>&lt;aside&gt;</code> 侧边栏标签</li>
<li><code>&lt;footer&gt;</code> 尾部标签</li>
</ol>
<h2 id="多媒体标签"><a href="#多媒体标签" class="headerlink" title="多媒体标签"></a>多媒体标签</h2><ol>
<li><p>多媒体标签分为 音频audio和视频video两个标签 使用它们，我们可以很方便的在页面中嵌入音频和视频，而不再去使用落后的flash和其他浏览器插件了。</p>
</li>
<li><p>视频标签-video</p>
<ol>
<li>语法：<code>&lt;video src=&quot;media/mi.mp4&quot;&gt;&lt;/video&gt;</code></li>
</ol>
</li>
<li><p>视频常见属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>autoplay</td>
<td>autoplay</td>
<td>视频就绪自动播放（谷歌浏览器需要添加muted来解决自动播放的问题）</td>
</tr>
<tr>
<td>controls</td>
<td>controls</td>
<td>向用户显示播放控件</td>
</tr>
<tr>
<td>width</td>
<td>pixels（像素）</td>
<td>设置播放器宽度</td>
</tr>
<tr>
<td>height</td>
<td>pixels（像素）</td>
<td>设置播放器高度</td>
</tr>
<tr>
<td>loop</td>
<td>loop</td>
<td>播放完是否继续播放该视频，循环播放</td>
</tr>
<tr>
<td>preload</td>
<td>auto（预先加载视频）none（不加载视频）</td>
<td>规定是否预先加载视频（如果有了autoplay则忽略该属性）</td>
</tr>
<tr>
<td>src</td>
<td>url</td>
<td>视频url地址</td>
</tr>
<tr>
<td>poster</td>
<td>imgurl</td>
<td>加载等待的画面图片</td>
</tr>
<tr>
<td>muted</td>
<td>muted</td>
<td>静音播放</td>
</tr>
</tbody></table>
<ol start="2">
<li><p>音频常见属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>autoplay</td>
<td>autoplay</td>
<td>如果出现该属性，则音频在就绪后立即播放（谷歌浏览器不支持）</td>
</tr>
<tr>
<td>controls</td>
<td>controls</td>
<td>如果出现该属性，则向用户显示控件，比如播放按钮</td>
</tr>
<tr>
<td>loop</td>
<td>loop</td>
<td>如果出现该属性，则当音频结束时重新开始播放</td>
</tr>
<tr>
<td>src</td>
<td>url</td>
<td>要播放音频的URL</td>
</tr>
</tbody></table>
</li>
<li><p>多媒体标签总结</p>
<ol>
<li>音频标签和视频标签使用方式基本一致</li>
<li>浏览器支持情况不同</li>
<li>谷歌浏览器把音频和视频自动播放禁止 了</li>
<li>可以给视频标签添加muted属性来静音播放视频，音频不可以（通过JavaScript解决）</li>
<li>视频标签是重点，经常设置自动播放，不使用controls控件，循环和设置大小属性</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="新增的表单元素"><a href="#新增的表单元素" class="headerlink" title="新增的表单元素"></a>新增的表单元素</h2><ol>
<li><p>重点记忆：number tel search这三个</p>
</li>
<li><p>属性值</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>type=&quot;email&quot;</code></td>
<td>限制用户输入必须为email类型</td>
</tr>
<tr>
<td><code>type=&quot;url&quot;</code></td>
<td>限制用户输入必须为url类型</td>
</tr>
<tr>
<td><code>type=&quot;date&quot;</code></td>
<td>限制用户输入必须为日期类型</td>
</tr>
<tr>
<td><code>type=&quot;time&quot;</code></td>
<td>限制用户输入必须为时间类型</td>
</tr>
<tr>
<td><code>type=&quot;month&quot;</code></td>
<td>限制用户输入必须为月类型</td>
</tr>
<tr>
<td><code>type=&quot;week&quot;</code></td>
<td>限制用户输入必须为周类型</td>
</tr>
<tr>
<td><code>type=&quot;number&quot;</code></td>
<td>限制用户输入必须为数字类型</td>
</tr>
<tr>
<td><code>type=&quot;tel&quot;</code></td>
<td>电话号码</td>
</tr>
<tr>
<td><code>type=&quot;search&quot;</code></td>
<td>搜索框</td>
</tr>
<tr>
<td><code>type=&quot;color&quot;</code></td>
<td>生成一个颜色选择表单</td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="HTML5新增表单属性"><a href="#HTML5新增表单属性" class="headerlink" title="HTML5新增表单属性"></a>HTML5新增表单属性</h2><ol>
<li><p>属性值</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>required</td>
<td>required</td>
<td>表单拥有该属性表示其内容不能为空，必填</td>
</tr>
<tr>
<td>placeholder</td>
<td>提示文本</td>
<td>表单的提示信息，存在默认值将不显示</td>
</tr>
<tr>
<td>autofocus</td>
<td>autofocus</td>
<td>自动聚焦属性，页面加载完成自动聚焦到指定表单</td>
</tr>
<tr>
<td>autocomplete</td>
<td>off&#x2F;on</td>
<td>当用户在字段开始键入时，浏览器基于之前键入过的值，应该显示出在字段中填写的选项；默认已经打开，如：autocomplete&#x3D;”on”，关闭autocomplete&#x3D;”off”需要放在表单内，同时加上name属性，同时成功提交</td>
</tr>
<tr>
<td>multiple</td>
<td>multiple</td>
<td>可以多选提交文件</td>
</tr>
</tbody></table>
</li>
<li><p>注意：可以通过设置以下方式修改placehoder里面的字体颜色</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">input::placeholder &#123;</span><br><span class="line">  color: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="CSS3新特性"><a href="#CSS3新特性" class="headerlink" title="CSS3新特性"></a>CSS3新特性</h1><h2 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h2><ol>
<li>属性选择器，按照字面意思，都是根据标签中的属性来选择元素</li>
</ol>
<ul>
<li>E[att]   选择具有att属性的E元素</li>
<li>E[att&#x3D;”val“]   选择具有att属性且属性值等于val的E元素</li>
<li>E[att^&#x3D;”val“]    匹配具有att属性且值以val开头的E元素</li>
<li>E[att$&#x3D;”val“]    匹配具有att属性且值以val结尾的E元素</li>
<li>E[att*&#x3D;”val“]    匹配具有att属性且值中含有val的E元素</li>
</ul>
<ol start="2">
<li>属性选择器，类选择器，伪类选择器，权重都为10<ul>
<li>例：div[class^&#x3D;icon]权重为11；其中div为标签选择器，权重为1；class^&#x3D;icon为属性选择器，权重为10</li>
</ul>
</li>
</ol>
<h2 id="结构伪类选择器"><a href="#结构伪类选择器" class="headerlink" title="结构伪类选择器"></a>结构伪类选择器</h2><ol>
<li><p>结构伪类选择器主要根据文档结构来选择器元素，常用于根据父级选择器里面的子元素</p>
</li>
<li><p>nth-child</p>
<table>
<thead>
<tr>
<th>选择符</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td>E:first-child</td>
<td>匹配父元素中的第一个子元素E</td>
</tr>
<tr>
<td>E:last-child</td>
<td>匹配父元素中最后一个子元素E</td>
</tr>
<tr>
<td>E:nth-child(n)</td>
<td>匹配父元素中的第n个子元素E</td>
</tr>
</tbody></table>
<ol>
<li><p>选择某个父元素的一个或者多个特定的子元素</p>
<ul>
<li><p>n可以是数字，关键字和公式</p>
</li>
<li><p>n如果可以是数字，就是选择第n个子元素，里面数字从1开始</p>
</li>
<li><p>n可以是关键字：even偶数，odd奇数</p>
</li>
<li><p>n可以是公式：常见的公式如下（如果n是公式，则从0开始计算，但是第0个元素或者超出了元素的个数会被忽略）</p>
<table>
<thead>
<tr>
<th>公式</th>
<th>取值</th>
</tr>
</thead>
<tbody><tr>
<td>2n</td>
<td>偶数</td>
</tr>
<tr>
<td>2n+1</td>
<td>奇数</td>
</tr>
<tr>
<td>5n</td>
<td>5的倍数</td>
</tr>
<tr>
<td>n+5</td>
<td>从第5个开始（包含第五个）到最后</td>
</tr>
<tr>
<td>-n+5</td>
<td>前5个（包含第5个）</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ol>
</li>
<li><p>nth-of-type</p>
<table>
<thead>
<tr>
<th>选择符</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td>E:first-of-type</td>
<td>指定类型E的第一个</td>
</tr>
<tr>
<td>E:last-of-type</td>
<td>指定类型E的最后一个</td>
</tr>
<tr>
<td>E:nth-of-type(n)</td>
<td>指定类型E的第n个,公式同上</td>
</tr>
</tbody></table>
</li>
<li><p>区别（重点）</p>
<ol>
<li>nth-child：对父类元素里面所有孩子排序选择（序号是固定的）先找到第n个孩子，然后看是否和E匹配</li>
<li>nth-of-type：对父类元素里面指定子元素进行排序选择；先去匹配E，然后再根据E找第n个孩子</li>
</ol>
</li>
</ol>
<h2 id="伪元素选择器（重点）"><a href="#伪元素选择器（重点）" class="headerlink" title="伪元素选择器（重点）"></a>伪元素选择器（重点）</h2><ol>
<li><p>伪元素选择器可以帮助我们利用CSS创建新标签元素，而不需要HTML标签，从而简化HTML结构</p>
<table>
<thead>
<tr>
<th>选择符</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td>::before</td>
<td>在元素内部的前面插入元素</td>
</tr>
<tr>
<td>::after</td>
<td>在元素内部的后面插入元素</td>
</tr>
</tbody></table>
</li>
<li><p>注意：</p>
<ol>
<li>before和after创建一个元素，但是属于行内元素</li>
<li>新创建的这个元素在文档树中是找不到的，所以我们称为伪元素</li>
<li>语法：element::before{}   </li>
<li>before和after必须有content属性 </li>
<li>before在父元素内容的前面创建元素，after在父元素内容的后面插入元素</li>
<li>伪元素选择器和标签选择器一样，权重为1</li>
</ol>
</li>
<li><p>伪元素应用场景</p>
<p>伪元素选择器使用场景3：伪元素清除浮动</p>
<ul>
<li>after伪元素清除浮动<br><img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20210922004949.png" alt="img"></li>
<li>双伪元素清除浮动<br><img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20210922005017.png" alt="img"></li>
</ul>
</li>
</ol>
<h2 id="盒子模型（重点）"><a href="#盒子模型（重点）" class="headerlink" title="盒子模型（重点）"></a>盒子模型（重点）</h2><ol>
<li><p>CSS3中可以通过 box-sizing 来指定盒模型，有2个值：即可指定为content-box、border-box，这样我们计算盒子大小的方式就发生了改变</p>
</li>
<li><p>可以分成两种情况：</p>
<ol>
<li>box-sizing: content-box盒子大小为width+padding+border（以前默认的）</li>
<li>box-sizing: border-box盒子大小为width</li>
</ol>
</li>
<li><p>如果盒子模型我们改为了box-sizing: border-box，那padding和border就不会撑大盒子了（前提padding和border不会超过width宽度）</p>
</li>
</ol>
<h2 id="CSS3其他特性"><a href="#CSS3其他特性" class="headerlink" title="CSS3其他特性"></a>CSS3其他特性</h2><h3 id="CSS3滤镜filter"><a href="#CSS3滤镜filter" class="headerlink" title="CSS3滤镜filter"></a>CSS3滤镜filter</h3><ol>
<li><p>filter: CSS属性将模糊或颜色偏移等图形效果应用于元素</p>
</li>
<li><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">filter:函数(); --&gt; 例如:filter: blur(5px); --&gt; blur模糊处理数值越大越模糊</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="CSS3的calc函数"><a href="#CSS3的calc函数" class="headerlink" title="CSS3的calc函数"></a>CSS3的calc函数</h3><ol>
<li><p>calc():此CSS函数让你在声明CSS属性值时执行一些计算</p>
</li>
<li><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">width: calc(100% - 80px);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>括号里面可以使用 + - *  &#x2F; 来进行计算</p>
<h2 id="CSS3过渡（重点）"><a href="#CSS3过渡（重点）" class="headerlink" title="CSS3过渡（重点）"></a>CSS3过渡（重点）</h2><ol>
<li><p>过渡（transition）是CSS3中具有颠覆性的特征之一，我们可以在不使用Flash动画或 JavaScript的情况下，当元素从一种样式变换为另一种样式时为元素添加效果。</p>
</li>
<li><p>过渡动画：是从一个状态 渐渐的过渡到另外一个状态</p>
</li>
<li><p>我们现在经常和:hover 一起 搭配使用。</p>
</li>
<li><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">transition: 要过渡的属性  花费时间  运动曲线  何时开始;</span><br></pre></td></tr></table></figure>
</li>
<li><p>属性值</p>
<ol>
<li><p>属性：想要变化的css属性，宽度高度背景颜色内外边距都可以。如果想要所有的属性都变化过渡，写一个all</p>
</li>
<li><p>花费时间：单位是秒（必须写单位）比如0.5s </p>
</li>
<li><p>运动曲线：默认是ease（可以省略）</p>
</li>
<li><p>何时开始：单位是秒（必须写单位）可以设置延迟触发时间默认是0s（可以省略）</p>
</li>
<li><p>后面两个属性可以省略</p>
</li>
<li><p>记住过渡的使用口诀：谁做过渡给谁加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        div &#123;</span><br><span class="line">            width: 200px;</span><br><span class="line">            height: 80px;</span><br><span class="line">            background-color: pink;</span><br><span class="line">            /* transition: width 1s; */</span><br><span class="line">            /* 想要写多个属性，则用逗号进行分隔 */</span><br><span class="line">            transition: width 1s, hight 1s;</span><br><span class="line">            /* 所有的属性都需要变化过渡,则属性值为all,开发中常用 */</span><br><span class="line">            transition: all 1s;</span><br><span class="line">            border-top-right-radius: 100px;</span><br><span class="line">            border-bottom-right-radius: 100px;</span><br><span class="line">        &#125;</span><br><span class="line">        div:hover &#123;</span><br><span class="line">            width: 700px;</span><br><span class="line">            height: 300px;</span><br><span class="line">            background-color: skyblue;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h1 id="2D转换"><a href="#2D转换" class="headerlink" title="2D转换"></a>2D转换</h1><ol>
<li>transform是CSS3中具有颠覆性的特征之一，可以实现多元素的位移，旋转缩放等效果<ol>
<li>移动：translate</li>
<li>旋转：rotate</li>
<li>缩放：scale</li>
</ol>
</li>
</ol>
<h2 id="二维坐标系"><a href="#二维坐标系" class="headerlink" title="二维坐标系"></a>二维坐标系</h2><ol>
<li>2D转换是改变在二维平面上的位置和1形状的一种技术</li>
<li>网页二维坐标系：x轴正轴水平向右，y轴正轴水平向下</li>
</ol>
<h2 id="转换之移动translate"><a href="#转换之移动translate" class="headerlink" title="转换之移动translate"></a>转换之移动translate</h2><ol>
<li><p>2D移动还是2D转换里面的一种功能，可以改变元素在页面中的位置，类似定位</p>
</li>
<li><p>语法：</p>
<ol>
<li>transform：translate(x,y);</li>
<li>分开写：<ul>
<li>transform: translateX(n);</li>
<li>transform: translateY(n);</li>
</ul>
</li>
</ol>
</li>
<li><p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    div &#123;</span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 200px;</span><br><span class="line">        background-color: skyblue;</span><br><span class="line">        /* transform：translate(x,y); */</span><br><span class="line">        transform: translate(100px, 100px);</span><br><span class="line">        /* transform: translateX(n); */</span><br><span class="line">        transform: translateX(100px);</span><br><span class="line">        /* transform: translateY(n); */</span><br><span class="line">        transform: translateY(100px);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重点：</p>
<ol>
<li>定义2D转换中的移动，沿着X和Y轴移动元素</li>
<li>translate最大的优点：不会影响到其他元素的位置</li>
<li>translate中的百分比单位是相对于自身元素的translate:(50%, 50%);</li>
<li>对行内标签没有效果</li>
</ol>
</li>
<li><p>小技巧：让盒子实现水平垂直居中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        div &#123;</span><br><span class="line">            position: relative;</span><br><span class="line">            width: 500px;</span><br><span class="line">            height: 500px;</span><br><span class="line">            background-color: skyblue;</span><br><span class="line">        &#125;</span><br><span class="line">        p &#123;</span><br><span class="line">            position: absolute;</span><br><span class="line">            /* 定位 */</span><br><span class="line">            top: 50%;</span><br><span class="line">            left: 50%;</span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background-color: pink;</span><br><span class="line">            /* 移动 */</span><br><span class="line">            transform: translate(-50%, -50%);</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p&gt;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="转换之2D旋转rotate"><a href="#转换之2D旋转rotate" class="headerlink" title="转换之2D旋转rotate"></a>转换之2D旋转rotate</h2><ol>
<li><p>2D旋转是指让元素在2维平面内顺时针旋转或者逆时针旋转</p>
</li>
<li><p>语法</p>
<ul>
<li>transform: rotate(度数)</li>
</ul>
</li>
<li><p>重点</p>
<ol>
<li>rotate里面跟度数，单位是deg 比如: totate(45deg)</li>
<li>角度为正时，顺时针；角度为负时，为逆时针</li>
<li>默认旋转的中心点是元素的中心点</li>
</ol>
</li>
<li><p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        img &#123;</span><br><span class="line">            width: 200px;</span><br><span class="line">            height: 200px;</span><br><span class="line">            border: 2px solid pink;</span><br><span class="line">            border-radius: 100px;</span><br><span class="line">            transition: all 1s;</span><br><span class="line">        &#125;</span><br><span class="line">        img:hover &#123;</span><br><span class="line">            /* rotate旋转 */</span><br><span class="line">            transform: rotate(360deg);</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;img src=&quot;../../images/fat.png&quot; alt=&quot;&quot;&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>2D转换中心点transform-origin</p>
<ol>
<li><p>语法：</p>
<ul>
<li>transform-origin: x y;</li>
</ul>
</li>
<li><p>重点</p>
<ul>
<li>注意后面参数x和y要用空格隔开</li>
<li>x y 默认转换的中心点是元素的中心点(50% 50%)</li>
<li>还可以给x y设置像素或者方位名词(top bottom left right center)</li>
</ul>
</li>
<li><p>例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        div &#123;</span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background-color: skyblue;</span><br><span class="line">            margin: 200px auto;</span><br><span class="line">            transition: all 1s;</span><br><span class="line">            /* 旋转中心点为左下角 */</span><br><span class="line">            transform-origin: left bottom;</span><br><span class="line">            /* 旋转中心点为距离盒子上边框和左边框各30px */</span><br><span class="line">            transform-origin: 30px 30px;</span><br><span class="line">        &#125;</span><br><span class="line">        div:hover &#123;</span><br><span class="line">            transform: rotate(360deg)</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="2D转换之缩放scale"><a href="#2D转换之缩放scale" class="headerlink" title="2D转换之缩放scale"></a>2D转换之缩放scale</h2><ol>
<li><p>缩放：可以将元素放大和缩小。只要给元素添加上这个属性就能控制它放大或缩小</p>
</li>
<li><p>语法</p>
<ul>
<li>transform: scale(x, y);</li>
</ul>
</li>
<li><p>注意</p>
<ol>
<li>注意其中的x和y用逗号分隔</li>
<li>transform: scale(1, 1)：宽和高都放大了一倍，相当于没有放大</li>
<li>transform: scale(2, 2)：宽和高都放大了2倍</li>
<li>transform: scale(2)：只写一个参数，第二个参数则和第一个参数一样，相当于scale(2, 2)</li>
<li>transform: scale(0.5, 0.5)：缩小</li>
<li>sacle缩放的最大优势：可以设置转换中心点缩放，默认以中心点缩放，而且不影响其他盒子</li>
</ol>
</li>
<li><p>演示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        div &#123;</span><br><span class="line">            width: 200px;</span><br><span class="line">            height: 200px;</span><br><span class="line">            background-color: skyblue;</span><br><span class="line">            margin: 100px auto;</span><br><span class="line">            transition: all 1s;</span><br><span class="line">        &#125;</span><br><span class="line">        div:hover &#123;</span><br><span class="line">            /* transform: scale(2, 2)：宽和高都放大了2倍 */</span><br><span class="line">            /* transform: scale(2, 2); */</span><br><span class="line">            /* transform: scale(2)：只写一个参数，第二个参数则和第一个参数一样，相当于scale(2, 2) */</span><br><span class="line">            /* transform: scale(2); */</span><br><span class="line">            /* transform: scale(0.5, 0.5)：缩小 */</span><br><span class="line">            transform: scale(0.5, 0.5);</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="2D转换综合写法"><a href="#2D转换综合写法" class="headerlink" title="2D转换综合写法"></a>2D转换综合写法</h2><ol>
<li><p>注意</p>
<ol>
<li><p>同时使用多个转换，语法为：</p>
<ul>
<li>ransform: translate() rotate() scale();</li>
</ul>
</li>
<li><p>其顺序会影响转换的效果（先旋转会改变坐标轴的方向）</p>
</li>
<li><p>当我们同时有位移和其他属性的时候，记得要将位移放到最前面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    div &#123;</span><br><span class="line">        width: 150px;</span><br><span class="line">        height: 150px;</span><br><span class="line">        background-color: pink;</span><br><span class="line">        transition: all 0.5s;</span><br><span class="line">    &#125;</span><br><span class="line">    div:hover &#123;</span><br><span class="line">        transform: translate(200px, 100px) rotate(180deg) scale(1.5);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h1 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h1><ol>
<li>动画是CSS3中具有颠覆性的特征之一，可以通过设置多个节点来精确控制一个或一组动画，常用来实现复杂的动画效果；相比于过度，动画可以实现更多变化，更多控制，连续自动播放等效果</li>
<li>制作动画分为两步<ol>
<li>定义动画</li>
<li>使用（调用）动画</li>
</ol>
</li>
</ol>
<h2 id="动画的基本使用"><a href="#动画的基本使用" class="headerlink" title="动画的基本使用"></a>动画的基本使用</h2><ol>
<li>0%是动画的开始，100%是动画的完成。这样的规则就是动画序列</li>
<li>在@keyframes中规定某项CSS样式，就能创建由当前样式逐渐改为新样式的动画效果</li>
<li>动画是使元素从一种样式逐渐变化为另一种样式的效果，可以改变任意多的样式任意多的次数</li>
<li>请用百分比来规定变化发生的时间，或者关键词”from”和”to”，等同于0%和100%</li>
</ol>
<h3 id="用keyframes定义动画（类似定义类选择器）"><a href="#用keyframes定义动画（类似定义类选择器）" class="headerlink" title="用keyframes定义动画（类似定义类选择器）"></a>用keyframes定义动画（类似定义类选择器）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@keyframes 动画名称 &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="元素使用动画"><a href="#元素使用动画" class="headerlink" title="元素使用动画"></a>元素使用动画</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">  width: 200px;</span><br><span class="line">  height: 200px;</span><br><span class="line">  background-color: aqua;</span><br><span class="line">  margin: 100px auto;</span><br><span class="line">  /* 调用动画 */</span><br><span class="line">  animation-name: 动画名称；</span><br><span class="line">  /* 持续时间 */</span><br><span class="line">  animation-duration: 持续时间； </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    /* 定义动画 */</span><br><span class="line">    @keyframes move &#123;</span><br><span class="line">        0% &#123;</span><br><span class="line">            transform: translate(0, 0);</span><br><span class="line">        &#125;</span><br><span class="line">        25% &#123;</span><br><span class="line">            transform: translate(800px, 0);</span><br><span class="line">        &#125;</span><br><span class="line">        50% &#123;</span><br><span class="line">            transform: translate(800px, 500px);</span><br><span class="line">        &#125;</span><br><span class="line">        75% &#123;</span><br><span class="line">            transform: translate(0, 500px);</span><br><span class="line">        &#125;</span><br><span class="line">        100% &#123;</span><br><span class="line">            transform: translate(0, 0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    div &#123;</span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 100px;</span><br><span class="line">        background-color: pink;</span><br><span class="line">        /* 调用动画 */</span><br><span class="line">        animation-name: move;</span><br><span class="line">        /* 持续时间 */</span><br><span class="line">        animation-duration: 8s;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h2 id="动画常见属性"><a href="#动画常见属性" class="headerlink" title="动画常见属性"></a>动画常见属性</h2><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>@keyframes</td>
<td>规定动画</td>
</tr>
<tr>
<td>animation</td>
<td>所有动画属性的简写属性，除了animation-play-state属性</td>
</tr>
<tr>
<td>animation-name</td>
<td>规定@keyframes动画的名称（必须的）</td>
</tr>
<tr>
<td>animation-duration</td>
<td>规定动画完成一个周期所花费的秒或毫秒，默认是0（必须的）</td>
</tr>
<tr>
<td>animation-timing-function</td>
<td>规定动画的速度曲线，默认是“ease”，匀速“linear”</td>
</tr>
<tr>
<td>animation-delay</td>
<td>规定动画何时开始，默认是0</td>
</tr>
<tr>
<td>animation-iteration-count</td>
<td>规定动画被播放次数，默认是1，还有infinite(无限)—–iteration（匀速的）</td>
</tr>
<tr>
<td>animation-direction</td>
<td>规定动画是否在下一周期逆向播放，默认是“normal”，“alternate”为逆向播放</td>
</tr>
<tr>
<td>animation-play-state</td>
<td>规定动画是否正在运行或暂停。默认是运行“running”，暂停“paused”</td>
</tr>
<tr>
<td>animation-fill-mode</td>
<td>规定动画结束后状态，保持forward，回到起始backwards</td>
</tr>
</tbody></table>
<ol>
<li><p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  @keyframes move &#123;</span><br><span class="line">      0% &#123;</span><br><span class="line">          transform: translateX(0, 0);</span><br><span class="line">      &#125;</span><br><span class="line">      100% &#123;</span><br><span class="line">          transform: translate(1000px);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  div &#123;</span><br><span class="line">      width: 100px;</span><br><span class="line">      height: 100px;</span><br><span class="line">      background-color: pink;</span><br><span class="line">      /* @keyframes动画的名称 */</span><br><span class="line">      animation-name: move;</span><br><span class="line">      /* 规定动画完成一个周期所花费的秒或毫秒，默认是0 */</span><br><span class="line">      animation-duration: 3s;</span><br><span class="line">      /* 规定动画的速度曲线，默认是“ease” */</span><br><span class="line">      animation-timing-function: ease;</span><br><span class="line">      /* 规定动画何时开始，默认是0 */</span><br><span class="line">      animation-delay: 2s;</span><br><span class="line">      /* 规定动画被播放次数，默认是1，还有infinite(无限) */</span><br><span class="line">      animation-iteration-count: 3;</span><br><span class="line">      /* 规定动画是否在下一周期逆向播放，默认是“normal”，“alternate”为逆向播放 */</span><br><span class="line">      animation-direction: alternate;</span><br><span class="line">      /* 规定动画结束购状态，保持forward，回到起始backwards */</span><br><span class="line">      animation-fill-mode: backwards;</span><br><span class="line">  &#125;</span><br><span class="line">  div:hover &#123;</span><br><span class="line">      /* 规定动画是否正在运行或暂停。默认是运行“running”，暂停“paused” */</span><br><span class="line">      animation-play-state: paused;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="动画简写"><a href="#动画简写" class="headerlink" title="动画简写"></a>动画简写</h3><ol>
<li>animation: 动画名称 持续时间 运动曲线 何时开始 播放次数 是否反方向 动画起始或者结束的状态;</li>
<li>注意<ol>
<li>简写属性里面不包括animation-play-state（停止动画）</li>
<li>暂停动画：animation-play-state: puased; 经常和鼠标经过等其他配合使用</li>
<li>想要动画走回来，而不是直接跳回来：animation-direction: alternate;</li>
<li>盒子动画结束后，停在结束位置：animation-fill-mode: forwards;</li>
</ol>
</li>
</ol>
<h3 id="速度曲线细节"><a href="#速度曲线细节" class="headerlink" title="速度曲线细节"></a>速度曲线细节</h3><ol>
<li><p>animation-timing-function：规定动画的速度曲线，默认是“ease”</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>liner</td>
<td>动画从头到尾的速度是相同的，匀速</td>
</tr>
<tr>
<td>ease</td>
<td>默认。动画以低速开始，然后加快，在结束前变慢</td>
</tr>
<tr>
<td>ease-in</td>
<td>动画以低速开始</td>
</tr>
<tr>
<td>ease-in-out</td>
<td>动画以低速开始和结束</td>
</tr>
<tr>
<td>steps()</td>
<td>指定了时间函数中的间隔数量（步长）</td>
</tr>
</tbody></table>
</li>
</ol>
<h1 id="3D转换"><a href="#3D转换" class="headerlink" title="3D转换"></a>3D转换</h1><h2 id="三维坐标系"><a href="#三维坐标系" class="headerlink" title="三维坐标系"></a>三维坐标系</h2><ol>
<li>三维坐标是指的是立体空间，立体空间是由3个轴共同组成的<ol>
<li>x轴：水平向右—注意：x右边为正值，左边为负值</li>
<li>y轴：垂直向下—注意：y往下为正值，往上为负值</li>
<li>z轴：垂直屏幕—注意：z往外为正值，往内为负值</li>
</ol>
</li>
</ol>
<h2 id="3D移动-translate3d"><a href="#3D移动-translate3d" class="headerlink" title="3D移动 translate3d"></a>3D移动 translate3d</h2><ol>
<li><p>3D移动在2D移动的基础上多加了一个可以移动的方向，就是z轴方向</p>
<ol>
<li><p>transform: translateX(100px)：在x轴上移动</p>
</li>
<li><p>transform: translateY(100px)：在y轴上移动</p>
</li>
<li><p>transform: translateZ(100px)：在z轴上移动(注意：translateZ一般用px单位)</p>
</li>
<li><p>transform: translate3d(x, y, z)：其中x, y, z分别指移动的轴的方向的距离</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">div &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background-color: pink;</span><br><span class="line">    margin: 200px auto;</span><br><span class="line">    /* 在x轴上移动 */</span><br><span class="line">    transform: translateX(100px);</span><br><span class="line">    /* 在y轴上移动 */</span><br><span class="line">    transform: translateY(100px);</span><br><span class="line">    /* 在z轴上移动(注意：translateZ一般用px单位) */</span><br><span class="line">    transform: translateZ(100px);</span><br><span class="line">    /* 其中x, y, z分别指移动的轴的方向的距离 */</span><br><span class="line">    transform: translate3d(50px, 50px, 50px)</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="透视-perspective"><a href="#透视-perspective" class="headerlink" title="透视 perspective"></a>透视 perspective</h2><ol>
<li><p>近大远小</p>
</li>
<li><p>透视也称为视距：视距就是人的眼睛到屏幕的距离</p>
</li>
<li><p>透视的单位是像素</p>
</li>
<li><p>透视写在被观察元素的父盒子上面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    body &#123;</span><br><span class="line">        /* 透视写在被观察元素的父盒子上面 */</span><br><span class="line">        perspective: 200px;</span><br><span class="line">    &#125;</span><br><span class="line">    div &#123;</span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 100px;</span><br><span class="line">        background-color: pink;</span><br><span class="line">        margin: 200px auto;</span><br><span class="line">        transform: translateZ(100px);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>d：视距（透视），视距就是一个距离，人的眼睛到屏幕的距离</li>
<li>z：z轴，物体距离屏幕的距离，z轴越大（正值）我们看到的物体就愈大<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20210922004619.png" alt="img"></li>
</ol>
</li>
</ol>
<h2 id="3D转换-rotate3d"><a href="#3D转换-rotate3d" class="headerlink" title="3D转换 rotate3d"></a>3D转换 rotate3d</h2><ol>
<li>3D旋转指可以让元素在三维平面内沿着x轴，y轴，z轴或者自定义轴进行旋转</li>
<li>语法<ol>
<li>transform: rotateX(45deg)：沿着x轴正方向旋转45度</li>
<li>transform: rotateY(45deg)：沿着y轴正方向旋转45度</li>
<li>transform: rotateZ(45deg)：沿着z轴正方向旋转45度</li>
<li>transform3d: rotate3d(x, y, z, deg)：沿着自定义轴旋转deg角度（了解即可）</li>
</ol>
</li>
</ol>
<ul>
<li>x y z表示旋转轴的矢量<ul>
<li>例：transform3d: rotate3d(1, 1, 0, 45deg)</li>
<li>就是沿着x轴和y轴矢量方向的对角线旋转45deg</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    body &#123;</span><br><span class="line">        /* 透视写在被观察元素的父盒子上面 */</span><br><span class="line">        perspective: 300px;</span><br><span class="line">    &#125;</span><br><span class="line">    div &#123;</span><br><span class="line">        width: 320px;</span><br><span class="line">        height: 250px;</span><br><span class="line">        margin: 200px auto;</span><br><span class="line">        transition: all 1s;</span><br><span class="line">    &#125;</span><br><span class="line">    img &#123;</span><br><span class="line">        width: 100%;</span><br><span class="line">        height: 100%;</span><br><span class="line">    &#125;</span><br><span class="line">    div:hover &#123;</span><br><span class="line">        /* 沿着x轴正方向旋转45度 */</span><br><span class="line">        transform: rotateX(360deg);</span><br><span class="line">        /* 沿着y轴正方向旋转45度 */</span><br><span class="line">        transform: rotateY(360deg);</span><br><span class="line">        /* 沿着z轴正方向旋转45度 */</span><br><span class="line">        transform: rotateZ(360deg);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h2 id="3D呈现transform-style"><a href="#3D呈现transform-style" class="headerlink" title="3D呈现transform-style"></a>3D呈现transform-style</h2><ol>
<li><p>控制子元素是否开启三维立体环境</p>
</li>
<li><p>transfrom-style: flat;子元素不开启3d立体空间 默认的</p>
</li>
<li><p>transform-style: preserve-3d; 子元素开启立体空间</p>
</li>
<li><p>代码写给父级，但是影响的是子盒子</p>
</li>
<li><p>这个属性很重要，后面必用</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">&lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">body &#123;</span><br><span class="line">    perspective: 300px;</span><br><span class="line">&#125;</span><br><span class="line">.box &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    margin: 100px auto;</span><br><span class="line">    transition: all 1s;</span><br><span class="line">    /* 代码写给父级，但是影响的是子盒子 */</span><br><span class="line">    transform-style: preserve-3d;</span><br><span class="line">&#125;</span><br><span class="line">.box:hover &#123;</span><br><span class="line">    transform: rotateY(60deg);</span><br><span class="line">&#125;</span><br><span class="line">.box div &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 0;</span><br><span class="line">    left: 0;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 100%;</span><br><span class="line">&#125;</span><br><span class="line">.one &#123;</span><br><span class="line">    background-color: pink;</span><br><span class="line">&#125;</span><br><span class="line">.two &#123;</span><br><span class="line">    background-color: skyblue;</span><br><span class="line">    transform: rotateX(60deg);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;box&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;one&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;two&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS的元素显示模式和背景</title>
    <url>/2022/08/01/CSS%E7%9A%84%E5%85%83%E7%B4%A0%E6%98%BE%E7%A4%BA%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%83%8C%E6%99%AF/</url>
    <content><![CDATA[<h1 id="Emmet语法"><a href="#Emmet语法" class="headerlink" title="Emmet语法"></a>Emmet语法</h1><h2 id="快速生成HTML结构语法"><a href="#快速生成HTML结构语法" class="headerlink" title="快速生成HTML结构语法"></a>快速生成HTML结构语法</h2><ul>
<li>生成标签 直接输入标签名 按tab键即可   比如  div   然后tab 键， 就可以生成 <div></div></li>
<li>如果想要生成多个相同标签  加上 * 就可以了 比如   div*3  就可以快速生成3个div</li>
<li>如果有父子级关系的标签，可以用 &gt;  比如   ul &gt; li就可以了</li>
<li>如果有兄弟关系的标签，用  +  就可以了 比如 div+p  </li>
<li>如果生成带有类名或者id名字的，  直接写  .demo  或者  #two   tab 键就可以了</li>
<li>如果生成的div 类名是有顺序的， 可以用 自增符号  $ </li>
<li>如果想要在生成的标签内部写内容可以用  { }  表示</li>
</ul>
<h2 id="快速生成CSS样式语法"><a href="#快速生成CSS样式语法" class="headerlink" title="快速生成CSS样式语法"></a>快速生成CSS样式语法</h2><p>CSS 基本采取简写形式即可</p>
<p>​		比如 w200   按tab  可以 生成  width: 200px;</p>
<p>​		比如 lh26px   按tab  可以生成  line-height: 26px;</p>
<h2 id="快速格式化代码"><a href="#快速格式化代码" class="headerlink" title="快速格式化代码"></a>快速格式化代码</h2><p>Vscode  快速格式化代码:   shift+alt+f</p>
<p>也可以设置 当我们 保存页面的时候自动格式化代码:</p>
<p>1）文件 ——.&gt;【首选项】———-&gt;【设置】；</p>
<p>2）搜索emmet.include;</p>
<p>3）在settings.json下的【工作区设置】中添加以下语句：</p>
<p>​		“editor.formatOnType”: true,</p>
<p>​		“editor.formatOnSave”: true</p>
<h1 id="CSS的显示模式"><a href="#CSS的显示模式" class="headerlink" title="CSS的显示模式"></a>CSS的显示模式</h1><h2 id="什么是元素的显示模式"><a href="#什么是元素的显示模式" class="headerlink" title="什么是元素的显示模式"></a>什么是元素的显示模式</h2><p><strong>定义：</strong></p>
<p>​		元素显示模式就是元素（标签）以什么方式进行显示，比如<code>&lt;div&gt;</code>自己占一行，比如一行可以放多个<code>&lt;span&gt;</code>。</p>
<p><strong>作用：</strong></p>
<p>​		网页的标签非常多，在不同地方会用到不同类型的标签，了解他们的特点可以更好的布局我们的网页。</p>
<h3 id="块元素"><a href="#块元素" class="headerlink" title="块元素"></a>块元素</h3><ol>
<li><p>常见的块元素：<code>&lt;h1&gt;~&lt;h6&gt;、&lt;p&gt;、&lt;div&gt;、&lt;ul&gt;、&lt;ol&gt;、&lt;li&gt;</code>,其中<code>&lt;div&gt;</code>标签是最典型的块元素。</p>
</li>
<li><p>块级元素的特点： </p>
<ol>
<li>自己独占一行。</li>
<li>高度，宽度、外边距以及内边距都可以控制。</li>
<li>宽度默认是容器（父级宽度）的100%。</li>
<li>是一个容器及盒子，里面可以放行内或者块级元素。</li>
</ol>
</li>
<li><p>注意：  </p>
<ol>
<li>文字类的元素内不能放块级元素</li>
<li><code>&lt;p&gt;</code>标签主要用于存放文字，因此<code>&lt;p&gt;</code>里面不能放块级元素，尤其是<code>&lt;div&gt;</code></li>
</ol>
</li>
</ol>
<h3 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h3><ol>
<li><p>常见的行内元素：<code>&lt;a&gt;、&lt;strong&gt;、&lt;b&gt;、&lt;em&gt;、&lt;i&gt;、&lt;del&gt;、&lt;s&gt;、&lt;ins&gt;、&lt;u&gt;、&lt;span&gt;</code>其中<code>&lt;span&gt;</code> 标签是最典型的行内元素。有的地方也将行内元素称为内联元素。</p>
</li>
<li><p>行内元素的特点：</p>
<ol>
<li>相邻行内元素在一行上，一行可以显示多个。</li>
<li>高、宽直接设置是无效的。</li>
<li>默认宽度就是它本身内容的宽度。</li>
<li>行内元素只能容纳文本或其他行内元素。</li>
</ol>
</li>
<li><p>注意：</p>
<ol>
<li>链接里面不能再放链接</li>
<li>特殊情况链接 <code>&lt;a&gt;</code> 里面可以放块级元素，但是给 <code>&lt;a&gt;</code>转换一下块级模式最安全</li>
</ol>
</li>
</ol>
<h3 id="行内块元素"><a href="#行内块元素" class="headerlink" title="行内块元素"></a>行内块元素</h3><ol>
<li><p>常见的行内块标签：<code>&lt;img/&gt;、&lt;input/&gt;、&lt;td&gt;</code>它们同时具有块元素和行内元素的特点，有些资料称它们为行内块元素。</p>
</li>
<li><p>行内块元素的特点：</p>
<ol>
<li>和相邻行内元素（行内块）在一行上，但是他们之间会有空白缝隙。</li>
<li>一行可以显示多个（行内元素特点）。</li>
<li>默认宽度就是它本身内容的宽度（行内元素特点）。</li>
<li>高度，行高、外边距以及内边距都可以控制（块级元素特点）。</li>
</ol>
</li>
</ol>
<h2 id="元素显示模式的转换"><a href="#元素显示模式的转换" class="headerlink" title="元素显示模式的转换"></a>元素显示模式的转换</h2><ol>
<li>简单理解就是一个模式的元素需要另外一种模式的特性</li>
<li>转换方式<ol>
<li>转换为块元素：display:block;</li>
<li>转换为行内元素：display:inline;</li>
<li>转换为行内块：display: inline-block;</li>
</ol>
</li>
</ol>
<h2 id="元素显示模式"><a href="#元素显示模式" class="headerlink" title="元素显示模式"></a>元素显示模式</h2><table>
<thead>
<tr>
<th>元素模式</th>
<th>元素排列</th>
<th>设置样式</th>
<th>默认宽度</th>
<th>包含</th>
</tr>
</thead>
<tbody><tr>
<td>块级元素</td>
<td>一行只能放一个块级元素</td>
<td>以设置宽度高度</td>
<td>容器的100%</td>
<td>容器既可以包含任何标签</td>
</tr>
<tr>
<td>行内元素</td>
<td>一行可以放多个行内元素</td>
<td>不可以直接设置宽度高度</td>
<td>它本身内容的宽的</td>
<td>容纳文本或者其他行内元素</td>
</tr>
<tr>
<td>行内块元素</td>
<td>一行放多个行内块元素</td>
<td>可以设置宽度和高度</td>
<td>它本身内容的宽度</td>
<td></td>
</tr>
</tbody></table>
<h1 id="CSS的背景"><a href="#CSS的背景" class="headerlink" title="CSS的背景"></a>CSS的背景</h1><ol>
<li>通过 CSS 背景属性，可以给页面元素添加背景样式。</li>
<li>背景属性可以设置背景颜色、背景图片、背景平铺、背景图片位置、背景图像固定等。</li>
</ol>
<h2 id="背景颜色"><a href="#背景颜色" class="headerlink" title="背景颜色"></a>背景颜色</h2><pre><code>background-color 定义元素的背景颜色
</code></pre>
<h2 id="背景图片"><a href="#背景图片" class="headerlink" title="背景图片"></a>背景图片</h2><pre><code>background-image  定义元素的背景图片
</code></pre>
<p><strong>其他说明</strong>：</p>
<ol>
<li>实际开发常见于logo或者一些装饰性的小图片或者是超大的背景图片，优点是非常便于控制位置(精灵图也是一种运用场景)</li>
<li>注意：背景图片后面的地址，千万不要忘记加URL，同时里面的路径<strong>不要加引号</strong>。</li>
</ol>
<h2 id="背景平铺"><a href="#背景平铺" class="headerlink" title="背景平铺"></a>背景平铺</h2><pre><code>background-repeat 设置元素背景图像的平铺 
</code></pre>
<h2 id="背景图片位置"><a href="#背景图片位置" class="headerlink" title="背景图片位置"></a>背景图片位置</h2><pre><code>background-position 属性可以改变图片在背景中的位置
</code></pre>
<p><strong>其他说明：</strong></p>
<ol>
<li><p>参数是方位名词</p>
<ol>
<li>如果指定的两个值都是方位名词，则两个值前后顺序无关，比如 left  top 和 top  left 效果一致</li>
<li>如果只指定了一个方位名词，另一个值省略，则第二个值默认居中对齐</li>
</ol>
</li>
<li><p>参数是精确单位</p>
<ol>
<li>如果参数值是精确坐标，那么第一个肯定是 x 坐标，第二个一定是 y 坐标</li>
<li>如果只指定一个数值，那该数值一定是 x 坐标，另一个默认垂直居中</li>
</ol>
</li>
<li><p>参数是混合单位</p>
<ol>
<li>如果指定的两个值是精确单位和方位名词混合使用，则第一个值是 x 坐标，第二个值是 y 坐标</li>
</ol>
</li>
</ol>
<h2 id="背景图片固定"><a href="#背景图片固定" class="headerlink" title="背景图片固定"></a>背景图片固定</h2><pre><code>background-attachment 属性设置背景图像是否固定或者随着页面的其余部分滚动。
</code></pre>
<p><strong>其他说明：</strong></p>
<p>background-attachment 后期可以制作视差滚动的效果。</p>
<h2 id="背景样式合写"><a href="#背景样式合写" class="headerlink" title="背景样式合写"></a>背景样式合写</h2><pre><code>background: 背景颜色 背景图片地址 背景平铺 背景图像滚动 背景图片位置;
</code></pre>
<h2 id="背景色半透明"><a href="#背景色半透明" class="headerlink" title="背景色半透明"></a>背景色半透明</h2><p>CSS3 提供了背景颜色半透明的效果。 </p>
<ol>
<li>最后一个参数是 alpha 透明度，取值范围在 0~1之间</li>
<li>我们习惯把 0.3 的 0 省略掉，写为 background: rgba(0, 0, 0, .3);</li>
</ol>
<p><strong>注意</strong>：</p>
<ol>
<li>背景半透明是指盒子背景半透明，盒子里面的内容不受影响</li>
<li>CSS3新增属性，是IE9+版本浏览器才支持的，现在实际开发,不用太关注兼容性写法了</li>
</ol>
<h2 id="背景缩放"><a href="#背景缩放" class="headerlink" title="背景缩放"></a>背景缩放</h2><pre><code>background-size: 背景图片宽度 背景图片高度；
</code></pre>
<p><strong>其他说明：</strong></p>
<ol>
<li>单位：长度 | 百分比 | cover | contain<ol>
<li>cover把背景图片扩展至足够大，使背景图像完全覆盖背景区域</li>
<li>contain把图像扩展至最大尺寸，使其宽度和高度完全适应内容区域</li>
</ol>
</li>
</ol>
<h2 id="背景小结"><a href="#背景小结" class="headerlink" title="背景小结"></a>背景小结</h2><table>
<thead>
<tr>
<th>属性</th>
<th>作用</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>background-color</td>
<td>背景颜色</td>
<td>预定义的颜色值&#x2F;十六进制&#x2F;RGB代码</td>
</tr>
<tr>
<td>background-image</td>
<td>背景图片</td>
<td>url（图片路径）</td>
</tr>
<tr>
<td>background-repeat</td>
<td>是否平铺</td>
<td>repeat&#x2F;no-repeat&#x2F;repeat-x&#x2F;repeat-y</td>
</tr>
<tr>
<td>background-position</td>
<td>背景位置</td>
<td>length&#x2F;position 分别是x和y坐标</td>
</tr>
<tr>
<td>background-attachment</td>
<td>背景附着</td>
<td>scroll（背景滚动）&#x2F;fixed（背景固定）</td>
</tr>
<tr>
<td>背景简写</td>
<td>书写更简单</td>
<td>背景颜色 背景图片地址 背景平铺 背景图像滚动 背景图片位置</td>
</tr>
<tr>
<td>背景色半透明</td>
<td>背景颜色半透明</td>
<td>background：rgba(0,0,0,0.3); 后面必须是4个值</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS的精灵图、字体图标和用户界面样式</title>
    <url>/2022/08/01/CSS%E7%9A%84%E7%B2%BE%E7%81%B5%E5%9B%BE%E3%80%81%E5%AD%97%E4%BD%93%E5%9B%BE%E6%A0%87%E5%92%8C%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E6%A0%B7%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="精灵图（重点）、字体图标"><a href="#精灵图（重点）、字体图标" class="headerlink" title="精灵图（重点）、字体图标"></a>精灵图（重点）、字体图标</h1><h2 id="精灵图意义"><a href="#精灵图意义" class="headerlink" title="精灵图意义"></a>精灵图意义</h2><ol>
<li><p>为什么需要精灵图</p>
<ul>
<li>一个网页中往往会应用很多小的背景图像作为修饰，当网页中的图像过多时，服务器就会频繁地接收和发送请求图片，造成服务器请求压力过大，这将大大降低页面的加载速度。</li>
</ul>
</li>
<li><p>使用精灵图目的</p>
<ul>
<li>为了有效地减少服务器接收和发送请求的次数，提高页面的加载速度，出现了CSS精灵技术（也称CSS Sprites、CSS雪碧）。</li>
</ul>
</li>
<li><p>核心原理</p>
<ul>
<li>将网页中的一些小背景图像整合到一张大图中 ，这样服务器只需要一次请求就可以了。</li>
</ul>
</li>
</ol>
<h2 id="精灵图（sprites）的使用"><a href="#精灵图（sprites）的使用" class="headerlink" title="精灵图（sprites）的使用"></a>精灵图（sprites）的使用</h2><ol>
<li><p>使用精灵图核心：</p>
<ol>
<li>精灵技术主要针对于背景图片使用，就是把多个小背景图片整合到一张大图片中</li>
<li>这个大图片也称为sprites精灵图或者雪碧图</li>
<li>移动背景图片位置， 此时可以使用background-position </li>
<li>移动的距离就是这个目标图片的x和y坐标。注意网页中的坐标有所不同</li>
<li>因为一般情况下都是往上往左移动，所以数值是负值</li>
<li>使用精灵图的时候需要精确测量，每个小背景图片的大小和位置</li>
</ol>
</li>
<li><p>使用精灵图核心总结：</p>
<ol>
<li>精灵图主要针对于小的背景图片使用。</li>
<li>主要借助于背景位置来实现-background-position 。</li>
<li>一般情况下精灵图都是负值（千万注意网页中的坐标：x轴右边走是正值，左边走是负值，y轴同理）</li>
</ol>
</li>
</ol>
<h2 id="字体图标"><a href="#字体图标" class="headerlink" title="字体图标"></a>字体图标</h2><h3 id="字体图标的特点"><a href="#字体图标的特点" class="headerlink" title="字体图标的特点"></a>字体图标的特点</h3><ol>
<li>字体图标的优点<ol>
<li>轻量级：一个图标字体要比一系列的图像要小。一旦字体加载了，图标就会马上渲染出来，减少了服务器请求</li>
<li>灵活性：本质其实是文字，可以很随意的改变颜色、产生阴影、透明效果、旋转等</li>
<li>兼容性：几乎支持所有的浏览器，请放心使用</li>
</ol>
</li>
<li>注意： 字体图标不能替代精灵技术，只是对工作中图标部分技术的提升和优化。</li>
<li>总结：<ol>
<li>如果遇到一些结构和样式比较简单的小图标，就用字体图标。</li>
<li>如果遇到一些结构和样式复杂一点的小图片，就用精灵图。</li>
</ol>
</li>
</ol>
<h3 id="字体图标的下载"><a href="#字体图标的下载" class="headerlink" title="字体图标的下载"></a>字体图标的下载</h3><ol>
<li><a href="http://icomoon.io/">icomoon字库</a></li>
<li><a href="http://www.iconfont.cn/">阿里iconfont字库</a></li>
</ol>
<h3 id="字体图标的使用与引入"><a href="#字体图标的使用与引入" class="headerlink" title="字体图标的使用与引入"></a>字体图标的使用与引入</h3><ol>
<li><p>把下载包里面的fonts文件夹放入页面根目录下</p>
</li>
<li><p>在CSS样式中全局声明字体：简单理解把这些字体文件通过css引入到我们页面中；要注意字体文件路径的问题</p>
<ul>
<li><p>文件路径问题：路径需要根据字体图标文件夹icomoon中的style.css文件调用font文件夹中四个文件的路径而改变</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@font-face &#123;</span><br><span class="line">    font-family: &#x27;icomoon&#x27;;</span><br><span class="line">    src: url(&#x27;fonts/icomoon.eot?8axf2s&#x27;);</span><br><span class="line">    src: url(&#x27;fonts/icomoon.eot?8axf2s#iefix&#x27;) format(&#x27;embedded-opentype&#x27;),</span><br><span class="line">        url(&#x27;fonts/icomoon.ttf?8axf2s&#x27;) format(&#x27;truetype&#x27;),</span><br><span class="line">        url(&#x27;fonts/icomoon.woff?8axf2s&#x27;) format(&#x27;woff&#x27;),</span><br><span class="line">        url(&#x27;fonts/icomoon.svg?8axf2s#icomoon&#x27;) format(&#x27;svg&#x27;);</span><br><span class="line">    font-weight: normal;</span><br><span class="line">    font-style: normal;</span><br><span class="line">    font-display: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>html标签内添加字体图标</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    @font-face &#123;</span><br><span class="line">      font-family: &#x27;icomoon&#x27;;</span><br><span class="line">      src: url(&#x27;fonts/icomoon.eot?8axf2s&#x27;);</span><br><span class="line">      src: url(&#x27;fonts/icomoon.eot?8axf2s#iefix&#x27;) format(&#x27;embedded-opentype&#x27;),</span><br><span class="line">        url(&#x27;fonts/icomoon.ttf?8axf2s&#x27;) format(&#x27;truetype&#x27;),</span><br><span class="line">        url(&#x27;fonts/icomoon.woff?8axf2s&#x27;) format(&#x27;woff&#x27;),</span><br><span class="line">        url(&#x27;fonts/icomoon.svg?8axf2s#icomoon&#x27;) format(&#x27;svg&#x27;);</span><br><span class="line">      font-weight: normal;</span><br><span class="line">      font-style: normal;</span><br><span class="line">      font-display: block;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .one &#123;</span><br><span class="line">      /* font-family与上方导入的代码中的第一行需要保持相同 */</span><br><span class="line">      font-family: &#x27;icomoon&#x27;;</span><br><span class="line">      font-size: 50px;</span><br><span class="line">      color: pink;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .two &#123;</span><br><span class="line">      /* font-family与上方导入的代码中的第一行需要保持相同 */</span><br><span class="line">      font-family: &#x27;icomoon&#x27;;</span><br><span class="line">      font-size: 50px;</span><br><span class="line">      color: skyblue;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;span class=&quot;one&quot;&gt;&lt;/span&gt;</span><br><span class="line">  &lt;span class=&quot;two&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="字体图标追加"><a href="#字体图标追加" class="headerlink" title="字体图标追加"></a>字体图标追加</h3><ol>
<li>将压缩包内的selection.json重新上传即可，然后选中自己想要的新的图标，重新下载压缩包，并替换原来的文件</li>
<li>步骤<ol>
<li><a href="http://icomoon.io/">打开icomoon字库网址</a></li>
<li>点击左上角import icons按钮，弹出对话框，找到selection.json文件，打开，点击重新加载YES</li>
<li>开始选择新的字体图标，选择完毕后点击右下角generate font按钮，点击右下角download按钮下载</li>
</ol>
</li>
</ol>
<h3 id="通过类名调用字体图标（推荐）"><a href="#通过类名调用字体图标（推荐）" class="headerlink" title="通过类名调用字体图标（推荐）"></a>通过类名调用字体图标（推荐）</h3><ol>
<li>HTML页面中引入字体图标中css文件 — style.css<ul>
<li>注意修改style.css文件中的四个路径，修改方法见上</li>
</ul>
</li>
<li>标签直接调用图标对象的类名即可（类名在style.css文件中标注，或直接打开dome.html文件查询）</li>
</ol>
<h2 id="CSS三角"><a href="#CSS三角" class="headerlink" title="CSS三角"></a>CSS三角</h2><ol>
<li>代码参考</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;CSS 三角制作&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .box1 &#123;</span><br><span class="line">            width: 0;</span><br><span class="line">            height: 0;</span><br><span class="line">            /* border: 10px solid pink; */</span><br><span class="line">            border-top: 10px solid pink;</span><br><span class="line">            border-right: 10px solid red;</span><br><span class="line">            border-bottom: 10px solid blue;</span><br><span class="line">            border-left: 10px solid green;</span><br><span class="line">        &#125;</span><br><span class="line">        .box2 &#123;</span><br><span class="line">            width: 0;</span><br><span class="line">            height: 0;</span><br><span class="line">            border: 50px solid transparent;</span><br><span class="line">            border-left-color: pink;</span><br><span class="line">            margin: 100px auto;</span><br><span class="line">        &#125;</span><br><span class="line">        .jd &#123;</span><br><span class="line">            position: relative;</span><br><span class="line">            width: 120px;</span><br><span class="line">            height: 249px;</span><br><span class="line">            background-color: pink;</span><br><span class="line">        &#125;</span><br><span class="line">        .jd span &#123;</span><br><span class="line">            position: absolute;</span><br><span class="line">            right: 15px;</span><br><span class="line">            top: -10px;</span><br><span class="line">            width: 0;</span><br><span class="line">            height: 0;</span><br><span class="line">            /* 为了照顾兼容性 */</span><br><span class="line">            line-height: 0;  </span><br><span class="line">            font-size: 0;</span><br><span class="line">            border: 5px solid transparent;</span><br><span class="line">            border-bottom-color: pink;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;jd&quot;&gt;</span><br><span class="line">        &lt;span&gt;&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>



<h1 id="CSS用户界面样式"><a href="#CSS用户界面样式" class="headerlink" title="CSS用户界面样式"></a>CSS用户界面样式</h1><h2 id="鼠标样式cursor"><a href="#鼠标样式cursor" class="headerlink" title="鼠标样式cursor"></a>鼠标样式cursor</h2><ol>
<li><p>设置或检索在对象上移动的鼠标指针采用何种系统预定义的光标形状</p>
</li>
<li><p>语法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">li &#123;</span><br><span class="line">   cursor: pointer; </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>属性值</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>default</td>
<td>小白 默认</td>
</tr>
<tr>
<td>pointer</td>
<td>小手</td>
</tr>
<tr>
<td>move</td>
<td>移动</td>
</tr>
<tr>
<td>text</td>
<td>文本</td>
</tr>
<tr>
<td>not-allowed 禁止</td>
<td></td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="轮廓线outline"><a href="#轮廓线outline" class="headerlink" title="轮廓线outline"></a>轮廓线outline</h2><ol>
<li><p>给表单添加 outline: 0; 或者outline: none; 样式之后，就可以去掉默认的蓝色边框。</p>
</li>
<li><p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">     outline: none; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="防止拖拽文本域resize"><a href="#防止拖拽文本域resize" class="headerlink" title="防止拖拽文本域resize"></a>防止拖拽文本域resize</h2><ol>
<li><p>实际开发中，我们文本域右下角是不可以拖拽的。</p>
</li>
<li><p>语法</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">textarea</span>&#123; </span><br><span class="line">       <span class="attribute">resize</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="vertical-align属性应用"><a href="#vertical-align属性应用" class="headerlink" title="vertical-align属性应用"></a>vertical-align属性应用</h2><ol>
<li><p>CSS的vertical-align属性使用场景：经常用于设置图片或者表单（行内块元素）和文字垂直对齐。</p>
</li>
<li><p>官方解释: 用于设置一个元素的垂直对齐方式，但是它只针对于行内元素或者行内块元素有效。</p>
</li>
<li><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vertical-align : baseline | top | middle | bottom </span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>baseline</td>
<td>默认，元素放置在父元素的基线上</td>
</tr>
<tr>
<td>top</td>
<td>把元素的顶端与行中最高元素的顶端对齐</td>
</tr>
<tr>
<td>middle</td>
<td>把此元素放置在父元素的中部</td>
</tr>
<tr>
<td>bottom</td>
<td>把元素的顶端与行中最低的元素顶端对齐</td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="解决图片底部默认空白缝隙问题"><a href="#解决图片底部默认空白缝隙问题" class="headerlink" title="解决图片底部默认空白缝隙问题"></a>解决图片底部默认空白缝隙问题</h2><ol>
<li><p>bug：图片底侧会有一个空白缝隙，原因是行内块元素会和文字的基线对齐。</p>
</li>
<li><p>解决方法有两种：</p>
<ol>
<li>给图片添加vertical-align:middle | top| bottom;（提倡使用的）</li>
<li>把图片转换为块级元素display: block;</li>
</ol>
</li>
</ol>
<h2 id="溢出的文字省略号显示"><a href="#溢出的文字省略号显示" class="headerlink" title="溢出的文字省略号显示"></a>溢出的文字省略号显示</h2><h3 id="单行文本溢出显示省略号"><a href="#单行文本溢出显示省略号" class="headerlink" title="单行文本溢出显示省略号"></a>单行文本溢出显示省略号</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*1. 先强制一行内显示文本*/</span><br><span class="line">white-space: nowrap;  （ 默认 normal 自动换行）</span><br><span class="line">   </span><br><span class="line">/*2. 超出的部分隐藏*/</span><br><span class="line">overflow: hidden;</span><br><span class="line">   </span><br><span class="line">/*3. 文字用省略号替代超出的部分*/</span><br><span class="line">text-overflow: ellipsis;</span><br></pre></td></tr></table></figure>

<h3 id="多行文本溢出显示省略号（了解）"><a href="#多行文本溢出显示省略号（了解）" class="headerlink" title="多行文本溢出显示省略号（了解）"></a>多行文本溢出显示省略号（了解）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*1. 超出的部分隐藏 */</span><br><span class="line">overflow: hidden;</span><br><span class="line"></span><br><span class="line">/*2. 文字用省略号替代超出的部分 */</span><br><span class="line">text-overflow: ellipsis;</span><br><span class="line"></span><br><span class="line">/* 3. 弹性伸缩盒子模型显示 */</span><br><span class="line">display: -webkit-box;</span><br><span class="line"></span><br><span class="line">/* 4. 限制在一个块元素显示的文本的行数 */</span><br><span class="line">-webkit-line-clamp: 2;</span><br><span class="line"></span><br><span class="line">/* 5. 设置或检索伸缩盒对象的子元素的排列方式 */</span><br><span class="line">-webkit-box-orient: vertical;</span><br></pre></td></tr></table></figure>



<h1 id="常见布局技巧"><a href="#常见布局技巧" class="headerlink" title="常见布局技巧"></a>常见布局技巧</h1><h2 id="margin负值运用"><a href="#margin负值运用" class="headerlink" title="margin负值运用"></a>margin负值运用</h2><p>1.让每个盒子margin 往左侧移动 -1px 正好压住相邻盒子边框</p>
<p>2.鼠标经过某个盒子的时候，提高当前盒子的层级即可（如果没有有定位，则加相对定位（保留位置），如果有定位，则加z-index）</p>
<h2 id="文字围绕浮动元素"><a href="#文字围绕浮动元素" class="headerlink" title="文字围绕浮动元素"></a>文字围绕浮动元素</h2><ol>
<li><p>文字会围绕图片显示，因为创造浮动的初衷就是做文字环绕效果的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        * &#123;</span><br><span class="line">            margin: 0;</span><br><span class="line">            padding: 0;</span><br><span class="line">        &#125;</span><br><span class="line">        .box &#123;</span><br><span class="line">            width: 270px;</span><br><span class="line">            height: 70px;</span><br><span class="line">            background-color: pink;</span><br><span class="line">            margin: 10px auto;</span><br><span class="line">            padding: 5px;</span><br><span class="line">        &#125;</span><br><span class="line">        .pic &#123;</span><br><span class="line">            float: left;</span><br><span class="line">            width: 120px;</span><br><span class="line">            height: 70px;</span><br><span class="line">            margin-right: 5px;</span><br><span class="line">        &#125;</span><br><span class="line">        img &#123;</span><br><span class="line">            width: 100%;</span><br><span class="line">            height: 100%;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;box&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;pic&quot;&gt;</span><br><span class="line">            &lt;img src=&quot;../images/bear.jpg&quot; alt=&quot;&quot;&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;p&gt;你好，你好呀&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="CSS三角强化"><a href="#CSS三角强化" class="headerlink" title="CSS三角强化"></a>CSS三角强化</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    .box1 &#123;</span><br><span class="line">        width: 0;</span><br><span class="line">        height: 0;</span><br><span class="line">        </span><br><span class="line">        /* 把上边框宽度调大 */</span><br><span class="line">        /* border-top: 100px solid transparent;</span><br><span class="line">        border-right: 50px solid skyblue; */</span><br><span class="line">        /* 左边和下边的边框宽度设置为0 */</span><br><span class="line">        /* border-bottom: 0 solid blue;</span><br><span class="line">        border-left: 0 solid green; */</span><br><span class="line">        </span><br><span class="line">        /* 1.只保留右边的边框有颜色 */</span><br><span class="line">        border-color: transparent red transparent transparent;</span><br><span class="line">        /* 2. 样式都是solid */</span><br><span class="line">        border-style: solid;</span><br><span class="line">        /* 3. 上边框宽度要大， 右边框 宽度稍小， 其余的边框该为 0 */</span><br><span class="line">        border-width: 100px 50px 0 0 ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS的选择器、属性、引入方式</title>
    <url>/2022/08/01/CSS%E7%9A%84%E9%80%89%E6%8B%A9%E5%99%A8%E3%80%81%E5%B1%9E%E6%80%A7%E3%80%81%E5%BC%95%E5%85%A5%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="CSS简介"><a href="#CSS简介" class="headerlink" title="CSS简介"></a>CSS简介</h1><ol>
<li>CSS是层叠样式表 ( Cascading Style Sheets ) 的简称，有时我们也会称之为 CSS 样式表或级联样式表。</li>
<li>CSS让我们的网页更加丰富多彩，布局更加灵活自如。简单理解：CSS 可以美化HTML, 让HTML更漂亮，让页面布局更简单。</li>
<li>CSS最大价值: 由 HTML 专注去做结构呈现，样式交给 CSS，即 结构 (HTML) 与样式(CSS) 相分离</li>
</ol>
<h1 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h1><ol>
<li>选择器分为基础选择器和复合选择器两大类</li>
</ol>
<h2 id="基础选择器（重点）"><a href="#基础选择器（重点）" class="headerlink" title="基础选择器（重点）"></a>基础选择器（重点）</h2><ol>
<li>基础选择器是由单个选择器组成的</li>
<li>基础选择器又包括：签选择器，类选择器，id选择器，通配符选择器</li>
<li>要对那个标签里面的数据进行操作</li>
</ol>
<h3 id="基础选择器之标签选择器"><a href="#基础选择器之标签选择器" class="headerlink" title="基础选择器之标签选择器"></a>基础选择器之标签选择器</h3><ol>
<li>使用标签名作为选择器的名称</li>
<li>作用：标签选择器可以把某一类标签全部选择出来</li>
<li>优点：可以快速为页面中同类型的标签统一设置样式</li>
<li>缺点：不能设计差异化样式，只能选择全部的当前标签</li>
</ol>
<h3 id="基础选择器之类选择器"><a href="#基础选择器之类选择器" class="headerlink" title="基础选择器之类选择器"></a>基础选择器之类选择器</h3><ol>
<li>口诀：样式点定义，结构类调用，一个或多个，开发最常用</li>
<li>每一个html标签都有一个属性class</li>
<li>多类名选择器<ol>
<li>各个类名中间用空格隔开</li>
<li>简单理解：给某个标签添加了多个类，或者这个标签有多个名字</li>
<li>这个标签就可以分别具有这些类名的样式，从而节省CSS代码，统一修改非常方便</li>
<li>在后期布局比较复杂的情况下，使用较多</li>
</ol>
</li>
</ol>
<h3 id="基础选择器之id选择器"><a href="#基础选择器之id选择器" class="headerlink" title="基础选择器之id选择器"></a>基础选择器之id选择器</h3><ol>
<li>id选择器和类选择器的最大不同在于使用次数上，id选择器只可以被使用一次</li>
<li>id选择器一般用于页面唯一性的元素上，经常和JavaScript搭配使用</li>
</ol>
<h3 id="基础选择器之通配符选择器"><a href="#基础选择器之通配符选择器" class="headerlink" title="基础选择器之通配符选择器"></a>基础选择器之通配符选择器</h3><ol>
<li>配符选择器不需要调用，自动就给所有元素使用样式</li>
<li>特殊情况使用</li>
</ol>
<h3 id="基础选择器小结"><a href="#基础选择器小结" class="headerlink" title="基础选择器小结"></a>基础选择器小结</h3><ol>
<li><p>四种基础选择器总结</p>
<table>
<thead>
<tr>
<th>基础选择器</th>
<th>作用</th>
<th>特点</th>
<th>使用情况</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>标签选择器</td>
<td>可以选出所有相同的标签</td>
<td>不能差异化选择</td>
<td>较多</td>
<td>P {color: red}</td>
</tr>
<tr>
<td>类选择器</td>
<td>可以选出1个或者多个标签</td>
<td>可以根据需求选择</td>
<td>非常多</td>
<td>.red {color: red}</td>
</tr>
<tr>
<td>id选择器</td>
<td>一次只能选择1个标签</td>
<td>id属性只能在每个HTML文档中出现一次</td>
<td>一般和js搭配</td>
<td>#nav {color: red}</td>
</tr>
<tr>
<td>通配符选择器</td>
<td>选择所有标签</td>
<td>选择的太多，有部分不需要被选择</td>
<td>特殊情况使用 *{color: red}</td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p>css基本选择器的优先级</p>
<ol>
<li>style &gt; id选择器 &gt; class选择器 &gt; 标签选择器</li>
</ol>
</li>
</ol>
<h2 id="复合选择器"><a href="#复合选择器" class="headerlink" title="复合选择器"></a>复合选择器</h2><ol>
<li>复合选择器是建立在基础选择器之上的，对基础选择器进行组合形成的<ol>
<li>复合选择器可以更准确，更高效的选择目标元素</li>
<li>复合选择器是由两个或者多个基础选择器，通过不同的方式组合而成的</li>
<li>常用的复合选择器包括：后代选择器，子选择器，并集选择器，伪类选择器等</li>
</ol>
</li>
</ol>
<h3 id="后代选择器（重点）"><a href="#后代选择器（重点）" class="headerlink" title="后代选择器（重点）"></a>后代选择器（重点）</h3><ol>
<li>后代选择器又称包含选择器，可以选择父类元素里面的子元素</li>
<li>语法：<ul>
<li>元素1 元素2 {样式声明}</li>
</ul>
</li>
<li>注意<ol>
<li>元素1和元素2中间用空格隔开</li>
<li>元素1是父级，元素2是子级，最终选择的是元素2</li>
<li>元素2可以是儿子，也可以是孙子等，只要为元素1后代都可</li>
<li>元素1和元素2可以为任意基础选择器</li>
</ol>
</li>
</ol>
<h3 id="子选择器（重要）"><a href="#子选择器（重要）" class="headerlink" title="子选择器（重要）"></a>子选择器（重要）</h3><ol>
<li>只能选择作为某元素的最近一级子元素</li>
<li>语法：<ul>
<li>元素1 &gt; 元素2 {样式声明}</li>
</ul>
</li>
<li>上述语法表示元素1里面的所有直接后代（子元素）元素2</li>
<li>注意<ol>
<li>元素1和元素2中间用大于号隔开</li>
<li>元素1是父级，元素2是子级，最终选择的是元素2</li>
<li>元素2必须是亲儿子，其孙子等都不管</li>
</ol>
</li>
</ol>
<h3 id="并集选择器"><a href="#并集选择器" class="headerlink" title="并集选择器"></a>并集选择器</h3><ol>
<li>并集选择器可以选择多组标签，同时为他们定义相同的样式，通常用于集体声明</li>
<li>并集选择器是各选择器通过英文逗号（，）连接而成，任何形式的选择器都可以作为并集选择器的一部分</li>
<li>语法：<br>元素1，元素2 {样式声明}</li>
<li>注意<ol>
<li>元素1和元素2中间用逗号隔开</li>
<li>逗号可以理解为和的意思</li>
<li>并集选择器通常用于集体声明</li>
</ol>
</li>
</ol>
<h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><ol>
<li><p>链接伪类选择器</p>
<table>
<thead>
<tr>
<th>伪类选择器</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>a:link</td>
<td>选择所有未被访问的链接</td>
</tr>
<tr>
<td>a:visited</td>
<td>选择所有已被访问的链接</td>
</tr>
<tr>
<td>a:hover</td>
<td>选择鼠标指针位于其上的链接</td>
</tr>
<tr>
<td>a:active</td>
<td>选择活动链接（鼠标按下为弹起的链接）</td>
</tr>
</tbody></table>
<ol>
<li>注意：<ol>
<li>为确保链接伪类选择器生效，要按照LVHA的顺序声明 a:link - a:visited - a:hover - a:active</li>
<li>记忆法：love hate（爱恨）</li>
<li>因为a链接在浏览器中具有默认样式，所以在实际工作中都需要给链接单独指定样式</li>
</ol>
</li>
</ol>
</li>
<li><p>:focus伪类选择器</p>
<ol>
<li>:focus伪类选择器用于获取焦点（光标）的表单元素</li>
<li>一般情况下<code>&lt;input&gt;</code>类表单元素才能获取，因此这个选择器也主要针对于表单元素</li>
<li>语法：input:focus {}</li>
</ol>
</li>
</ol>
<h3 id="复合选择器小结"><a href="#复合选择器小结" class="headerlink" title="复合选择器小结"></a>复合选择器小结</h3><table>
<thead>
<tr>
<th>选择器</th>
<th>作用</th>
<th>特征</th>
<th>使用情况</th>
<th>隔开符号及用法</th>
</tr>
</thead>
<tbody><tr>
<td>后代选择器</td>
<td>用来选择后代元素</td>
<td>可以是子孙后代</td>
<td>较多</td>
<td>符号：空格</td>
</tr>
<tr>
<td>子选择器</td>
<td>选择最近一级元素</td>
<td>只选亲儿子</td>
<td>较少</td>
<td>符号：大于号&gt;</td>
</tr>
<tr>
<td>并集选择器</td>
<td>选择某些相同样式的元素</td>
<td>可以用于集体声明</td>
<td>较多</td>
<td>符号：逗号</td>
</tr>
<tr>
<td>链接伪类选择器</td>
<td>选择不同状态的链接</td>
<td>跟链接相关</td>
<td>较多</td>
<td>a:link a:visited a:hover a:active</td>
</tr>
<tr>
<td>:focus选择器</td>
<td>选择活动光标的表单</td>
<td>跟表单相关</td>
<td>较少</td>
<td>input:focus</td>
</tr>
</tbody></table>
<h1 id="CSS属性"><a href="#CSS属性" class="headerlink" title="CSS属性"></a>CSS属性</h1><h2 id="font文字属性"><a href="#font文字属性" class="headerlink" title="font文字属性"></a>font文字属性</h2><h3 id="字体大小"><a href="#字体大小" class="headerlink" title="字体大小"></a>字体大小</h3><ol>
<li>font-size属性设置文本字体的粗细</li>
<li>px（像素）时网页的最常用单位</li>
<li>谷歌浏览器默认的文字大小为16px，尽量不要使用浏览器默认的字体大小，最好自己给出</li>
<li>可以给boby指定整个页面文字大小</li>
<li>标题标签比较特殊，需要单独指定文字大小</li>
</ol>
<h3 id="字体粗细"><a href="#字体粗细" class="headerlink" title="字体粗细"></a>字体粗细</h3><ol>
<li><p>font-weight属性设置文本字体的粗细</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>normal</td>
<td>默认值（不加粗 400）</td>
</tr>
<tr>
<td>bold</td>
<td>定义粗体（加粗的 700）</td>
</tr>
<tr>
<td>100 - 900</td>
<td>400等同于normal，而700等同于bold，注意数字后不跟单位</td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="文字样式"><a href="#文字样式" class="headerlink" title="文字样式"></a>文字样式</h3><ol>
<li><p>font-style属性设置文本字体的粗细</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>normal</td>
<td>默认值，正常默认字体</td>
</tr>
<tr>
<td>italic</td>
<td>斜体</td>
</tr>
</tbody></table>
</li>
<li><p>一般很少使用斜体字，反而要给斜体字改为正常字体</p>
</li>
</ol>
<h3 id="复合属性写法"><a href="#复合属性写法" class="headerlink" title="复合属性写法"></a>复合属性写法</h3><ol>
<li><p>字体属性可以可以把文字样式综合来写，节约代码</p>
</li>
<li><p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  font: font-style font-weight font-size/line-height font-family（字体）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用font属性时，必须按照以上语法格式顺序书写，不能更换，各个属性之间用空格隔开</p>
</li>
<li><p>不需要设置的属性可以省略（取默认值），但是必须保留font-size和font-family属性，否则font属性将不起作用</p>
</li>
</ol>
<h3 id="文字属性小结"><a href="#文字属性小结" class="headerlink" title="文字属性小结"></a>文字属性小结</h3><table>
<thead>
<tr>
<th>属性</th>
<th>表示</th>
</tr>
</thead>
<tbody><tr>
<td>font-size</td>
<td>文字大小</td>
</tr>
<tr>
<td>font-weight</td>
<td>文字粗细</td>
</tr>
<tr>
<td>font-style</td>
<td>文字样式</td>
</tr>
</tbody></table>
<h2 id="CSS文本属性"><a href="#CSS文本属性" class="headerlink" title="CSS文本属性"></a>CSS文本属性</h2><h3 id="文本颜色"><a href="#文本颜色" class="headerlink" title="文本颜色"></a>文本颜色</h3><ol>
<li>color属性用于定义文本的颜色</li>
<li>十六进制颜色表示法最为常用</li>
</ol>
<h3 id="对齐文本"><a href="#对齐文本" class="headerlink" title="对齐文本"></a>对齐文本</h3><ol>
<li><p>align属性用于设置元素内文本内容的水平对齐方式</p>
<table>
<thead>
<tr>
<th>齐属性值</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>left</td>
<td>左对齐</td>
</tr>
<tr>
<td>right</td>
<td>右对齐</td>
</tr>
<tr>
<td>center</td>
<td>居中对齐</td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="装饰文本"><a href="#装饰文本" class="headerlink" title="装饰文本"></a>装饰文本</h3><ol>
<li><p>text-decoration属性规定添加到文本的修饰，可以添加下划线，删除线，上划线等。</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>none</td>
<td>默认，没有装饰性（最常用）</td>
</tr>
<tr>
<td>underline</td>
<td>下划线，超链接a自带下划线</td>
</tr>
<tr>
<td>overline</td>
<td>上划线（几乎不用）</td>
</tr>
<tr>
<td>line-through</td>
<td>删除线（不常用）</td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="文本缩进"><a href="#文本缩进" class="headerlink" title="文本缩进"></a>文本缩进</h3><ol>
<li>text-indent属性用来指定文本的第一行的缩进，通常是将段落的首行进行缩进</li>
<li>缩进单位用：em<ul>
<li>em是一个相对单位，就是当前元素（font-size）1个文字的大小</li>
</ul>
</li>
</ol>
<h3 id="行间距"><a href="#行间距" class="headerlink" title="行间距"></a>行间距</h3><ol>
<li>line-height属性用于设置行间距离，可以控制文字行与行之间的距离</li>
<li>行高由三部分组成：上边距，下边距，文本高度</li>
<li>上边距 &#x3D; 下边距</li>
</ol>
<h3 id="文本属性小结"><a href="#文本属性小结" class="headerlink" title="文本属性小结"></a>文本属性小结</h3><table>
<thead>
<tr>
<th>属性</th>
<th>表示</th>
</tr>
</thead>
<tbody><tr>
<td>color</td>
<td>文本颜色</td>
</tr>
<tr>
<td>text-align</td>
<td>文本对齐</td>
</tr>
<tr>
<td>text-indent</td>
<td>文本缩进</td>
</tr>
<tr>
<td>text-decoration</td>
<td>文本修饰</td>
</tr>
<tr>
<td>line-height</td>
<td>行高</td>
</tr>
</tbody></table>
<h1 id="CSS引入方式"><a href="#CSS引入方式" class="headerlink" title="CSS引入方式"></a>CSS引入方式</h1><h3 id="内部样式表（嵌入式引入）"><a href="#内部样式表（嵌入式引入）" class="headerlink" title="内部样式表（嵌入式引入）"></a>内部样式表（嵌入式引入）</h3><ol>
<li><pre><code>&lt;style&gt;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">标签放到</span><br><span class="line"></span><br></pre></td></tr></table></figure>
&lt;head&gt;
</code></pre>
<p>标签中，控制当前整个页面中的元素样式设置</p>
<ol>
<li>优点：代码结构清晰</li>
<li>缺点：没有实现结构与样式的完全分离</li>
</ol>
</li>
<li><p>一般在练习时使用</p>
</li>
</ol>
<h3 id="行内样式表（行内式引入）"><a href="#行内样式表（行内式引入）" class="headerlink" title="行内样式表（行内式引入）"></a>行内样式表（行内式引入）</h3><ol>
<li>在元素标签内部的style属性中设定CSS样式，适用于修改简单样式</li>
<li>书写繁琐，没有体现结构与样式分离的思想，只有对当前元素添加简单样式时，才考虑使用</li>
</ol>
<h3 id="外部样式表（外链式、链接式引入）"><a href="#外部样式表（外链式、链接式引入）" class="headerlink" title="外部样式表（外链式、链接式引入）"></a>外部样式表（外链式、链接式引入）</h3><ol>
<li><p>步骤</p>
<ol>
<li><p>新建一个后缀名为.CSS的样式文件，把所有的CSS代码都放入文件中</p>
</li>
<li><p>在HTML页面中，使用标签引入这个文件</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th>样式</th>
</tr>
</thead>
<tbody><tr>
<td align="left">rel</td>
<td>定义当前文档与被链接文档之间的关系，值需要指定为“stylesheet”,表示被链接的文档是一个样式表文件</td>
</tr>
<tr>
<td align="left">href</td>
<td>定义所链接外部样式表文件的URL，可以是相对路径，也可以是绝对路径</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
<li><p>开发中最常用</p>
</li>
</ol>
<h3 id="引入方式小结"><a href="#引入方式小结" class="headerlink" title="引入方式小结"></a>引入方式小结</h3><table>
<thead>
<tr>
<th>样式表</th>
<th>优点</th>
<th>缺点</th>
<th>使用情况</th>
<th>控制范围</th>
</tr>
</thead>
<tbody><tr>
<td>行内样式表</td>
<td>书写方便，权重高</td>
<td>结构样式混写</td>
<td>较少</td>
<td>控制一个标签</td>
</tr>
<tr>
<td>内部样式表</td>
<td>部分结构和样式相分离</td>
<td>没有彻底分离</td>
<td>较多</td>
<td>控制一个页面</td>
</tr>
<tr>
<td>外部样式表</td>
<td>完全实现结构和样式相分离</td>
<td>需要引入</td>
<td>最多</td>
<td>控制多个页面</td>
</tr>
</tbody></table>
<h2 id="Chrome调试工具"><a href="#Chrome调试工具" class="headerlink" title="Chrome调试工具"></a>Chrome调试工具</h2><ol>
<li>Ctrl+滚轮 可以放大开发者工具代码大小</li>
<li>左边是 HTML 元素结构，右边是 CSS 样式</li>
<li>右边 CSS 样式可以改动数值（左右箭头或者直接输入）和查看颜色</li>
<li>Ctrl + 0 复原浏览器大小</li>
<li>如果点击元素，发现右侧没有样式引入，极有可能是类名或者样式引入错误</li>
<li>如果有样式，但是样式前面有黄色叹号提示，则是样式属性书写错误</li>
</ol>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>DOM事件基础</title>
    <url>/2022/08/01/DOM%E4%BA%8B%E4%BB%B6%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="web-APIs和JS基础关联性"><a href="#web-APIs和JS基础关联性" class="headerlink" title="web APIs和JS基础关联性"></a>web APIs和JS基础关联性</h1><h2 id="JS基础阶段"><a href="#JS基础阶段" class="headerlink" title="JS基础阶段"></a>JS基础阶段</h2><ol>
<li>学习的是ECMAScript标准规定的基本语法</li>
<li>要求掌握JS基础语法</li>
<li>只学习基本语法，做不了常用的网页交互效果</li>
<li>目的是为了JS后面的课程打基础、做铺垫</li>
</ol>
<h2 id="Web-APIs阶段"><a href="#Web-APIs阶段" class="headerlink" title="Web APIs阶段"></a>Web APIs阶段</h2><ol>
<li>web APIs是w3C组织的标准</li>
<li>web APIs主要学习DOM和BOM</li>
<li>web APIs是JS所独有的部分</li>
<li>主要学习页面交互功能</li>
<li>需要使用JS基础的课程内容做基础</li>
</ol>
<h1 id="API和Web-API"><a href="#API和Web-API" class="headerlink" title="API和Web API"></a>API和Web API</h1><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><ol>
<li>API（应用程序编程接口）：一些预定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节</li>
<li>简单理解：API是给程序员提供的一种工具，以便能更轻松的实现想要完成的功能</li>
</ol>
<h2 id="Web-API"><a href="#Web-API" class="headerlink" title="Web API"></a>Web API</h2><ol>
<li>Web API是浏览器提供的一套操作浏览器功能和页面元素的API(BOM和DOM)</li>
<li>现阶段主要针对于浏览器讲解常用的API，主要针对浏览器做交互效果</li>
<li>比如想要浏览器弹出一个警示框，直接使用alert(‘弹出’)</li>
<li>MDN详细API: <a href="https://developer.mozilla.org/zh-CN/">https://developer.mozilla.org/zh-CN/</a></li>
<li>因为Web API很多,所以我们将这个阶段称为Web APIs</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>API是为程序员提供的一个接口，帮助我们实现某种功能，会使用就可以了，不必纠结内部如何实现</li>
<li>Web API主要是针对于浏览器提供的接口，主要针对于浏览器做交互效果</li>
<li>Web API一般都有输入和输出(函数的传参和返回值)，Web API很多都是方法(函数)</li>
<li>学习Web API可以结合前面学习内置对象方法的思路学习</li>
</ol>
<h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><ol>
<li>文档对象模型（DOM）：是W3C组织推荐的处理可扩展标记语言（HTML和XML）的标准编程接口</li>
<li>W3C已经定义了一系列的DOM接口，通过这些DOM接口可以改变网页的内容、结构和样式</li>
<li>对于HTML来说，dom使得html形成一棵dom树，包含文档、元素、节点</li>
</ol>
<h2 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h2><ol>
<li>DOM树<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20210927013853.png" alt="img">1. 文档：一个页面就是一个文档，DOM中使用document表示 2. 元素：页面中的所有标签都是元素，DOM中使用element表示 3. 节点：网页中的所有内容都是节点（标签，属性，文本，注释等），DOM中用node表示 4. DOM把以上内容都看做是对象</li>
</ol>
<h3 id="JS书写位置"><a href="#JS书写位置" class="headerlink" title="JS书写位置"></a>JS书写位置</h3><ol>
<li>标签要写在标签内的最后面，因为页面加载是从上往下的，只有先存在需要查找的标签，才可以进行获取</li>
</ol>
<h3 id="console-dir"><a href="#console-dir" class="headerlink" title="console.dir()"></a>console.dir()</h3><ol>
<li>console.dir()：打印返回的元素对象，更好的查看里面的属性和方法</li>
</ol>
<h3 id="获取Element对象"><a href="#获取Element对象" class="headerlink" title="获取Element对象"></a>获取Element对象</h3><ol>
<li><p>getElementById()：根据id属性值获取元素对象，id属性值一般唯一</p>
<ol>
<li>语法：<code>document.getElementById(&#39;time&#39;);</code><ul>
<li>参数是id，id是大小写敏感的字符串</li>
<li>返回值是一个DOM的Element对象，若当前Document没有找到，则返回null</li>
</ul>
</li>
</ol>
</li>
<li><p>getElementsByTagName(‘元素名称’)：根据元素名称获取元素对象集合，返回值为一个伪数组</p>
<ol>
<li><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.getElementsByTagName(&#x27;div&#x27;);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>返回值是获取过来元素对象的集合，以伪数组的形式存储</p>
</li>
<li><p>若页面中只有一个div，返回的仍然是伪数组形式</p>
</li>
<li><p>若页面中没有这个元素，返回的是空的伪数组的形式</p>
</li>
<li><p>想要依次打印里面的元素对象，可以采用遍历的方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div&gt;煤球1&lt;/div&gt;</span><br><span class="line">&lt;div&gt;煤球2&lt;/div&gt;</span><br><span class="line">&lt;div&gt;煤球3&lt;/div&gt;</span><br><span class="line">&lt;div&gt;煤球4&lt;/div&gt;</span><br><span class="line">&lt;div&gt;煤球5&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  var divs = document.getElementsByTagName(&#x27;div&#x27;);</span><br><span class="line">  console.log(divs);</span><br><span class="line">  for (var i = 0; i &lt; divs.length; i++) &#123;</span><br><span class="line">      console.log(divs[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
<li><p>获取父元素内部所有指定标签名的子元素</p>
<ol>
<li><p>注意：父元素必须是单个对象（必须指明是哪一个元素对象），获取时不包括父元素自己</p>
</li>
<li><p>常用语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Element.getElementsByTagName(&#x27;标签名&#x27;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;ol&gt;</span><br><span class="line">    &lt;li&gt;煤球1&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;煤球2&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;煤球3&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;煤球4&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;煤球5&lt;/li&gt;</span><br><span class="line">  &lt;/ol&gt;</span><br><span class="line">  &lt;ul id=&#x27;ul&#x27;&gt;</span><br><span class="line">    &lt;li&gt;煤球球1&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;煤球球2&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;煤球球3&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;煤球球4&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;煤球球5&lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    var ul = document.getElementById(&#x27;ul&#x27;);</span><br><span class="line">    var lis = console.log(ul.getElementsByTagName(&#x27;li&#x27;));</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="通过HTML5新增的方法获取Element元素-（不考虑兼容性的前提下推荐使用）"><a href="#通过HTML5新增的方法获取Element元素-（不考虑兼容性的前提下推荐使用）" class="headerlink" title="通过HTML5新增的方法获取Element元素 （不考虑兼容性的前提下推荐使用）"></a>通过HTML5新增的方法获取Element元素 （不考虑兼容性的前提下推荐使用）</h3><ol>
<li><p>getElemensByClassName(‘类名’)：根据class属性值获取元素对象集合，返回值为一个为伪数组</p>
<ol>
<li>语法：<code>document.getElementsByClassName(&#39;box&#39;);</code></li>
</ol>
</li>
<li><p>querySelector()：返回指定选择器的第一个元素对象，切记：里面的选择器需要加符号（.box-代表类；#nav-代表id）</p>
<ol>
<li><p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.querySelector(&#x27;.box&#x27;);</span><br><span class="line">document.querySelector(&#x27;#nav&#x27;)</span><br><span class="line">document.querySelector(&#x27;li&#x27;);</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>querySelectorAll()：返回指定选择器的所有元素对象集合，切记：里面的选择器需要加符号（.box-代表类；#nav-代表id）</p>
<ol>
<li><p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.querySelectorAll(&#x27;.box&#x27;);</span><br><span class="line">document.querySelectorAll(&#x27;#nav&#x27;);</span><br><span class="line">document.querySelectorAll(&#x27;li&#x27;);</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="获取body元素和html元素"><a href="#获取body元素和html元素" class="headerlink" title="获取body元素和html元素"></a>获取body元素和html元素</h3><ol>
<li><p>获取body元素</p>
<ol>
<li><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.body;</span><br></pre></td></tr></table></figure>

<ul>
<li>返回body元素对象</li>
</ul>
</li>
</ol>
</li>
<li><p>获取html元素</p>
<ol>
<li><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.documentElement;</span><br></pre></td></tr></table></figure>

<ul>
<li>返回html元素对象</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="事件基础"><a href="#事件基础" class="headerlink" title="事件基础"></a>事件基础</h2><ol>
<li>JavaScript使我们有能力创建动态页面,而事件是可以被JavaScript侦测到的行为</li>
<li>事件简单理解：触发–响应机制</li>
<li>网页中的每个元素都可以产生某些可以触发JavaScript的事件</li>
</ol>
<h3 id="事件三要素"><a href="#事件三要素" class="headerlink" title="事件三要素"></a>事件三要素</h3><ol>
<li>事件由三部分组成：事件源，事件类型，事件处理程序</li>
<li>事件源：事件被触发的对象</li>
<li>事件类型：如何触发，什么事件，比如鼠标点击（onclick），鼠标经过，滚轮滑动</li>
<li>事件处理程序：通过一个函数赋值的方式完成</li>
</ol>
<h3 id="执行事件的步骤"><a href="#执行事件的步骤" class="headerlink" title="执行事件的步骤"></a>执行事件的步骤</h3><ol>
<li>获取事件源</li>
<li>注册事件（绑定事件）</li>
<li>添加事件处理程序（采取函数赋值形式）<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20210927015412.png" alt="img"></li>
</ol>
<h3 id="常见鼠标事件"><a href="#常见鼠标事件" class="headerlink" title="常见鼠标事件"></a>常见鼠标事件</h3><table>
<thead>
<tr>
<th>鼠标事件</th>
<th>触发条件</th>
</tr>
</thead>
<tbody><tr>
<td>onclick</td>
<td>鼠标点击左键触发</td>
</tr>
<tr>
<td>onmouseover</td>
<td>鼠标经过触发</td>
</tr>
<tr>
<td>onmouseout</td>
<td>鼠标离开触发</td>
</tr>
<tr>
<td>onmouseenter</td>
<td>鼠标经过触发，不会冒泡</td>
</tr>
<tr>
<td>onmouseleave</td>
<td>鼠标离开触发，不会冒泡</td>
</tr>
<tr>
<td>onfocus</td>
<td>获得鼠标焦点触发</td>
</tr>
<tr>
<td>onblur</td>
<td>失去鼠标焦点触发</td>
</tr>
<tr>
<td>onmousemove</td>
<td>鼠标移动触发</td>
</tr>
<tr>
<td>onmouseup</td>
<td>鼠标弹起触发</td>
</tr>
<tr>
<td>onmousedown</td>
<td>鼠标按下触发</td>
</tr>
</tbody></table>
<ol>
<li>onmouseover和onmouseenter的区别<ol>
<li>mouseover鼠标经过自身盒子会触发，经过子盒子还会触发<ul>
<li>原因：由于冒泡原理，鼠标经过子盒子后向上冒泡再次触发父盒子</li>
</ul>
</li>
<li>mouseenter只会经过自身盒子触发<ul>
<li>原因：onmouseenter不会冒泡</li>
</ul>
</li>
</ol>
</li>
<li>onmouseover和onmouseout相对应</li>
<li>onmouseenter和onmouseleave相对应</li>
</ol>
<h2 id="操作元素"><a href="#操作元素" class="headerlink" title="操作元素"></a>操作元素</h2><ol>
<li>JavaScript的DOM操作可以改变网页内容、结构和样式，我们可以利用DOM操作元素来改变元素里面的内容、属性等</li>
</ol>
<h3 id="修改元素内容"><a href="#修改元素内容" class="headerlink" title="修改元素内容"></a>修改元素内容</h3><ol>
<li><p>element.innerText：从起始位置到终止位置的内容，但它不识别html标签，同时去掉空格和换行</p>
</li>
<li><p>element.innerHTML（常用）：从起始位置到终止位置的全部内容，识别html标签，同时保留空格和换行</p>
<ol>
<li><p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 获取事件源</span><br><span class="line">var img = document.querySelector(&#x27;div&#x27;);</span><br><span class="line">img.innerHTML = &#x27;要修改的内容&#x27;;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="修改元素属性"><a href="#修改元素属性" class="headerlink" title="修改元素属性"></a>修改元素属性</h3><ol>
<li><p>修改src，href，id，alt，title等属性的操作</p>
<ol>
<li><p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 获取事件源</span><br><span class="line">var img = document.querySelector(&#x27;img&#x27;);</span><br><span class="line">img.src = &#x27;要修改的内容&#x27;;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="修改表单属性"><a href="#修改表单属性" class="headerlink" title="修改表单属性"></a>修改表单属性</h3><ol>
<li><p>修改表单元素中src，href，id，alt，title等属性的操作</p>
<ol>
<li><p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  // 获取事件源</span><br><span class="line">  var btn = document.querySelector(&#x27;button&#x27;);</span><br><span class="line">  var input = document.querySelector(&#x27;input&#x27;);</span><br><span class="line">  // 注册事件，添加事件处理程序</span><br><span class="line">  btn.onclick = function () &#123;</span><br><span class="line">    input.value = &#x27;被点击了&#x27;;</span><br><span class="line">    // this指向的是事件函数的调用者</span><br><span class="line">    this.disabled = true;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="样式属性操作"><a href="#样式属性操作" class="headerlink" title="样式属性操作"></a>样式属性操作</h3><ol>
<li><p>可以通过JS修改元素的大小，颜色，位置等样式</p>
</li>
<li><p>行内样式操作 -</p>
<p>element.style</p>
<ol>
<li><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">element.style.样式属性 = &#x27;属性&#x27;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    // 获取事件源</span><br><span class="line">    var div = document.querySelector(&#x27;div&#x27;);</span><br><span class="line">    // 注册事件，添加事件处理程序</span><br><span class="line">    div.onclick = function () &#123;</span><br><span class="line">        this.style.backgroundColor = &#x27;pink&#x27;;</span><br><span class="line">        this.style.width = &#x27;300px&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>JS里面的样式采取驼峰命名法，如fontSize，backgroundColor</li>
<li>JS修改style样式操作，产生的是行内样式，CSS权重比较高</li>
<li>适合样式较少，功能简单的情况</li>
</ul>
</li>
</ol>
</li>
<li><p>类名样式操作 - element.className</p>
<ol>
<li>语法：<code>element.className = &#39;类名&#39;;</code><img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20210927020532.png" alt="img"></li>
<li>合于样式较多或者功能复杂的情况 - className会直接更改元素的类名，会覆盖原先的类名，因此进行类名赋值时需要把类名写全<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20210927020621.png" alt="img"></li>
</ol>
</li>
</ol>
<h3 id="排他思想"><a href="#排他思想" class="headerlink" title="排他思想"></a>排他思想</h3><ol>
<li>如果有同一组元素，我们想要某一个元素实现某种样式 ，需要用到循环的排他思想算法</li>
<li>步骤<ol>
<li>所有元素全部清除样式（干掉其他元素）</li>
<li>给当前元素设置样式（留下自己）</li>
</ol>
</li>
<li>注意：顺序不能颠倒</li>
<li>排他思想应用，例：tab栏切换案例<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20210927020800.png" alt="img"></li>
</ol>
<h3 id="自定义属性操作"><a href="#自定义属性操作" class="headerlink" title="自定义属性操作"></a>自定义属性操作</h3><ol>
<li><p>获取属性值的方法</p>
<ol>
<li>方法一：element.属性;</li>
<li>方法二：getAttribute(‘属性’);<ul>
<li>attribute — 属性</li>
</ul>
</li>
</ol>
</li>
<li><p>区别</p>
<ol>
<li><strong>element.属性; — 获取内置属性值（元素自带的属性）</strong></li>
<li><strong>getAttribute(‘属性’); —主要获得自定义的属性</strong></li>
</ol>
</li>
<li><p>设置属性值</p>
<ol>
<li>element.属性 &#x3D; ‘值’; — 设置内置属性</li>
<li>element.setAttribute(‘属性’, ‘值’); — 主要针对于自定义属性<ul>
<li>在实际开发中经常使用，利用自定义属性给元素设置索引值，案例见上tab栏切换</li>
</ul>
</li>
</ol>
</li>
<li><p>移除属性</p>
<ol>
<li>removeAttribute(‘属性’);</li>
</ol>
</li>
<li><p>自定义属性的目的：是为了保存并使用数据；有些数据可以保存到页面中而不用保存到数据库中</p>
</li>
<li><p>为了避免自定义属性和内置属性混淆，因此H5中规定</p>
<p>自定义属性data-开头做为属性名并且赋值</p>
<ol>
<li>如<ul>
<li><code>&lt;div data-index = &#39;1&#39;&gt;&lt;/div&gt;</code></li>
<li><code>div.setAttribute(&#39;data-time&#39;, 20);</code></li>
<li><code>div.getAttribute(&#39;data-time&#39;);</code></li>
</ul>
</li>
</ol>
</li>
<li><p>H5新增的获取自定义属性的方法，它只能获取data-开头的自定义属性（ie11以上版本支持，兼容性较差）</p>
<ol>
<li>dataset是一个集合里面存放了所有以data开头的首定义属性</li>
<li>语法<ul>
<li>获取自定义属性data-index：div.dataset.index</li>
<li>获取自定义属性data-list-name：div.dataset.listName</li>
</ul>
</li>
<li>若定义属性里面有多个 - 链接的单词，获取的时候采取驼峰命名法</li>
</ol>
</li>
</ol>
<h2 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h2><ol>
<li>为什么学习节点操作<ol>
<li>利用dom提供的方法获取元素<ul>
<li>document.getElementById()</li>
<li>document.getElementsByTagName()</li>
<li>document.querySelector等</li>
<li>逻辑性不强、繁琐</li>
</ul>
</li>
<li>利用节点层级关系获取元素<ul>
<li>利用父子兄节点关系获取元素</li>
<li>逻辑性强，但是兼容性稍差</li>
</ul>
</li>
</ol>
</li>
<li>节点层次：利用DOM树可以把节点划分为不同的层级关系，常见的父子兄层级关系</li>
</ol>
<h3 id="节点概述"><a href="#节点概述" class="headerlink" title="节点概述"></a>节点概述</h3><ol>
<li>网页中的所有内容都是节点(标签、属性、文本、注释等)，在DOM中，节点使用node来表示</li>
<li>HTML DOM树中的所有节点均可通过JavaScript进行访问，所有HTML元素(节点)均可被修改，也可以创建或删除</li>
<li>一般地，节点至少拥有nodeType(节点类型)、nodeName(节点名称)和nodeValue (节点值)这三个基本属性</li>
<li>节点一般有三种类型，实际开发中节点操作主要操作的是元素节点<ol>
<li>元素节点：nodeType为1</li>
<li>属性节点：nodeType为2</li>
<li>文本节点：nodeType为3（文本节点包含文字、空格、换行等）</li>
</ol>
</li>
</ol>
<h3 id="节点操作之父节点"><a href="#节点操作之父节点" class="headerlink" title="节点操作之父节点"></a>节点操作之父节点</h3><ol>
<li>父节点 parentNode<ol>
<li>得到的是离元素最近的父级节点（亲爸爸）</li>
<li>若找不到父节点就返回null</li>
</ol>
</li>
</ol>
<h3 id="节点操作之子节点"><a href="#节点操作之子节点" class="headerlink" title="节点操作之子节点"></a>节点操作之子节点</h3><ol>
<li><p>子节点 childNodes（标准）</p>
<ol>
<li>childNodes返回包含指定节点的子节点的集合，该集合为即时更新的集合</li>
<li>会获取所有的子节点，包含元素节点，文本节点等<ul>
<li>若只想要获得里面的元素节点，则需要专门处理，因此不推荐使用childNodes</li>
</ul>
</li>
</ol>
</li>
<li><p>子节点 chlidren</p>
<p>（非标准）</p>
<ol>
<li><p>获取所有的子元素节点，不包含文本节点等，实际开发经常使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;1&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;2&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;3&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;4&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  var ul = document.querySelector(&#x27;ul&#x27;);</span><br><span class="line">  // 子节点 childNodes 获取所有的子节点，包含元素节点，文本节点等</span><br><span class="line">  console.log(ul.childNodes); // NodeList(9)</span><br><span class="line">  // 子节点 children 获取所有的子元素节点，不包含文本节点等，实际开发经常使用</span><br><span class="line">  console.log(ul.children); // HTMLCollection(4)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>获取第一个和最后一个子节点</p>
<ol>
<li><p>方法一 — firstChild &#x2F; lastChild：第一个子节点，不管是文本节点还是元素节点</p>
<ul>
<li>有兼容性问题，IE9以上版本支持</li>
</ul>
</li>
<li><p>方法二 — firstElementChild &#x2F; lastElementChild：返回第一个子元素节点</p>
<ul>
<li>有兼容性问题，IE9以上版本支持</li>
</ul>
</li>
<li><p>方法三（常用）</p>
<p>— 实际开发写法，既没有兼容性问题，又返回任意子元素</p>
<ul>
<li><p>先获取父元素，然后利用children获取所有子元素节点，此时父元素为一个伪数组，遍历用索引号获取子元素节点，代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;节点li1&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;节点li2&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;节点li3&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;节点li4&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  var ul = document.querySelector(&#x27;ul&#x27;);</span><br><span class="line">  // 获取第一个和最后一个子节点</span><br><span class="line">  // 方法一 firstChild/lastChild：第一个子节点，不管是文本节点还是元素节点</span><br><span class="line">  console.log(ul.firstChild); // #text</span><br><span class="line">  console.log(ul.lastChild); // #text</span><br><span class="line"></span><br><span class="line">  // 方法二 firstElementChild/lastElementChild：返回第一个子元素节点</span><br><span class="line">  console.log(ul.firstElementChild); // &lt;li&gt;节点li1&lt;li&gt;</span><br><span class="line">  console.log(ul.lastElementChild); // &lt;li&gt;节点li4&lt;li&gt;</span><br><span class="line"></span><br><span class="line">  // 方法三 实际开发写法，既没有兼容性问题，又返回任意子元素</span><br><span class="line">  console.log(ul.children[0]); // &lt;li&gt;节点li1&lt;li&gt;</span><br><span class="line">  console.log(ul.children[ul.children.length - 1]); // &lt;li&gt;节点li4&lt;li&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="节点操作之兄弟节点"><a href="#节点操作之兄弟节点" class="headerlink" title="节点操作之兄弟节点"></a>节点操作之兄弟节点</h3><ol>
<li>获取兄弟节点<ol>
<li>方法一 — nextSibing &#x2F; previousSibing：返回当前元素的下一个&#x2F;上一个兄弟节点，找不到则返回null<ul>
<li>包含所有节点，如文本节点</li>
<li>有兼容性问题，IE9以上版本支持</li>
</ul>
</li>
<li>方法二 — nextElementSibling &#x2F; previousElementSlibing：返回当前元素下一个&#x2F;上一个兄弟节点，找不到则返回null<ul>
<li>只包含元素节点</li>
<li>有兼容性问题，IE9以上版本支持</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="创建元素节点"><a href="#创建元素节点" class="headerlink" title="创建元素节点"></a>创建元素节点</h3><ol>
<li><p>给页面添加一个新的元素分两步</p>
<ol>
<li>创建元素</li>
<li>添加元素</li>
</ol>
</li>
<li><p>创建节点元素节点</p>
<ol>
<li><p>方法一：</p>
<p>createElement()</p>
<ul>
<li>语法：<code>document.createElement(&#39;tagName&#39;);</code></li>
</ul>
</li>
</ol>
</li>
<li><p>添加节点(方法一) — 不支持追加字符串格式的元素</p>
<ol>
<li>node.appendChild(child)：将一个节点添加到指定父节点的子节点列表末尾<ul>
<li>node为父级，child为子级</li>
</ul>
</li>
<li>node.insertBefore(child, 指定元素)：将一个节点添加到指定父节点的指定子节点前面<ul>
<li>node为父级，child为子级<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20210927021815.png" alt="img"></li>
</ul>
</li>
</ol>
</li>
<li><p>添加节点(方法二)：insertAdjacentHTML() — 支持追加字符串格式的元素</p>
<ol>
<li><p>语法</p>
<ul>
<li>document.insertAdjacentHTML(‘beforeend’, html); — insert(插入) adjacent(相邻的)</li>
</ul>
</li>
<li><p>参数</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>beforebegin</td>
<td>元素自身的前面</td>
</tr>
<tr>
<td>afterbegin</td>
<td>插入元素内部的第一子节点之前</td>
</tr>
<tr>
<td>beforeend</td>
<td>插入元素内部的最后一个子节点之后</td>
</tr>
<tr>
<td>afterend</td>
<td>元素自身的后面</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ol>
<h3 id="删除元素节点"><a href="#删除元素节点" class="headerlink" title="删除元素节点"></a>删除元素节点</h3><ol>
<li>删除节点：node.removeChild(child)<ol>
<li>node为父级，child为子级</li>
<li>node.removeChild(child)方法从一个DOM中删除一个子节点，返回删除的节点<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20210927022050.png" alt="img"></li>
</ol>
</li>
<li>阻止链接跳转：给a标签行内样式href的属性值改为javascript:;</li>
</ol>
<h3 id="复制节点（克隆节点）"><a href="#复制节点（克隆节点）" class="headerlink" title="复制节点（克隆节点）"></a>复制节点（克隆节点）</h3><ol>
<li><p>复制节点：node.cloneNode(空、false &#x2F; true)</p>
<ol>
<li><p>方法返回调用该方法的节点的一个副本</p>
</li>
<li><p>注意</p>
<ul>
<li><p><strong>括号参数为空或者为false，则是浅拷贝，即只克隆复制节点本身，不克隆里面的子节点</strong></p>
</li>
<li><p>括号参数为true，则是深拷贝，复制标签以及复制里面的内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;1111&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;2&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;3&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  // 获取元素</span><br><span class="line">  var ul = document.querySelector(&#x27;ul&#x27;);</span><br><span class="line"></span><br><span class="line">  // 复制第一个li</span><br><span class="line">  // 括号参数为空或者为false，则是浅拷贝，即只克隆复制节点本身，不克隆里面的子节点</span><br><span class="line">  // var li1 = ul.children[0].cloneNode();</span><br><span class="line"></span><br><span class="line">  // 括号参数为true，则是深拷贝，复制标签以及复制里面的内容</span><br><span class="line">  var li1 = ul.children[0].cloneNode(true);</span><br><span class="line"></span><br><span class="line">  // 添加节点</span><br><span class="line">  ul.appendChild(li1);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="动态创建元素innerHTML和creatElement效率对比（经典面试题）"><a href="#动态创建元素innerHTML和creatElement效率对比（经典面试题）" class="headerlink" title="动态创建元素innerHTML和creatElement效率对比（经典面试题）"></a>动态创建元素innerHTML和creatElement效率对比（经典面试题）</h2><h3 id="三种动态创建元素"><a href="#三种动态创建元素" class="headerlink" title="三种动态创建元素"></a>三种动态创建元素</h3><ol>
<li>document.write()</li>
<li>element.innerHTML</li>
<li>document.createElement()</li>
</ol>
<h3 id="creatElement效率测试"><a href="#creatElement效率测试" class="headerlink" title="creatElement效率测试"></a>creatElement效率测试</h3><ol>
<li>执行时间大概在6毫秒左右<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20210927022413.png" alt="img"></li>
</ol>
<h3 id="innerHTML拼接字符串方法效率测试"><a href="#innerHTML拼接字符串方法效率测试" class="headerlink" title="innerHTML拼接字符串方法效率测试"></a>innerHTML拼接字符串方法效率测试</h3><ol>
<li>执行时间大概在900毫秒左右<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20210927022447.png" alt="img"></li>
</ol>
<h3 id="innerHTML数组方法效率测试（效率最高）"><a href="#innerHTML数组方法效率测试（效率最高）" class="headerlink" title="innerHTML数组方法效率测试（效率最高）"></a>innerHTML数组方法效率测试（效率最高）</h3><ol>
<li>执行时间大概在2毫秒左右<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20210927022519.png" alt="img"></li>
</ol>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol>
<li>document.write是直接将内容写入页面的内容流，但是文档流执行完毕，则它会导致页面全部重绘</li>
<li>innerHTML是将内容写入某个DOM节点，不会导致页面全部重绘</li>
<li>innerHTMI创建多个元素效率更高（不要拼接字符串，采取数组形式拼接），结构稍微复杂</li>
<li>createElement()创建多个元素效率稍低一点，但是结构更清晰</li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>ES5函数进阶</title>
    <url>/2022/08/01/ES5%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h1 id="ES5函数进阶"><a href="#ES5函数进阶" class="headerlink" title="ES5函数进阶"></a>ES5函数进阶</h1><h2 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h2><ol>
<li>三种定义函数的方法<ol>
<li>函数声明方式（命名函数）：function 函数名()</li>
<li>函数表达式（匿名函数）</li>
<li>new function()<ul>
<li>var fn &#x3D; new Function(‘参数1’, (‘参数2’, .., ‘函数体’)<ul>
<li>Function里面参数都必须是字符串格式</li>
<li>第三种方式执行效率低，也不方便书写，较少使用</li>
<li>所有函数都是Function的实例对象</li>
<li>函数也属于对象<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211007010844.png" alt="img"></li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><h3 id="什么是严格模式"><a href="#什么是严格模式" class="headerlink" title="什么是严格模式"></a>什么是严格模式</h3><ol>
<li>JavaScript除了提供正常模式外，还提供了严格模式（strict mode) ES5的严格模式是采用具有限制性JavaScript变体的一种方式，即在严格的条件下运行JS代码</li>
<li>严格模式在IE10以上版本的浏览器中才会被支持，旧版本浏览器中会被忽略</li>
<li>严格模式对正常的JavaScript语义做了一些更改<ol>
<li>消除了Javascript语法的一些不合理、不严谨之处，减少了一些怪异行为</li>
<li>消除代码运行的一些不安全之处，保证代码运行的安全。</li>
<li>提高编译器效率，增加运行速度</li>
<li>禁用了在ECMAScript的未来版本中可能会定义的一些语法，为未来新版本的Javascript做好铺垫。比如一些保留字符：class, enum, export, extends, import, super不能做变量名</li>
</ol>
</li>
</ol>
<h3 id="开启严格模式"><a href="#开启严格模式" class="headerlink" title="开启严格模式"></a>开启严格模式</h3><ol>
<li>严格模式可以应用到整个脚本或个别函数中，因此再使用时，可以将严格模式分为：<ol>
<li>为脚本开启严格模式</li>
<li>为函数开启严格模式</li>
</ol>
</li>
</ol>
<h3 id="为脚本开启严格模式"><a href="#为脚本开启严格模式" class="headerlink" title="为脚本开启严格模式"></a>为脚本开启严格模式</h3><ol>
<li><p>有的Script是严格模式，有的Script脚本是正常模式，这样不利于文件合并，所以将整个脚本文件放在一个立即执行的匿名函数之中，这样独立创建一个作用域而不影响其他Script脚本文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(function () &#123;</span><br><span class="line">    &#x27;use strict&#x27;;</span><br><span class="line">    var num = 10;</span><br><span class="line">    function fn() &#123;&#125;</span><br><span class="line">&#125;) ();</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="为函数开启严格模式"><a href="#为函数开启严格模式" class="headerlink" title="为函数开启严格模式"></a>为函数开启严格模式</h3><ol>
<li><p>要给某个函数开启严格模式，需要把’use strict’;声明放在函数体所有语句之前</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function fn() &#123;</span><br><span class="line">    &#x27;use strict&#x27;;</span><br><span class="line">    // 该函数内部以下的代码按照严格模式执行代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="严格模式中的变化"><a href="#严格模式中的变化" class="headerlink" title="严格模式中的变化"></a>严格模式中的变化</h3><ol>
<li>变量规定<ol>
<li>在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，变量都必须先用var命令声明，然后再使用</li>
<li>严禁删除已经声明的变量；例如delete；语法是错误的</li>
</ol>
</li>
<li>this指向问题<ol>
<li>以前在全局作用域函数的this指向Window对象</li>
<li>严格模式下全局作用域中的this指向undefined</li>
<li>以前构造函数时不加new也可以调用，当普通函数，this指向全局对象</li>
<li>严格模式下，如果构造函数不加new调用，this会报错</li>
<li>new实例化的构造函数仍然指向创建的对象实例</li>
<li>定时器this仍然是指向window</li>
<li>事件、对象仍然是指向调用者</li>
</ol>
</li>
<li>函数变化<ol>
<li>函数不能有重名的参数</li>
<li>函数必须声明在顶层，新版本的JavaScript会引入“块级作用域”（ES6已引入）。为了与新版本接轨，不允许在非函数的代码块内声明函数</li>
</ol>
</li>
</ol>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><ol>
<li>高阶函数是对其他函数进行操作的函数，满足以下两个条件中任意一个即为高阶函数<ol>
<li>接收函数作为参数</li>
<li>将函数作为返回值输出</li>
</ol>
</li>
<li>函数也是一种数据类型，同样可以作为参数，传递给另外一个参数使用；最典型的就是作为回调函数</li>
<li>闭包是一个典型的高阶函数用法，因为闭包将函数作为返回值</li>
</ol>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><ol>
<li>递归函数：函数内部自己调用自己，这个函数就是递归函数</li>
<li>递归里面必须加退出条件，否则会造成死递归，使栈溢出</li>
</ol>
]]></content>
      <categories>
        <category>ES5</category>
      </categories>
      <tags>
        <tag>ES5</tag>
      </tags>
  </entry>
  <entry>
    <title>DOM事件高级</title>
    <url>/2022/08/01/DOM%E4%BA%8B%E4%BB%B6%E9%AB%98%E7%BA%A7/</url>
    <content><![CDATA[<h1 id="注册事件"><a href="#注册事件" class="headerlink" title="注册事件"></a>注册事件</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol>
<li>给元素添加事件，称为注册事件或者绑定事件</li>
<li>注册事件有两种方式：传统方式和方法监听注册方式</li>
</ol>
<h3 id="传统注册事件"><a href="#传统注册事件" class="headerlink" title="传统注册事件"></a>传统注册事件</h3><ol>
<li>同一个元素同一个事件只能设置一个处理函数 ，最后注册的处理函数将会覆盖前面注册的处理函数</li>
</ol>
<h3 id="方法监听注册事件"><a href="#方法监听注册事件" class="headerlink" title="方法监听注册事件"></a>方法监听注册事件</h3><ol>
<li>W3C标准推荐方式</li>
<li>addEventListener() — 它是一个方法</li>
<li>IE9以前的版本不支持，可使用attachEvent()代替</li>
<li>特点：同一个元素同一个事件可以注册多个监听器</li>
<li>按照注册顺序依次执行</li>
</ol>
<h2 id="addEventListener事件监听方式"><a href="#addEventListener事件监听方式" class="headerlink" title="addEventListener事件监听方式"></a>addEventListener事件监听方式</h2><h3 id="事件侦听注册事件addEventListener"><a href="#事件侦听注册事件addEventListener" class="headerlink" title="事件侦听注册事件addEventListener"></a>事件侦听注册事件addEventListener</h3><ol>
<li>里面的事件类型是字符串必定加引号而且不带on</li>
<li>同一个元素同一个事件可以添加多个侦听器（事件处理程序）<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20210929104153.png" alt="img"></li>
</ol>
<h2 id="删除事件"><a href="#删除事件" class="headerlink" title="删除事件"></a>删除事件</h2><h3 id="传统方式删除事件"><a href="#传统方式删除事件" class="headerlink" title="传统方式删除事件"></a>传统方式删除事件</h3><ol>
<li>btn.onclick &#x3D; null;</li>
</ol>
<h3 id="removeEventListener删除事件"><a href="#removeEventListener删除事件" class="headerlink" title="removeEventListener删除事件"></a>removeEventListener删除事件</h3><ol>
<li>btn.removeEventListener(‘click’, fn);</li>
</ol>
<h1 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h1><ol>
<li>事件流描述的是从页面中接收事件的顺序</li>
<li>事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即DOM事件流</li>
</ol>
<h2 id="DOM事件流的三个阶段"><a href="#DOM事件流的三个阶段" class="headerlink" title="DOM事件流的三个阶段"></a>DOM事件流的三个阶段</h2><ol>
<li>DOM事件流分为三个阶段<ol>
<li>阶段一：事件捕获阶段</li>
<li>阶段二：当前目标阶段</li>
<li>阶段三：事件冒泡阶段</li>
</ol>
</li>
<li>事件捕获：由DOM最顶层节点开始，然后逐级向下传播到到最具体的元素接收的过程</li>
<li>事件冒泡：事件开始时由最具体的元素接收，然后逐级向上传播到到DOM最顶层节点的过程</li>
<li>比如给div注册了一个点击事件<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20210929104504.png" alt="img"></li>
<li>我们向水里面扔一块石头，首先它会有一个下降的过程，这个过程就可以理解为从最顶层向事件发生的最具体元素(目标点)的捕获过程；之后会产生泡泡，会在最低点(最具体元素)之后漂浮到水面上，这个过程相当于事件冒泡</li>
</ol>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol>
<li>JS代码只能执行捕获或者冒泡其中的一个阶段</li>
<li>onclick和attachEvent只能得到冒泡阶段</li>
<li>addEventListener第三个参数是true，则处于捕获阶段：document –&gt;html –&gt; body –&gt; father –&gt; son<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20210929104709.png" alt="img"></li>
<li>addEventListener第三个参数是false或者省略，则处于冒泡阶段：son -&gt; father -&gt; body -&gt; html -&gt; document<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20210929104750.png" alt="img"></li>
</ol>
<h1 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h1><h2 id="事件对象概述"><a href="#事件对象概述" class="headerlink" title="事件对象概述"></a>事件对象概述</h2><ol>
<li>官方解释：event对象代表事件的状态，比如键盘按键的状态、鼠标的位置、鼠标按钮的状态</li>
<li>简单理解：事件发生后，跟事件相关的一系列信息数据的集合都放到这个对象里面，这个对象就是事件对象event，它有很多属性和方法</li>
<li>注册事件时，event对象就会被系统自动创建，并依次传递给事件监听器(事件处理函数)</li>
<li>事件对象我们可以自己命名比如event、evt、e</li>
<li>event 是个形参，系统帮我们设定为事件对象，不需要传递实参过去</li>
<li>当注册事件时，event对象就会被系统自动创建，并依次传递给事件监听器(事件处理函数)</li>
</ol>
<h2 id="事件对象常见的属性和方法"><a href="#事件对象常见的属性和方法" class="headerlink" title="事件对象常见的属性和方法"></a>事件对象常见的属性和方法</h2><table>
<thead>
<tr>
<th>事件对象属性方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>e.target</td>
<td>返回触发事件的对象 — 标准</td>
</tr>
<tr>
<td>e.srcElement</td>
<td>返回触发事件的对象 — 非标准，ie678使用</td>
</tr>
<tr>
<td>e.type</td>
<td>返回事件的类型，比如click mouseover，不带on</td>
</tr>
<tr>
<td>e.cancelBubble</td>
<td>该属性阻止冒泡 — 非标准，ie678使用</td>
</tr>
<tr>
<td>e.returnValue</td>
<td>该属性阻止默认事件（默认行为）— 非标准，ie678使用，比如不让链接跳转</td>
</tr>
<tr>
<td>e.preventDefault()</td>
<td>该方法阻止默认事件（默认行为）— 标准，比如不让链接跳转</td>
</tr>
<tr>
<td>e.stopPropagation()</td>
<td>阻止冒泡 — 标准</td>
</tr>
</tbody></table>
<h3 id="e-target和this的区别"><a href="#e-target和this的区别" class="headerlink" title="e.target和this的区别"></a>e.target和this的区别</h3><ol>
<li>e.target：返回的是触发事件的对象<ul>
<li>简单理解：点击了哪个元素，就返回哪个元素</li>
</ul>
</li>
<li>this：返回的是绑定事件的对象（元素）<ul>
<li>简单理解：哪个元素绑定了这个点击事件，那么就返回谁</li>
</ul>
</li>
</ol>
<h3 id="阻止默认行为"><a href="#阻止默认行为" class="headerlink" title="阻止默认行为"></a>阻止默认行为</h3><ol>
<li>dom标准写法：e.preventDefault();</li>
<li>传统注册方式，有三种方法<ol>
<li>普通浏览器：e.preventDefault()；</li>
<li>低版本浏览器：e.returnValue;</li>
<li>return false; — 可以阻止默认行为，没有兼容性问题<ul>
<li>特点：return后面的代码不执行，只限于传统的注册方式</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="阻止冒泡（面试考点）"><a href="#阻止冒泡（面试考点）" class="headerlink" title="阻止冒泡（面试考点）"></a>阻止冒泡（面试考点）</h3><ol>
<li><p>dom标准写法：e.stopPropagation() — propagation(传播)</p>
</li>
<li><p>非标准写法：e.cancelBubble &#x3D; true; — cancel(取消)，bubble(泡泡)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;father&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;son&quot;&gt;son儿子&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    // 常见事件对象的属性和方法</span><br><span class="line">    // 阻止冒泡  dom 推荐的标准 stopPropagation() </span><br><span class="line">    var son = document.querySelector(&#x27;.son&#x27;);</span><br><span class="line">    // 点击son盒子，只弹出son弹框</span><br><span class="line">    son.addEventListener(&#x27;click&#x27;, function (e) &#123;</span><br><span class="line">        alert(&#x27;son&#x27;);</span><br><span class="line">        e.stopPropagation(); // stop 停止  Propagation 传播</span><br><span class="line">        e.cancelBubble = true; // 非标准 cancel 取消 bubble 泡泡</span><br><span class="line">    &#125;, false);</span><br><span class="line"></span><br><span class="line">    // 点击father盒子，弹出father弹框和document弹框</span><br><span class="line">    var father = document.querySelector(&#x27;.father&#x27;);</span><br><span class="line">    father.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">        alert(&#x27;father&#x27;);</span><br><span class="line">    &#125;, false);</span><br><span class="line"></span><br><span class="line">    document.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">        alert(&#x27;document&#x27;);</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ol>
<li>事件委托也称为事件代理，在jQuery中称为事件委派</li>
</ol>
<h3 id="事件委托的原理（能够口述）"><a href="#事件委托的原理（能够口述）" class="headerlink" title="事件委托的原理（能够口述）"></a>事件委托的原理（能够口述）</h3><ol>
<li>不是每个子节点单独设置事件监听器，而是将事件监听器设置在其父节点上，然后利用冒泡原理影响设置每个子节点</li>
</ol>
<h3 id="事件委托的作用"><a href="#事件委托的作用" class="headerlink" title="事件委托的作用"></a>事件委托的作用</h3><ol>
<li><p>只操作了DOM一次，提高了程序的性能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">      &lt;li&gt;事件委托&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;事件委托&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;事件委托&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;事件委托&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;事件委托&lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">  &lt;script&gt;</span><br><span class="line">      // 事件委托的原理：事件监听器设置在其父节点上，然后利用冒泡原理影响设置每个子节点</span><br><span class="line">      var ul = document.querySelector(&#x27;ul&#x27;);</span><br><span class="line">      ul.addEventListener(&#x27;click&#x27;, function (e) &#123;</span><br><span class="line">          // 返回的是触发事件的对象</span><br><span class="line">          e.target.style.backgroundColor = &#x27;pink&#x27;;</span><br><span class="line">      &#125;)</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="常用的鼠标和键盘事件"><a href="#常用的鼠标和键盘事件" class="headerlink" title="常用的鼠标和键盘事件"></a>常用的鼠标和键盘事件</h1><h2 id="常用的鼠标事件"><a href="#常用的鼠标事件" class="headerlink" title="常用的鼠标事件"></a>常用的鼠标事件</h2><table>
<thead>
<tr>
<th>鼠标事件</th>
<th>触发条件</th>
</tr>
</thead>
<tbody><tr>
<td>onclick</td>
<td>鼠标点击左键触发</td>
</tr>
<tr>
<td>onmouseover</td>
<td>鼠标经过触发</td>
</tr>
<tr>
<td>onmouseout</td>
<td>鼠标离开触发</td>
</tr>
<tr>
<td>onfocus</td>
<td>获得鼠标焦点触发</td>
</tr>
<tr>
<td>onblur</td>
<td>失去鼠标焦点触发</td>
</tr>
<tr>
<td>onmousemove</td>
<td>鼠标移动触发</td>
</tr>
<tr>
<td>onmouseup</td>
<td>鼠标弹起触发</td>
</tr>
<tr>
<td>onmousedown</td>
<td>鼠标按下触发</td>
</tr>
<tr>
<td>Ondblclick</td>
<td>鼠标双击事件</td>
</tr>
</tbody></table>
<ol>
<li><p>手动调用鼠标事件，不需要鼠标操作，程序自动执行相应的鼠标操作</p>
<ol>
<li><p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">click() --- 手动调用点击事件</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="常用鼠标事件补充"><a href="#常用鼠标事件补充" class="headerlink" title="常用鼠标事件补充"></a>常用鼠标事件补充</h3><ol>
<li><p>禁止鼠标右键菜单：contextmenu</p>
<ol>
<li>主要控制应该何时显示上下文菜单，主要用于程序员取消默认的上下文菜单</li>
</ol>
</li>
<li><p>禁止鼠标选中：selectstart</p>
<ol>
<li><p>主要控制文字是否能够被赋值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">我是一段不愿意被分享的文字</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    // 禁止鼠标右键菜单</span><br><span class="line">    document.addEventListener(&#x27;contextmenu&#x27;, function (e) &#123;</span><br><span class="line">        // 该方法阻止默认事件</span><br><span class="line">        e.preventDefault();</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    // 禁止鼠标选中</span><br><span class="line">    document.addEventListener(&#x27;selectstart&#x27;, function (e) &#123;</span><br><span class="line">        // 该方法阻止默认事件</span><br><span class="line">        e.preventDefault();</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="鼠标事件对象"><a href="#鼠标事件对象" class="headerlink" title="鼠标事件对象"></a>鼠标事件对象</h3><ol>
<li><p>鼠标事件对象：MouseEvent</p>
<table>
<thead>
<tr>
<th>鼠标事件对象</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>e.clientX</td>
<td>返回鼠标相对于浏览器窗口可视区的X坐标</td>
</tr>
<tr>
<td>e.clientY</td>
<td>返回鼠标相对于浏览器窗口可视区的Y坐标</td>
</tr>
<tr>
<td>e.pageX</td>
<td>返回鼠标相对于文档页面的X坐标 IE9+支持</td>
</tr>
<tr>
<td>e.pageY</td>
<td>返回鼠标相对于文档页面的Y坐标 IE9+支持</td>
</tr>
<tr>
<td>e.screenX</td>
<td>返回鼠标相对于电脑屏幕的X坐标</td>
</tr>
<tr>
<td>e.srceenY</td>
<td>返回鼠标相对于电脑屏幕的Y坐标</td>
</tr>
</tbody></table>
</li>
<li><p>案例：跟随鼠标的小天使</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;img src=&quot;images/angel.gif&quot; alt=&quot;&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var img = document.querySelector(&#x27;img&#x27;);</span><br><span class="line"></span><br><span class="line">        // 获取鼠标相对于文档页面的坐标</span><br><span class="line">        document.addEventListener(&#x27;mousemove&#x27;, function (e) &#123;</span><br><span class="line">            // 鼠标相对于文档页面的X坐标</span><br><span class="line">            var x = e.pageX;</span><br><span class="line">            // 鼠标相对于文档页面的Y坐标</span><br><span class="line">            var y = e.pageY;</span><br><span class="line">            // 将x和y坐标给小天使图片，千万不要忘记添加px单位</span><br><span class="line">            img.style.left = (x - 50) + &#x27;px&#x27;;</span><br><span class="line">            img.style.top = (y - 40) + &#x27;px&#x27;;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="常用键盘事件"><a href="#常用键盘事件" class="headerlink" title="常用键盘事件"></a>常用键盘事件</h2><table>
<thead>
<tr>
<th>键盘事件</th>
<th>触发条件</th>
</tr>
</thead>
<tbody><tr>
<td>onkeyup</td>
<td>某个键盘按键被松开时触发</td>
</tr>
<tr>
<td>onkeydown</td>
<td>某个键盘按键被按下时触发</td>
</tr>
<tr>
<td>onkeypress</td>
<td>某个键盘按键被按下时触发（不识别功能键，识别大小写，比如ctrl shift箭头等）</td>
</tr>
</tbody></table>
<ol>
<li>注意<ol>
<li>keyup和keydow事件不区分字母大小写，keypress区分大小写</li>
<li>若三个事件都需要执行，则它们的执行顺序是：keydown – keypress – keyup</li>
</ol>
</li>
</ol>
<h3 id="键盘事件对象"><a href="#键盘事件对象" class="headerlink" title="键盘事件对象"></a>键盘事件对象</h3><table>
<thead>
<tr>
<th>键盘事件对象 属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>keyCode</td>
<td>返回该键的ASCII值</td>
</tr>
</tbody></table>
<ol>
<li>可以利用keyCode返回的ASCII码值来判断用户按下了哪个键</li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>ES5中新增方法</title>
    <url>/2022/08/01/ES5%E4%B8%AD%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="ES5中的新增方法"><a href="#ES5中的新增方法" class="headerlink" title="ES5中的新增方法"></a>ES5中的新增方法</h1><h2 id="数组方法-—-迭代（遍历）方法"><a href="#数组方法-—-迭代（遍历）方法" class="headerlink" title="数组方法 — 迭代（遍历）方法"></a>数组方法 — 迭代（遍历）方法</h2><ol>
<li>迭代方法（遍历）方法：forEach()、map()、filter()、some()、every()、find()、findIndex()</li>
</ol>
<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h3><ol>
<li><p>语法</p>
<ul>
<li>array.forEach(function(currentValue, index, arr))</li>
</ul>
<ol>
<li><p>currentValue：数组当前项的值</p>
</li>
<li><p>index：数组当前项的索引</p>
</li>
<li><p>arr：数组对象本身</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [1, 2, 3];</span><br><span class="line">arr.forEach(function (value, index, arr) &#123;</span><br><span class="line">    console.log(value); // 输出数组元素</span><br><span class="line">    console.log(index); // 输出数组元素索引</span><br><span class="line">    console.log(arr); // 输出数组本身</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><ol>
<li><p>语法：array.filter(function(currentValue, index, arr))</p>
<ol>
<li>currentValue：数组当前项的值</li>
<li>index：数组当前项的索引</li>
<li>arr：数组对象本身</li>
</ol>
</li>
<li><p>filter()方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素，主要用于筛选数组</p>
</li>
<li><p>返回一个新数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [12, 5, 71, 19, 24];</span><br><span class="line">  // 方法的返回值是一个新数组</span><br><span class="line">  var newArr = arr.filter(function (value, index) &#123;</span><br><span class="line">    // 筛选出数组中的偶数，将值赋值给新的数组</span><br><span class="line">    return value % 2 === 0;</span><br><span class="line">  &#125;)</span><br><span class="line">  console.log(newArr);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h3><ol>
<li><p>some方法用于检测数组中是否存在满足指定条件的元素</p>
</li>
<li><p><strong>与every()的区别：一真即真</strong>， 只要其中一个为true就会返回true</p>
</li>
<li><p>语法：array.some(function(currentValue, index, arr))</p>
<ol>
<li>currentValue：数组当前项的值</li>
<li>index：数组当前项的索引</li>
<li>arr：数组对象本身</li>
</ol>
</li>
<li><p>返回值为布尔值，如果查找到这个元素则返回true终止循环，否则返回false继续循环</p>
</li>
<li><p>若找到第一个满足条件的元素，则终止循环，不再进行查找，迭代效率更高</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [1, 2, 8, 41, 3];</span><br><span class="line">// 方法返回值为布尔值</span><br><span class="line">var flag = arr.some(function (value, index, array) &#123;</span><br><span class="line">    return value &gt; 5;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(flag); // true</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h3><ol>
<li><p>every() 方法用于检测数组所有元素是否都符合指定条件</p>
</li>
<li><p><strong>与some()的区别：一假即假</strong>，必须所有都返回true才会返回true，哪怕有一个false，就会返回false</p>
</li>
<li><p>语法：array.every(function(currentValue, index, arr))</p>
<ol>
<li>currentValue：必须，当前元素的值</li>
<li>index：可选，当前元素的索引值</li>
<li>arr： 可选，当前元素属于的数组对象</li>
</ol>
</li>
<li><p>如果数组中检测到有一个元素不满足，则整个表达式返回false ，且剩余的元素不会再进行检测</p>
</li>
<li><p>如果所有元素都满足条件，则返回true</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [4, 6, 8, 41, 37];</span><br><span class="line">// 方法返回值为布尔值</span><br><span class="line">var flag = arr.some(function (value, index, array) &#123;</span><br><span class="line">    return value &gt; 3;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(flag); // true</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><ol>
<li><p>map()：通过指定函数处理数组的每个元素，并返回处理后的数组</p>
</li>
<li><p>语法：array.map(function(currentValue, index, arr))</p>
<ol>
<li>currentValue：当前被遍历的元素的值</li>
<li>index：可选，当前元素的索引值</li>
<li>arr：可选，当前元素属于的数组对象</li>
</ol>
</li>
<li><p>注意：</p>
<ol>
<li>map() 不会对空数组进行检测</li>
<li>map() 不会改变原始数组</li>
</ol>
</li>
<li><p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4];</span><br><span class="line">// 方法返回值为布尔值</span><br><span class="line">var result = arr.map(item =&gt; &#123;</span><br><span class="line">    // ``为模板字符串</span><br><span class="line">    retrun `&lt;li class=&quot;name&quot;&gt;$&#123;item&#125;&lt;/li&gt;`</span><br><span class="line">&#125;)</span><br><span class="line">console.log(result);</span><br><span class="line">// [&lt;li class=&quot;name&quot;&gt;1&lt;/li&gt;, &lt;li class=&quot;name&quot;&gt;2&lt;/li&gt;. &lt;li class=&quot;name&quot;&gt;3&lt;/li&gt;, &lt;li class=&quot;name&quot;&gt;4&lt;/li&gt;]</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h3><ol>
<li><p>findJ()：用于找出第一个符合条件的数组成员，<strong>返回值为该数组成员，若没有找到返回undefined</strong></p>
</li>
<li><p>语法：array.find(function(currentValue, index, arr))</p>
<ol>
<li>currentValue：当前被遍历的元素的值</li>
<li>index：可选，当前元素的索引值</li>
<li>arr：可选，当前元素属于的数组对象</li>
</ol>
</li>
<li><p><strong>注意：</strong></p>
<ol>
<li>find() 对于空数组，函数是不会执行的</li>
<li>find() 并没有改变数组的原始值</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    let array = [</span><br><span class="line">        &#123;</span><br><span class="line">            id: 1,</span><br><span class="line">            name: &#x27;张三&#x27;</span><br><span class="line">        &#125;, </span><br><span class="line">        &#123;</span><br><span class="line">            id: 2,</span><br><span class="line">            name: &#x27;李四&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">// 寻找id值为2的数组成员</span><br><span class="line">    var ary = array.find(item =&gt; item.id == 2);</span><br><span class="line">    console.log(ary); // &#123;id: 2, name: &quot;李四&quot;&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="findIndex"><a href="#findIndex" class="headerlink" title="findIndex()"></a>findIndex()</h3><ol>
<li><p>findIndex()：用于找出第一个符合条件的数组成员的位置，<strong>找到返回数组元素索引，若没有找到返回-1</strong></p>
</li>
<li><p>语法：array.findIndex(function(currentValue, index, arr))</p>
<ol>
<li>currentValue：当前被遍历的元素的值</li>
<li>index：可选，当前元素的索引值</li>
<li>arr：可选，当前元素属于的数组对象</li>
</ol>
</li>
<li><p><strong>注意：</strong></p>
<ol>
<li>find() 对于空数组，函数是不会执行的</li>
<li>find() 并没有改变数组的原始值</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  let arr = [4, 5, 77, 13, 49, 6];</span><br><span class="line">  // 查询数组中第一个大于10的元素位置索引</span><br><span class="line">  var result = arr.findIndex(value =&gt; value &gt; 10)</span><br><span class="line">  console.log(result); // 2</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h1><h3 id="trim"><a href="#trim" class="headerlink" title="trim()"></a>trim()</h3><ol>
<li>语法<ul>
<li>字符串变量.trim()</li>
</ul>
</li>
<li>trim()方法会从一个字符串的两端删除空白字符</li>
<li>trim()方法并不影响原字符串本身，它返回的是一个新的字符串</li>
</ol>
<h2 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h2><h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty()"></a>Object.defineProperty()</h3><ol>
<li><p>Obejct.defineProperty()：定义新属性或修改原有的属性</p>
<ol>
<li><p>语法</p>
<ul>
<li>Obejct.defineProperty(obj, prop, descriptor)<ul>
<li>obj：必需，目标对象</li>
<li>prop：必需，需要定义或者修改的属性的名字</li>
<li>descriptor：必需，目标属性所拥有的特性</li>
<li>第三个参数descriptor说明：以对象形式{}书写</li>
</ul>
</li>
</ul>
</li>
<li><p>第三个descriptor属性的属性值</p>
<ul>
<li>value：设置属性的值，默认为undefined</li>
<li>writable：值是否可以重写，true | false，默认为false</li>
<li>enumerable：目标属性是否可以被枚举（遍历），true | false，默认为false</li>
<li>configurable：目标属性是否可以被删除或是否可以再次修改特性，true | false，默认false</li>
</ul>
</li>
<li><p>代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const person = &#123;</span><br><span class="line">    name: &#x27;张三&#x27;,</span><br><span class="line">    sex: &#x27;男&#x27;</span><br><span class="line">&#125;</span><br><span class="line">Object.defineProperty(person, &#x27;age&#x27;, &#123;</span><br><span class="line">    value: 18 // 设置age的属性值</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>ES5</category>
      </categories>
      <tags>
        <tag>ES5</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6剩余参数</title>
    <url>/2022/08/01/ES6%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<h1 id="ES6剩余参数"><a href="#ES6剩余参数" class="headerlink" title="ES6剩余参数"></a>ES6剩余参数</h1><ol>
<li><p>剩余参数：当实参个数大于形参个数时，将剩余的不定数量的参数表示为一个数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  const fn = (first, ...args) =&gt; &#123;</span><br><span class="line">    console.log(first); // 1</span><br><span class="line">    // args为一个数组</span><br><span class="line">    console.log(args); // [2, 3, 4]</span><br><span class="line">    console.log(...args); // 2 3 4</span><br><span class="line">  &#125;</span><br><span class="line">  fn(1, 2, 3, 4);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>例：求任意个数据相加之和</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  const sum = (...args) =&gt; &#123;</span><br><span class="line">    let result = 0;</span><br><span class="line">    // 遍历数组</span><br><span class="line">    args.forEach(value =&gt; result += value)</span><br><span class="line">    // args.forEach((value) =&gt; &#123;</span><br><span class="line">    //     result += value;</span><br><span class="line">    // &#125;)</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(sum(10, 20, 30)); // 60</span><br><span class="line">  console.log(sum(10, 20, 30, 40)); // 100</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>剩余参数与解构配合使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  let arr = [&#x27;张三&#x27;, &#x27;李四&#x27;, &#x27;王五&#x27;];</span><br><span class="line">  let [arr1, ...arr2] = arr;</span><br><span class="line">  console.log(arr1); // 张三</span><br><span class="line">  // arr2为数组</span><br><span class="line">  console.log(arr2); // Array(2) [&#x27;李四&#x27;, &#x27;王五&#x27;]</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6对象的扩展</title>
    <url>/2022/08/01/ES6%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<h1 id="ES6对象的扩展"><a href="#ES6对象的扩展" class="headerlink" title="ES6对象的扩展"></a>ES6对象的扩展</h1><h3 id="属性的简写"><a href="#属性的简写" class="headerlink" title="属性的简写"></a>属性的简写</h3><ol>
<li>当属性名和属性值名称相同时，属性值可以不写，只写一个属性名即可</li>
</ol>
<h3 id="Obeject-keys-方法"><a href="#Obeject-keys-方法" class="headerlink" title="Obeject.keys()方法"></a>Obeject.keys()方法</h3><ol>
<li><p>获取对象的所有属性名或方法名（不包括原型的内容），返回一个数组</p>
</li>
<li><p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  name: &quot;john&quot;,</span><br><span class="line">  age: &quot;21&quot;, </span><br><span class="line">  getName: function () &#123; </span><br><span class="line">    alert(this.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(Object.keys(obj));                 // [&quot;name&quot;, &quot;age&quot;, &quot;getName&quot;] </span><br><span class="line">console.log(Object.keys(obj).length);          // 3 </span><br><span class="line">console.log(Object.keys([&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;]));  // [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;] </span><br><span class="line">console.log(Object.keys(&quot;abcdef&quot;));            // [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;]</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Object-assign-方法"><a href="#Object-assign-方法" class="headerlink" title="Object.assign()方法"></a>Object.assign()方法</h3><ol>
<li><p>assign 方法将多个原对象的属性和方法都合并到了目标对象上面</p>
</li>
<li><p>第一个参数是目标对象，后面的都是源对象</p>
</li>
<li><p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var target = &#123;&#125;; //目标对象 </span><br><span class="line">var source1 = &#123;name : &#x27;ming&#x27;, age: &#x27;19&#x27;&#125;; //源对象 1 </span><br><span class="line">var source2 = &#123;sex : &#x27;女&#x27;&#125;; //源对象2 </span><br><span class="line">var source3 = &#123;sex : &#x27;男&#x27;&#125;; //源对象3，和source2 中的对象有同名属性sex ，则覆盖同名属性sex</span><br><span class="line">Object.assign(target, source1, source2, source3); </span><br><span class="line">console.log(target); //&#123;name : &#x27;ming&#x27;, age: &#x27;19&#x27;, sex: &#x27;男&#x27;&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES5面向对象编程</title>
    <url>/2022/08/01/ES5%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="面向对象编程介绍"><a href="#面向对象编程介绍" class="headerlink" title="面向对象编程介绍"></a>面向对象编程介绍</h1><h2 id="两大编程思想"><a href="#两大编程思想" class="headerlink" title="两大编程思想"></a>两大编程思想</h2><ol>
<li>面向过程</li>
<li>面向对象</li>
</ol>
<h2 id="面向过程编程"><a href="#面向过程编程" class="headerlink" title="面向过程编程"></a>面向过程编程</h2><ol>
<li>面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的依次调用</li>
</ol>
<h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><ol>
<li>面向对象是把事务分解成为一个个对象，然后由对象之间分工与合作</li>
<li>面向对象是以对象功能来划分问题，而不是步骤</li>
<li>在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工</li>
<li>面向对象编程具有灵活、代码可复用、容易维护和开发的优点，更适合多人合作的大型软件项目</li>
</ol>
<h3 id="面向对象特性"><a href="#面向对象特性" class="headerlink" title="面向对象特性"></a>面向对象特性</h3><ol>
<li>封装性</li>
<li>继承性</li>
<li>多态性</li>
</ol>
<h3 id="面向过程和面向对象的对比"><a href="#面向过程和面向对象的对比" class="headerlink" title="面向过程和面向对象的对比"></a>面向过程和面向对象的对比</h3><ol>
<li>面向过程<ol>
<li>性能比面向对象高适合跟硬件联系很紧密的东西</li>
<li>缺点：没有面向对象易维护、易复用、易扩展</li>
</ol>
</li>
<li>面向对象<ol>
<li>优点：易维护、易复用、易扩展由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护</li>
<li>缺点：性能低于面向过程</li>
</ol>
</li>
</ol>
<h1 id="面向对象Tab栏案例"><a href="#面向对象Tab栏案例" class="headerlink" title="面向对象Tab栏案例"></a>面向对象Tab栏案例</h1><h2 id="抽象对象：Tab对象"><a href="#抽象对象：Tab对象" class="headerlink" title="抽象对象：Tab对象"></a>抽象对象：Tab对象</h2><ol>
<li>该对象具有切换功能 — 切换方法</li>
<li>该对象具有添加功能 — 添加方法</li>
<li>该对象具有删除功能 — 删除方法</li>
<li>该对象具有修改功能 — 修改方法</li>
<li>因为页面一经加载就需要给元素绑定点击事件，因此需要一个初始化功能 — 初始化函数</li>
</ol>
<h3 id="面向对象版tab栏切换-—-添加功能"><a href="#面向对象版tab栏切换-—-添加功能" class="headerlink" title="面向对象版tab栏切换 — 添加功能"></a>面向对象版tab栏切换 — 添加功能</h3><ol>
<li>点击 + 可以实现添加新的选项卡和内容</li>
<li>第一步：创建新的选项卡li和新的内容section</li>
<li>第二步：把创建的两个元素追加到对应的父元素中.</li>
<li>以前的做法：动态创建元素createElement，但是元素里面内容较多，需要innerHTML赋值在appendChild追加到父元素里面。</li>
<li>现在高级做法：利用insertAdjacentHTML()可以直接把字符串格式元素添加到父元素中</li>
<li>appendChild不支持追加字符串的子元素，insertAdjacentHTML支持追加字符串的元素</li>
<li>因为每次进行tab栏添加后，都需要重新获取li和section，所以将获取li和section封装为一个函数，每次点击添加后都进行调用</li>
</ol>
<h3 id="面向对象版tab栏切换-—-删除功能"><a href="#面向对象版tab栏切换-—-删除功能" class="headerlink" title="面向对象版tab栏切换 — 删除功能"></a>面向对象版tab栏切换 — 删除功能</h3><ol>
<li>击’x’可以删除当前的li选项卡和当前的section</li>
<li>‘x’是没有索引号的，但是它的父亲li有索引号，这个索引号正是我们想要的索引号</li>
<li>所以核心思路是：点击’x’号可以删除这个索引号对应的li和section</li>
</ol>
<h3 id="面向对象版tab栏切换-—-编辑功能"><a href="#面向对象版tab栏切换-—-编辑功能" class="headerlink" title="面向对象版tab栏切换 — 编辑功能"></a>面向对象版tab栏切换 — 编辑功能</h3><ol>
<li>双击选顶卡li或者section里面的文字，可以实现修改功能</li>
<li>双击事件是：ondblclick</li>
<li>如果双击文字，会默认选定文字，此时需要双击禁止选中文字<ol>
<li>方法一：js中在对应方法中添加代码<ul>
<li>window.getSelection?window.getSelection().removeAllRanges():document.selection.empty();</li>
</ul>
</li>
<li>方法二：在对应li和section的css样式中添加，会导致单击也无法选中<ul>
<li>user-select: none;</li>
</ul>
</li>
</ol>
</li>
<li>核心思路：双击文字的时候，在里面生成一个文本框，当失去焦点或者按下回车键时，把文本框输入的值给原先元素即可</li>
</ol>
<h3 id="面向对象版tab栏切换-—-代码演示"><a href="#面向对象版tab栏切换-—-代码演示" class="headerlink" title="面向对象版tab栏切换 — 代码演示"></a>面向对象版tab栏切换 — 代码演示</h3><ol>
<li><p>html结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;css/index.css&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h3&gt;JS面向对象 动态添加标签页&lt;/h3&gt;</span><br><span class="line">    &lt;div class=&quot;tab&quot; id=&quot;tab&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;tab-top&quot;&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &lt;li class=&quot;backcolor&quot;&gt;</span><br><span class="line">                    测试1</span><br><span class="line">                    &lt;span&gt;&lt;/span&gt;</span><br><span class="line">                &lt;/li&gt;</span><br><span class="line">                &lt;li&gt;</span><br><span class="line">                    测试2</span><br><span class="line">                    &lt;span&gt;&lt;/span&gt;</span><br><span class="line">                &lt;/li&gt;</span><br><span class="line">                &lt;li&gt;</span><br><span class="line">                    测试3</span><br><span class="line">                    &lt;span&gt;&lt;/span&gt;</span><br><span class="line">                &lt;/li&gt;</span><br><span class="line">                &lt;div class=&quot;append&quot;&gt;+&lt;/div&gt;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;tab-content&quot;&gt;</span><br><span class="line">            &lt;section class=&#x27;block&#x27;&gt;测试一&lt;/section&gt;</span><br><span class="line">            &lt;section&gt;测试二&lt;/section&gt;</span><br><span class="line">            &lt;section&gt;测试三&lt;/section&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script src=&quot;js/index.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>js代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 创建一个tab类</span><br><span class="line">// var that;</span><br><span class="line">class Tab &#123;</span><br><span class="line">  constructor(id) &#123;</span><br><span class="line">    // that = this;</span><br><span class="line">    // 获取实例化对象中的元素</span><br><span class="line">    // 先获取整个tab</span><br><span class="line">    this.main = document.querySelector(id);</span><br><span class="line">    // 获取添加按钮</span><br><span class="line">    this.appends = this.main.querySelector(&#x27;.append&#x27;);</span><br><span class="line">    // 获取ul</span><br><span class="line">    this.ul = this.main.querySelector(&#x27;.tab-top ul:first-child&#x27;);</span><br><span class="line">    // 获取tab-content    </span><br><span class="line">    this.tab_content = this.main.querySelector(&#x27;.tab-content&#x27;);</span><br><span class="line">    // 实例化对象时即调用初始化函数</span><br><span class="line">    this.init();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 初始化函数</span><br><span class="line">  init() &#123;</span><br><span class="line">    // 初始化时，获取li和section</span><br><span class="line">    this.updateNode();</span><br><span class="line">    // 给appends绑定点击事件</span><br><span class="line">    // 这里调用函数不要加()，因为此处是点击后才调用，加括号后则是页面加载即调用</span><br><span class="line">    this.appends.onclick = this.addTab.bind(this.appends, this);</span><br><span class="line">    // 给lis绑定点击事件</span><br><span class="line">    for (var i = 0; i &lt; this.lis.length; i++) &#123;</span><br><span class="line">      // 给每一个li设置索引号</span><br><span class="line">      this.lis[i].index = i;</span><br><span class="line">      // 这里调用函数不要加()，因为此处是点击后才调用，加括号后则是页面加载即调用</span><br><span class="line">      this.lis[i].onclick = this.toggleTab.bind(this.lis[i], this);</span><br><span class="line">      // 给每一个span绑定点击事件</span><br><span class="line">      // 这里调用函数不要加()，因为此处是点击后才调用，加括号后则是页面加载即调用</span><br><span class="line">      this.spans[i].onclick = this.removeTab.bind(this.spans[i], this);</span><br><span class="line">      // 给每一个li绑定双击事件</span><br><span class="line">      this.lis[i].ondblclick = this.editTab;</span><br><span class="line">      this.sections[i].ondblclick = this.editTab;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 因为经常进行tab栏的添加删除，所以要多次获取li、section和span</span><br><span class="line">  updateNode() &#123;</span><br><span class="line">    // 获取所有的li</span><br><span class="line">    this.lis = this.main.querySelectorAll(&#x27;li&#x27;);</span><br><span class="line">    // 获取所有的section</span><br><span class="line">    this.sections = this.main.querySelectorAll(&#x27;section&#x27;);</span><br><span class="line">    // 获取所有的span</span><br><span class="line">    this.spans = this.main.querySelectorAll(&#x27;span&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 切换功能</span><br><span class="line">  toggleTab(that) &#123;</span><br><span class="line">    // tab-top实现切换功能</span><br><span class="line">    // 这里的that为指向实例化对象</span><br><span class="line">    that.clearClass();</span><br><span class="line">    // 留下自己，给被点击的li添加类名</span><br><span class="line">    this.className = &#x27;backcolor&#x27;;</span><br><span class="line"></span><br><span class="line">    // tab-content实现切换功能</span><br><span class="line">    // 留下自己，给被点击的li对应的section添加类名</span><br><span class="line">    that.sections[this.index].className = &#x27;block&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line">  // 排他思想清除类函数</span><br><span class="line">  clearClass() &#123;</span><br><span class="line">    // 因为这个函数是由that调用的，所以this指向的是实例化对象</span><br><span class="line">    for (var j = 0; j &lt; this.lis.length; j++) &#123;</span><br><span class="line">      // 排他思想：干掉别人，让所有的li去掉类</span><br><span class="line">      this.lis[j].className = &#x27;&#x27;;</span><br><span class="line">      // 排他思想：干掉别人，清除每一个section的类</span><br><span class="line">      this.sections[j].className = &#x27;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 添加功能</span><br><span class="line">  addTab(that) &#123;</span><br><span class="line">    // 创建一个li和span节点，将span节点放入li中</span><br><span class="line">    // 创建li元素</span><br><span class="line">    var li = &#x27;&lt;li&gt;新选项卡&lt;span&gt;&lt;/span&gt;&lt;/li&gt;&#x27;;</span><br><span class="line">    // 将li元素插入ul中</span><br><span class="line">    that.ul.insertAdjacentHTML(&#x27;beforeend&#x27;, li);</span><br><span class="line"></span><br><span class="line">    // 创建section元素，添加入tab-content中</span><br><span class="line">    var section = &#x27;&lt;section&gt;请输入内容&lt;/section&gt;&#x27;;</span><br><span class="line">    // 将section元素添加进入ab-content中</span><br><span class="line">    that.tab_content.insertAdjacentHTML(&#x27;beforeend&#x27;, section);</span><br><span class="line">    // 每次添加li和section元素时，都需要重新初始化，重新调用li和section</span><br><span class="line">    that.init();</span><br><span class="line">  &#125;</span><br><span class="line">  // 删除功能</span><br><span class="line">  removeTab(that, e) &#123;</span><br><span class="line">    // 阻止冒泡，避免点击span&#x27;x&#x27;号后，冒泡触发点击li的事件</span><br><span class="line">    e.stopPropagation();</span><br><span class="line">    // 因为span没有索引，则获取当前被点击span的父元素的索引</span><br><span class="line">    var index = this.parentNode.index;</span><br><span class="line">    // 删除索引号对应的li和section</span><br><span class="line">    that.lis[index].remove();</span><br><span class="line">    that.sections[index].remove();</span><br><span class="line">    // 每次删除li和section元素时，都需要重新初始化</span><br><span class="line">    that.init();</span><br><span class="line">    // 当删除的是未被选中的tab选项时，被选中的tab选项不变</span><br><span class="line">    if (that.main.querySelector(&quot;.backcolor&quot;)) return;</span><br><span class="line">    // 当删除被选中的tab选项时，该tab选项的前一个tab选项会被自动选中</span><br><span class="line">    // 可以采用被自动点击的方式实现</span><br><span class="line">    index--;</span><br><span class="line">    // 当所有的tab选项被删除时，index为-1， that.lis[index]不存在则停止点击事件</span><br><span class="line">    that.lis[index] &amp;&amp; that.lis[index].click();</span><br><span class="line">  &#125;</span><br><span class="line">  // 修改功能</span><br><span class="line">  editTab() &#123;</span><br><span class="line">    // 取消默认双击选定文字</span><br><span class="line">    window.getSelection ? window.getSelection().removeAllRanges() : document.selection.empty();</span><br><span class="line">    // 获取li中的文字</span><br><span class="line">    var str = this.innerText;</span><br><span class="line">    // 每当li被双击时，就在span内部生成一个input表单替换span里面的文字</span><br><span class="line">    this.innerHTML = &#x27;&lt;input type=&quot;text&quot;&gt;&#x27;;</span><br><span class="line">    // 获取对应的input</span><br><span class="line">    var input = this.children[0];</span><br><span class="line">    // 将li中的文字赋值给文本框</span><br><span class="line">    input.value = str;</span><br><span class="line">    // 让文本框中的内容处于选中状态</span><br><span class="line">    input.select();</span><br><span class="line"></span><br><span class="line">    // 当文本框失去焦点或者按下enter键则将文本框的内容赋值给li</span><br><span class="line">    input.onblur = function () &#123;</span><br><span class="line">      // 这里的this指向input</span><br><span class="line">      this.parentNode.innerHTML = input.value + &#x27;&lt;span&gt;&lt;/span&gt;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    // enter键的ASCII码值为13</span><br><span class="line">    input.onkeyup = function (e) &#123;</span><br><span class="line">      if (e.keyCode === 13) &#123;</span><br><span class="line">        this.blur();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实例化一个tab对象</span><br><span class="line">new Tab(&#x27;#tab&#x27;);</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>ES5</category>
      </categories>
      <tags>
        <tag>ES5</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6新增关键字</title>
    <url>/2022/08/01/ES6%E6%96%B0%E5%A2%9E%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><h2 id="新增关键字"><a href="#新增关键字" class="headerlink" title="新增关键字"></a>新增关键字</h2><h3 id="let变量"><a href="#let变量" class="headerlink" title="let变量"></a>let变量</h3><ol>
<li><p>let变量：ES6中新增的用于变量声明的关键字</p>
<ol>
<li><p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let a;</span><br><span class="line">let b, c, d;</span><br><span class="line">let e =100;</span><br><span class="line">let f = 521, g = &#x27;love&#x27;, h = [];</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>特性：</p>
<ol>
<li>变量不能重复声明</li>
<li>块级作用域，只在所处代码块内部有效<ul>
<li>在一个大括号中，使用let关键字声明的变量才具有块级作用域，var关键字不具备这个特点</li>
</ul>
</li>
<li>防止循环变量变成全局变量</li>
<li>不存在变量提升</li>
<li>不影响作用域链的效果</li>
</ol>
</li>
<li><p>经典面试题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  var arr = [];</span><br><span class="line">  for (var i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">    arr[i] = function () &#123;</span><br><span class="line">      console.log(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 因为变量i是全局变量，函数执行时输出的是全局作用域的i值</span><br><span class="line">  // 而for循环是一个同步任务，函数执行时，循环已经结束，因此i值为2</span><br><span class="line">  arr[0](); // 2</span><br><span class="line">  arr[1](); // 2</span><br><span class="line"></span><br><span class="line">  let array = [];</span><br><span class="line">  for (let i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">    array[i] = function () &#123;</span><br><span class="line">      console.log(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 每次循环都会产生一个块级作用域，每个块级作用域中的i值都是不同的</span><br><span class="line">  // 函数执行时，输出的是自己上一级（循环产生的块级作用域）中的i值</span><br><span class="line">  array[0](); // 0</span><br><span class="line">  array[1](); // 1</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="const关键字"><a href="#const关键字" class="headerlink" title="const关键字"></a>const关键字</h3><ol>
<li><p>const关键字：用来声明常量，常量就是值（内存地址）不能变化的量</p>
</li>
<li><p>特性：</p>
<ol>
<li><p>用const声明常量一定要赋初始值</p>
</li>
<li><p>一般常量使用大写（潜规则）</p>
</li>
<li><p>块级作用域，只在所处代码块内部有效</p>
</li>
<li><p>常量赋值后，值不能修改，实际上是值对应的内存地址不可更改</p>
<ul>
<li>基本数据类型：常量声明后，值不可更改</li>
<li>复杂数据类型（数组对象）：数据结构内部的值可以更改，数据本身不可更改</li>
</ul>
</li>
<li><p>对于数组和对象进行元素修改，不算做是对常量的修改，不会报错；但是如果对数组和对象的值直接进行修改，则会报错，因为改变内存地址；因此声明数组和对象时推荐使用const关键字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  const ARR = [1, &#x27;a&#x27;, 2, &#x27;b&#x27;];</span><br><span class="line">  ARR.push(3); // 不报错，对数组和对象进行元素修改</span><br><span class="line">  ARR = [1, 3, 5]; // 报错，对数组和对象的值直接进行修改，改变了地址</span><br><span class="line">  ARR = 100; // 报错，对数组和对象的值直接进行修改，改变了地址</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="let、const、var声明变量的区别"><a href="#let、const、var声明变量的区别" class="headerlink" title="let、const、var声明变量的区别"></a>let、const、var声明变量的区别</h3><ol>
<li><p>使用var声明的变量，其作用域为该语句所在的函数内，且存在变量提升现象</p>
</li>
<li><p>使用let声明的变量，其作用域为该语句所在的代码块内，不存在变量提升</p>
</li>
<li><p>使用const声明的是常量，在后面出现的代码中不能再修改该常量的值</p>
<table>
<thead>
<tr>
<th>var</th>
<th>let</th>
<th>const</th>
</tr>
</thead>
<tbody><tr>
<td>函数级作用域</td>
<td>块级作用域</td>
<td>块级作用域</td>
</tr>
<tr>
<td>变量提升</td>
<td>不存在变量提升</td>
<td>不存在变量提升</td>
</tr>
<tr>
<td>值可改变</td>
<td>值可改变</td>
<td>值不可改变</td>
</tr>
</tbody></table>
</li>
</ol>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6模块化的导入和导出</title>
    <url>/2022/08/02/ES6%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E5%AF%BC%E5%85%A5%E5%92%8C%E5%AF%BC%E5%87%BA/</url>
    <content><![CDATA[<h1 id="ES6模块化的导入和导出"><a href="#ES6模块化的导入和导出" class="headerlink" title="ES6模块化的导入和导出"></a>ES6模块化的导入和导出</h1><h2 id="ES6的模块化"><a href="#ES6的模块化" class="headerlink" title="ES6的模块化"></a>ES6的模块化</h2><ol>
<li>在引入js文件时，在标签内部加上属性type&#x3D;’module’，也就是将类型设置为module；如果这样引入js文件，则表示是以模块化的思想对js文件进行使用的，一旦以模块化思想进行使用，就意味着被引入的这个js代码就是一个模块，单独的模块有单独的作用域</li>
</ol>
<h2 id="export和import基本使用"><a href="#export和import基本使用" class="headerlink" title="export和import基本使用"></a>export和import基本使用</h2><ol>
<li>模块化的用于导出变量（export）有两种方法<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211011002435.png" alt="img"><img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211011002508.png" alt="img"></li>
<li>模块化导入变量（import)<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211011002524.png" alt="img"></li>
</ol>
<h2 id="export-default"><a href="#export-default" class="headerlink" title="export default"></a>export default</h2><ol>
<li>某些情况下，一个模块中包含某个功能，我们并不希望给这个功能命名，而是让导入者可以自己命名</li>
<li>这个时候就可以使用export default</li>
<li>export default在同一个模块中，不允许同时存在多个<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211011002545.png" alt="img"><img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211011002554.png" alt="img"></li>
</ol>
<h2 id="统一全部导入"><a href="#统一全部导入" class="headerlink" title="统一全部导入"></a>统一全部导入</h2><ol>
<li>通过 * 可以导入模块中所有的export变量</li>
<li>但是通常情况下我们需要给*取一个别名，方便后续使用<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211011002626.png" alt="img"></li>
</ol>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6的Array扩展方法</title>
    <url>/2022/08/01/ES6%E7%9A%84Array%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="ES6的Array的扩展方法"><a href="#ES6的Array的扩展方法" class="headerlink" title="ES6的Array的扩展方法"></a>ES6的Array的扩展方法</h1><h3 id="扩展运算符（展开语法）"><a href="#扩展运算符（展开语法）" class="headerlink" title="扩展运算符（展开语法）"></a>扩展运算符（展开语法）</h3><ol>
<li><p>扩展运算符可以将数组或者对象转化为用逗号分隔的参数序列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  let arr = [1, 2, 3, 4];</span><br><span class="line">  // ...arr; 相当于1, 2, 3, 4</span><br><span class="line">  // 因此console.log(...arr);相当于console.log(1, 2, 3, 4);</span><br><span class="line">  // 在输出时，console.log();语句会自动将&#x27;,&#x27;看作分隔符，因此输出时没有逗号</span><br><span class="line">  console.log(...arr);</span><br><span class="line">  // console.log(1, 2, 3, 4);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>扩展运算符可以应用</p>
<ol>
<li><p>数组合并</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  let arr1 = [1, 2, 3];</span><br><span class="line">  let arr2 = [&#x27;张三&#x27;, &#x27;李四&#x27;, &#x27;王五&#x27;];</span><br><span class="line">  // let arr = [...arr1, ...arr2];</span><br><span class="line">  arr1.push(...arr2);</span><br><span class="line">  console.log(arr1); // [1, 2, 3, &quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;]</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将伪数组转化为数组，从而方便的调用数组中的方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        let divs = document.querySelectorAll(&#x27;div&#x27;);</span><br><span class="line">        console.log(divs); // NodeList(5) [div, div, div, div, div]</span><br><span class="line">        // 将伪数组转化为数组 </span><br><span class="line">        var arr = [...divs];</span><br><span class="line">        console.log(arr); // [div, div, div, div, div]</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="构造函数方法Array-from"><a href="#构造函数方法Array-from" class="headerlink" title="构造函数方法Array.from()"></a>构造函数方法Array.from()</h3><ol>
<li><p>将伪数组或可遍历的对象转换为真正的数组（伪数组内必须有length属性）</p>
</li>
<li><p>方法返回值为转换完毕后的数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arrayLink = &#123;</span><br><span class="line">    &#x27;0&#x27;: &#x27;张三&#x27;,</span><br><span class="line">    &#x27;1&#x27;: &#x27;男&#x27;,</span><br><span class="line">    &#x27;length&#x27;: &#x27;2&#x27;</span><br><span class="line">&#125;;</span><br><span class="line">let arr = Array.from(arrayLink);</span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法还可以接受第二个参数，用来对每个元素进行处理，将处理后的值放入返回的数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr1 = &#123;</span><br><span class="line">    &#x27;0&#x27;: &#x27;1&#x27;,</span><br><span class="line">    &#x27;1&#x27;: &#x27;2&#x27;,</span><br><span class="line">    &#x27;2&#x27;: &#x27;3&#x27;,</span><br><span class="line">    &#x27;length&#x27;: &#x27;3&#x27;</span><br><span class="line">&#125;</span><br><span class="line">var ary = Array.from(arr1, item =&gt; item * 2);</span><br><span class="line">console.log(ary);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="实例方法：includes"><a href="#实例方法：includes" class="headerlink" title="实例方法：includes()"></a>实例方法：includes()</h3><ol>
<li>表示某个数组是否包含给定的值，返回布尔值<ul>
<li>可以对字符串进行匹配，也可以对变量进行匹配，但不可以对正则表达式进行匹配</li>
</ul>
</li>
<li>注意：<strong>该方法区分大小写</strong>，若想不区分大小写使用match()方法，方法参数正则表达式（见正则表达式）</li>
<li>两者区别<ol>
<li>match()可以对<strong>正则表达式</strong>进行匹配，也可以对<strong>字符串</strong>进行匹配，但<strong>不可以对变量</strong>进行匹配</li>
<li>includes()可以对<strong>字符串</strong>进行匹配，也可以对变量进行匹配，但<strong>不可以对正则表达式</strong>进行匹配</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6的Promise对象</title>
    <url>/2022/08/01/ES6%E7%9A%84Promise%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="ES6的Promise对象"><a href="#ES6的Promise对象" class="headerlink" title="ES6的Promise对象"></a>ES6的Promise对象</h1><ol>
<li><p>ES6中一个非常重要和好用的特性就是Promise</p>
</li>
<li><p>Promise是异步编程的一种解决方案，将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数</p>
</li>
<li><p>是为了解决异步处理回调地狱（也就是循环嵌套的问题）而产生的</p>
</li>
<li><p>Promise构造函数包含带有resolve（解析）和reject（拒绝）两个参数的回调</p>
</li>
<li><p>promise的作用：在出现异步操作，特别是异步操作嵌套多层异步操作出现回调地狱时，以一种优雅的方式来处理这些异步，增加代码的可读性和可维护性</p>
</li>
</ol>
<h3 id="Promise的三种状态"><a href="#Promise的三种状态" class="headerlink" title="Promise的三种状态"></a>Promise的三种状态</h3><ol>
<li><p>当开发中有异步操作时，就可以给异步操作包装一个Promise</p>
</li>
<li><p>异步操作后会有三种状态</p>
<ol>
<li><strong>pending</strong>：等待状态（既没有被兑现，也没有被拒绝），比如正在进行网络请求，或者定时器没有到时间</li>
<li><strong>fulfill</strong>：满足状态（操作成功完成），当我们主动回调了resolve时，就处于该状态，并且会<strong>回调then()</strong></li>
<li><strong>reject</strong>：拒绝状态（操作失败），当我们主动回调了reject时，就处于该状态，并且回调catch()</li>
</ol>
</li>
<li><p>当 promise 被调用后，它会以<strong>处理中状态</strong> （pending）开始。这意味着调用的函数会继续执行，而 promise 仍处于处理中直到解决为止，从而为调用的函数提供所请求的任何数据</p>
</li>
<li><p>被创建的 promise 最终会以<strong>被解决状态</strong> （fulfilled） 或 <strong>被拒绝状态</strong> （rejected） 结束，并在完成时调用相应的回调函数（传给 <strong>then</strong> 和 <strong>catch</strong>）</p>
</li>
</ol>
<h3 id="Promise链式调用"><a href="#Promise链式调用" class="headerlink" title="Promise链式调用"></a>Promise链式调用</h3><ol>
<li><p>无论是<strong>then还是catch都可以返回一个Promise对象</strong></p>
</li>
<li><p>所以，我们的代码其实是可以进行链式调用的</p>
</li>
<li><p>可以直接通过Promise包装了一下新的数据，将Promise对象返回</p>
<ol>
<li><strong>Promise.resolve()<strong>：</strong>将数据包装成Promise对象，并且在内部回调resolve()函数</strong>（成功之后的回调函数)</li>
<li><strong>Promise.reject()<strong>：</strong>将数据包装成Promise对象，并且在内部回调reject()函数</strong>（失败之后的回调函数）</li>
</ol>
</li>
<li><p>既然Promise创建的实例是一个异步操作那么这个异步操作的结果<strong>只能有两种状态</strong></p>
<ol>
<li><strong>状态一：</strong>异步执行成功 需要在内部调用，成功的回调函数resolve 把结果返回给调用者</li>
<li><strong>状态二：</strong>异步执行失败了 需要在内部调用，成功的回调函数reject把结果返回给调用者</li>
<li>由于Promise的实例是一个异步操作，所以拿到操作结果后，无法使用return把操作结果返回给调用者，这个时候只能使用回调函数的形式，来把成功或者失败的结果返回给调用者</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6的String扩展方法</title>
    <url>/2022/08/01/ES6%E7%9A%84String%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="ES6的String的扩展方法"><a href="#ES6的String的扩展方法" class="headerlink" title="ES6的String的扩展方法"></a>ES6的String的扩展方法</h1><h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><ol>
<li><p>ES6新增的创建字符串的方式，使用反引号定义</p>
</li>
<li><p><strong>模板字符串语法：${}</strong></p>
</li>
<li><p>模板字符串的特点</p>
<ol>
<li><p>模板字符串中可以解析变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let name = `张三`;</span><br><span class="line">let sayHello = `你好啊，我的朋友$&#123;name&#125;`;</span><br><span class="line">console.log(sayHello); // 你好啊，我的朋友张三</span><br></pre></td></tr></table></figure>
</li>
<li><p>模板字符串中可以实现换行</p>
</li>
<li><p>在模板字符串中可以调用函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let fn = () =&gt; &#123;</span><br><span class="line">    return `在干嘛`;</span><br><span class="line">&#125;</span><br><span class="line">let say = `你好呀，$&#123;fn()&#125;`;</span><br><span class="line">console.log(say);</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="实例方法：startsWith"><a href="#实例方法：startsWith" class="headerlink" title="实例方法：startsWith()"></a>实例方法：startsWith()</h3><ol>
<li>startsWith()：表示参数字符串是否在原字符串的头部，返回布尔值</li>
</ol>
<h3 id="实例方法：endsWith"><a href="#实例方法：endsWith" class="headerlink" title="实例方法：endsWith()"></a>实例方法：endsWith()</h3><ol>
<li><p>endsWith()：表示参数字符串是否在原字符串的尾部，返回布尔值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  let str = &#x27;hello world!&#x27;;</span><br><span class="line">  var flag1 = str.startsWith(&#x27;hell&#x27;); // true</span><br><span class="line">  var flag2 = str.endsWith(&#x27;d!&#x27;); // true</span><br><span class="line">  console.log(flag1, flag2);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="实例方法：repeat"><a href="#实例方法：repeat" class="headerlink" title="实例方法：repeat()"></a>实例方法：repeat()</h3><ol>
<li><p>repeat()：表示将原字符串重复n次，返回一个新的字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(&#x27;你好呀&#x27;.repeat(5));</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6的import和export</title>
    <url>/2022/08/01/ES6%E7%9A%84import%E5%92%8Cexport/</url>
    <content><![CDATA[<h1 id="ES6的import和export"><a href="#ES6的import和export" class="headerlink" title="ES6的import和export"></a>ES6的import和export</h1><ol>
<li>ES6标准中，JavaScript原生支持模块(module)</li>
<li>即将JS代码分割成不同功能的小块进行模块化，将不同功能的代码分别写在不同文件中，各模块只需导出公共接口部分，然后通过模块的导入的方式可以在其他地方使用</li>
<li>export：用于对外输出本模块（一个文件可以理解为一个模块）变量的接口</li>
<li>import：用于在一个模块中加载另一个含有export接口的模块</li>
<li>注意<ol>
<li>import和export命令只能书写在模块的顶部，不能在代码块之中</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6的async和await</title>
    <url>/2022/08/01/ES6%E7%9A%84async%E5%92%8Cawait/</url>
    <content><![CDATA[<h1 id="ES6的async和await"><a href="#ES6的async和await" class="headerlink" title="ES6的async和await"></a>ES6的async和await</h1><ol>
<li>使用async&#x2F;await，搭配Promise，可以通过编写形似同步的代码来处理异步流程，提高代码的简洁性和可读性</li>
<li>async用于声明一个function是异步的</li>
<li>await用于等待一个异步方法执行完成，返回一个Promise对象resolve回调函数的返回值</li>
<li>async和await必须同时使用，且await只能出现在async函数中<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211014010801.png" alt="img"></li>
</ol>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6的set数据结构</title>
    <url>/2022/08/01/ES6%E7%9A%84set%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="ES6的set数据结构"><a href="#ES6的set数据结构" class="headerlink" title="ES6的set数据结构"></a>ES6的set数据结构</h1><ol>
<li><p>ES6提供了新的数据结构Set，类似于数组，但是成员的值都是唯一的，没有重复的值</p>
</li>
<li><p>Set本身是一个构造函数，用来生成Set数据结构</p>
<ul>
<li>const s &#x3D; new set();</li>
</ul>
</li>
<li><p>set函数可以接受一个数组作为参数，用来初始化</p>
</li>
<li><p>size属性：Set数据结构中的一个属性，用于计算当前数据结构中包含了多少值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  const s = new Set();</span><br><span class="line">  console.log(s.size); // 0</span><br><span class="line"></span><br><span class="line">  const e = new Set([1, 2, 4, 5]);</span><br><span class="line">  console.log(e.size); // 4</span><br><span class="line"></span><br><span class="line">  const t = new Set([1, 2, 2, 5]);</span><br><span class="line">  console.log(t.size); // 3 当数组内有重复的值时，重复的数据会被过滤</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>案例：利用set数据结构做数组去重</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    const s = new Set([&#x27;a&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]);</span><br><span class="line">    var arr = [...s];</span><br><span class="line">    console.log(arr); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><ol>
<li><p>add(value)：添加某个值，返回Set结构本身</p>
</li>
<li><p>delete(value)：删除某个值，返回一个布尔值，表示删除是否成功</p>
</li>
<li><p>has(value)：返回一个布尔值，表示该值是否为Set的成员</p>
</li>
<li><p>clear()：清除所有成员，没有返回值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  const set = new Set([1, &#x27;a&#x27;, &#x27;b&#x27;]);</span><br><span class="line"></span><br><span class="line">  // add(value)</span><br><span class="line">  set.add(3).add(&#x27;c&#x27;).add(&#x27;hello&#x27;);</span><br><span class="line">  console.log(set); // Set(6) &#123;1, &quot;a&quot;, &quot;b&quot;, 3, &quot;c&quot;, &quot;hello&quot;&#125;</span><br><span class="line">  // delete(value)</span><br><span class="line">  var flag1 = set.delete(&#x27;a&#x27;);</span><br><span class="line">  console.log(flag1); // true</span><br><span class="line">  console.log(set); // Set(5) &#123;1, &quot;b&quot;, 3, &quot;c&quot;, &quot;hello&quot;&#125;</span><br><span class="line">  // has(value)</span><br><span class="line">  var flag2 = set.has(&#x27;hello&#x27;);</span><br><span class="line">  console.log(flag2); // true</span><br><span class="line">  // clear()</span><br><span class="line">  set.clear()</span><br><span class="line">  console.log(set); // Set(0) &#123;&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历set</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  const s = new Set([&#x27;a&#x27;, 1, &#x27;b&#x27;]);</span><br><span class="line">  s.forEach((value) =&gt; &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6的类和对象</title>
    <url>/2022/08/01/ES6%E7%9A%84%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="ES6中的类和对象"><a href="#ES6中的类和对象" class="headerlink" title="ES6中的类和对象"></a>ES6中的类和对象</h1><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><ol>
<li>现实生活中：万物皆对象，对象是一个具体的事物，如一本书，一个人</li>
<li>在javaScript中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象，如字符串、数值、数组、函数等</li>
<li>对象是有属性和方法组成的<ol>
<li>属性：事物的特征，在对象中用属性来表示</li>
<li>方法：事物的行为，在对象中用方法来表示</li>
</ol>
</li>
</ol>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ol>
<li>类抽象了对象的公共部分，它泛指某一大类(class)</li>
<li>对象特指某一个，通过类实例化一个具体的对象</li>
<li>面向对象的思维特点：<ol>
<li>抽取(抽象)对象共用的属性和行为组织(封装)成一个类(模板)</li>
<li>对类进行实例化，获取类的对象</li>
</ol>
</li>
</ol>
<h2 id="类constructor构造函数"><a href="#类constructor构造函数" class="headerlink" title="类constructor构造函数"></a>类constructor构造函数</h2><ol>
<li>constructor()方法是类的构造函数（默认方法），用于传递参数返回实例对象，通过new命令生成对象实例时，自动调用该方法。如果类里面没有定义构造函数，类内部会自动给我们创建一个constructor()</li>
</ol>
<h3 id="利用类创建对象"><a href="#利用类创建对象" class="headerlink" title="利用类创建对象"></a>利用类创建对象</h3><ol>
<li>通过class关键字创建类，类名我们还是习惯性定义首字母大写</li>
<li>类里面有个constructor函数，可以接受传递过来的参数，同时返回实例对象</li>
<li>constructor函数只要new生成实例时，就会自动调用这个函数，如果我们不写这个函数，类也会自动生成这个函数生成实例new不能省略</li>
<li>最后注意语法规范，创建类，类名后面不要加小括号，生成实例类名后面加小括号，构造函数不需要加function</li>
</ol>
<h3 id="类添加方法"><a href="#类添加方法" class="headerlink" title="类添加方法"></a>类添加方法</h3><ol>
<li><p>类里面的所有的函数都不需要写function</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  // 创建类</span><br><span class="line">  class Star &#123;</span><br><span class="line">    constructor(uname, age) &#123;</span><br><span class="line">      this.uname = uname;</span><br><span class="line">      this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sing(song) &#123;</span><br><span class="line">      console.log(this.uname + song);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 创建对象</span><br><span class="line">  var ldh = new Star(&quot;刘德华&quot;, 45);</span><br><span class="line">  var zxy = new Star(&quot;张学友&quot;, 50);</span><br><span class="line">  ldh.sing(&quot;冰雨&quot;);</span><br><span class="line">  zxy.sing(&quot;李香兰&quot;);</span><br><span class="line">  console.log(ldh);</span><br><span class="line">  console.log(ldh.uname);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="在类中调用函数"><a href="#在类中调用函数" class="headerlink" title="在类中调用函数"></a>在类中调用函数</h3><ol>
<li>在类中调用函数，调用函数时，若不需要函数在页面加载后马上调用，则利用this.函数名进行调用，<strong>在后面不要加上括号，否则函数会在页面加载后立即执行</strong><img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211008000651.png" alt="img"></li>
</ol>
<h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><ol>
<li>程序中的继承：子类可以继承父类的一些属性和方法</li>
</ol>
<h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><ol>
<li><p><strong>super关键字用于访问和调用对象父类上的函数</strong>。可以调用父类的构造函数，也可以调用父类的普通函数</p>
</li>
<li><p>super必须在子类this之前调用</p>
<p>（必须先调用父类的构造方法，再使用子类的构造方法）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  class Father &#123;</span><br><span class="line">    constructor(x, y) &#123;</span><br><span class="line">      this.x = x;</span><br><span class="line">      this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sum() &#123;</span><br><span class="line">      // 这里的参数必须是父类传过来的才能进行相加</span><br><span class="line">      console.log(this.x + this.y);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class Son extends Father &#123; // 继承父类</span><br><span class="line">    constructor(x, y) &#123;</span><br><span class="line">      // super必须在子类this之前调用</span><br><span class="line">      super(x, y); // 调用了父类中的构造函数和普通函数</span><br><span class="line">      // this.x = x;</span><br><span class="line">      // this.y = y;  // 这里的x和y指向子类</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    subtract() &#123;</span><br><span class="line">      console.log(this.x - this.y);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var son = new Son(11, 22);</span><br><span class="line">  son.sum(); // 33</span><br><span class="line">  son.subtract(); // -11</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>继承中，如果实例化子类输出一个方法，先看子类有没有这个方法，如果有就先执行子类的；如果子类里面没有，就去查找父类有没有这个方法，如果有，就执行父类的这个方法（就近原则）</p>
</li>
</ol>
<h2 id="使用类的三个注意点"><a href="#使用类的三个注意点" class="headerlink" title="使用类的三个注意点"></a>使用类的三个注意点</h2><ol>
<li><p>在ES6中类没有变量提升，所以必须先定义类，才能通过类实例化对象</p>
</li>
<li><p>类里面的共有的属性和方法一定要加this使用</p>
</li>
<li><p>类里面的this指向问题，见以下代码</p>
<ol>
<li><p><strong>constructor里面的this指向的是创建的实例对象，方法里面的this指向这个方法的调用者</strong></p>
</li>
<li><p>小技巧：当一个类的方法中需要使用指向实例对象的this，但是由于方法里面的this指向这个方法的调用者，因此可以定义一个全局变量that，将constructor里面指向实例对象的this赋值给that，这样方法就可以通过that使用指向实例对象的this，见下图白框内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;button&gt;按钮&lt;/button&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    var that;</span><br><span class="line">    class Star &#123;</span><br><span class="line">      constructor(uname, age) &#123;</span><br><span class="line">        // this指向的是创建的实例对象，将实例对象赋值给that</span><br><span class="line">        // 这样that指向的也是创建的实例对象</span><br><span class="line">        that = this;</span><br><span class="line">        // constructor里面的this指向的是创建的实例对象</span><br><span class="line">        this.uname = uname;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.btn = document.querySelector(&quot;button&quot;);</span><br><span class="line">        // 这里调用sing函数，在sing后面没有加括号</span><br><span class="line">        // 因为这个函数是在btn被点击后才调用，因此不加括号</span><br><span class="line">        // 若在sing后面加上括号，则表示页面一经加载，则函数立即调用</span><br><span class="line">        this.btn.onclick = this.sing;</span><br><span class="line">      &#125;</span><br><span class="line">      sing() &#123;</span><br><span class="line">        // 输出&lt;button&gt;按钮&lt;/button&gt;</span><br><span class="line">        // 方法里面的this指向这个方法的调用者，因为sing函数是被btn调用的，this指向btn</span><br><span class="line">        console.log(this);</span><br><span class="line"></span><br><span class="line">        // 输出undefined，因为btn没有uname属性</span><br><span class="line">        console.log(this.uname);</span><br><span class="line"></span><br><span class="line">        // that里面存储的是constructor里面的this</span><br><span class="line">        // 因此输出&quot;刘德华&quot;</span><br><span class="line">        console.log(that.uname);</span><br><span class="line">      &#125;</span><br><span class="line">      song() &#123;</span><br><span class="line">        console.log(this); // 输出ldh的实例对象 Star&#123;&#125;，因为song方法是实例对象ldh调用</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var ldh = new Star(&quot;刘德华&quot;, 47);</span><br><span class="line">    ldh.song();</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h1 id="类-1"><a href="#类-1" class="headerlink" title="类"></a>类</h1><ol>
<li>在ES6之前通过构造函数+原型实现面向对象编程</li>
<li>在ES6之后通过类实现面向对象编程</li>
</ol>
<h2 id="类的本质"><a href="#类的本质" class="headerlink" title="类的本质"></a>类的本质</h2><ol>
<li>类的本质还是一个函数，类就是构造函数的另外一种写法<ol>
<li>类具有prototype原型对象</li>
<li>类的prototype原型对象指向类本身constructor</li>
<li>类可以通过原型对象中添加方法</li>
<li>类的实例对象的原型__proto__指向类的原型对象</li>
</ol>
</li>
<li>类的所有方法都定义在类的prototype属性上</li>
<li>类创建的实例对象，里面也有__proto__指向类的prototype原型对象</li>
<li>所以ES6的类它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法</li>
<li>ES6的类就是语法糖<ol>
<li>语法糖：语法糖就是一种便捷写法；简单理解，有两种方法可以实现同样的功能，但是一种写法更加清晰、方便，那么这个方法就是语法糖</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6箭头函数</title>
    <url>/2022/08/01/ES6%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="ES6箭头函数"><a href="#ES6箭头函数" class="headerlink" title="ES6箭头函数"></a>ES6箭头函数</h1><ol>
<li><p>ES6中新增的定义函数的方式 — 箭头函数</p>
<ol>
<li><p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">() =&gt; &#123;&#125;</span><br><span class="line">const fn = () =&gt; &#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>若函数体中只有一句代码，则代码的执行结果就是返回值，可以省略大括号</p>
</li>
<li><p>一般在需要把一个函数作为另外一个函数的参数传递时，会使用到箭头函数</p>
</li>
<li><p>若形参只有一个，形参外侧的小括号可以省略</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  // 定义箭头函数，函数体内只有一句代码</span><br><span class="line">  const fn = (n1, n2) =&gt; n1 + n2;</span><br><span class="line">  console.log(fn(1, 3));</span><br><span class="line"></span><br><span class="line">  // 若形参只有一个，形参外侧的小括号可以省略</span><br><span class="line">  const f = v =&gt; alert(v);</span><br><span class="line">  f(20);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>箭头函数不绑定this关键字，箭头函数没有自己的this关键字；箭头函数中的this指向的是箭头函数定义位置的中this</p>
</li>
<li><p>箭头函数面试题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  var age = 100;</span><br><span class="line">  // obj对象无法产生作用域</span><br><span class="line">  const obj = &#123;</span><br><span class="line">    age: 30,</span><br><span class="line">    say: () =&gt; &#123;</span><br><span class="line">      // 因此这里的this指向本作用域中的age属性，即为window中的age属性</span><br><span class="line">      console.log(this.age); // 100</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  obj.say();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6解构赋值</title>
    <url>/2022/08/01/ES6%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</url>
    <content><![CDATA[<h1 id="ES6解构赋值"><a href="#ES6解构赋值" class="headerlink" title="ES6解构赋值"></a>ES6解构赋值</h1><ol>
<li>ES6中允许从数组中提取值，按照对应位置，对变量赋值，对象也可以实现解构</li>
</ol>
<h3 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h3><ol>
<li><p>数组解构允许按照一一对应的关系从数组中提取值，然后将值赋值给变量</p>
</li>
<li><p>如果解构不成功，变量的值为undefined</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  let arr = [1, &#x27;a&#x27;, 2];</span><br><span class="line">  // 按照一一对应的关系从数组中提取值，然后将值赋值给变量</span><br><span class="line">  let [a, b, c] = arr;</span><br><span class="line">  console.log(a); // 1</span><br><span class="line">  console.log(b); // a</span><br><span class="line">  console.log(c); // 2</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  let arr = [1, &#x27;a&#x27;, 2];</span><br><span class="line">  // 按照一一对应的关系从数组中提取值，然后将值赋值给变量</span><br><span class="line">  let [a, b] = arr;</span><br><span class="line">  console.log(a); // 1</span><br><span class="line">  console.log(b); // a</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  let arr = [1, &#x27;a&#x27;, 2];</span><br><span class="line">  // 按照一一对应的关系从数组中提取值，然后将值赋值给变量</span><br><span class="line">  let [a, b, c, d] = arr;</span><br><span class="line">  console.log(a); // 1</span><br><span class="line">  console.log(b); // a</span><br><span class="line">  console.log(c); // 2</span><br><span class="line">  console.log(d); //undefined</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h3><ol>
<li><p>对象解构必须根据属性名进行匹配</p>
</li>
<li><p>如果解构不成功，变量的值为undefined</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  let person = &#123;</span><br><span class="line">    name: &#x27;zhangsan&#x27;,</span><br><span class="line">    age: &#x27;不详&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">  // 对象解构</span><br><span class="line">  let &#123; name, age &#125; = person;</span><br><span class="line">  console.log(name); // zhangsan</span><br><span class="line">  console.log(age); // 不详</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  let person = &#123;</span><br><span class="line">    name: &#x27;zhangsan&#x27;,</span><br><span class="line">    age: &#x27;不详&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">  // 冒号左侧的变量只用于匹配，赋值给冒号右边的变量</span><br><span class="line">  let &#123; name: myname, age: myage &#125; = person;</span><br><span class="line">  // 当对象解构成功，属性匹配成功，则将属性对应的值赋值给冒号左侧的变量</span><br><span class="line">  console.log(myname); // zhangsan</span><br><span class="line">  console.log(myage); // 不详</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  let person = &#123;</span><br><span class="line">    name: &#x27;zhangsan&#x27;,</span><br><span class="line">    age: &#x27;不详&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">  // 必须利用属性名进行匹配</span><br><span class="line">  let &#123; n, a &#125; = person;</span><br><span class="line">  console.log(n); // undefined</span><br><span class="line">  console.log(a); // undefined</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>Git</title>
    <url>/2022/08/01/Git/</url>
    <content><![CDATA[<h1 id="Git介绍"><a href="#Git介绍" class="headerlink" title="Git介绍"></a>Git介绍</h1><ol>
<li>Git是目前世界上最先进的分布式版本控制系统</li>
</ol>
<h2 id="Git和Github区别"><a href="#Git和Github区别" class="headerlink" title="Git和Github区别"></a>Git和Github区别</h2><ol>
<li>Git是一个分布式版本管理系统，简单说就是一个软件，用于记录一个或若干个文件内容变化，以便将来查阅特定版本修订情况的软件，官方地址：<a href="https://git-scm.com/">https://git-scm.com/</a></li>
<li>Github： <a href="https://www.github.com/">https://www.github.com</a></li>
<li>Github是一个为用户提供Git服务的网站，用于存放代码的地方（但不仅限于代码），Github除了提供管理Git的web界面外，还提供了订阅、关注、讨论组、在线编辑器等丰富的功能。</li>
</ol>
<h1 id="Git的使用"><a href="#Git的使用" class="headerlink" title="Git的使用"></a>Git的使用</h1><h2 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a>本地仓库</h2><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ol>
<li>Git本地操作的三个区域：<ol>
<li>Git Repository（Git仓库）：最终确定的文件保存到仓库，成为一个新的版本，并对他人可见</li>
<li>暂存区：暂存已经修改的文件最后统一提交到Git仓库中</li>
<li>工作区：添加、编辑、修改文件等动作</li>
</ol>
</li>
<li>工作流程：工作区 -&gt; 暂存区 -&gt; Git仓库</li>
</ol>
<h2 id="本地仓库操作"><a href="#本地仓库操作" class="headerlink" title="本地仓库操作"></a>本地仓库操作</h2><ol>
<li>什么是仓库呢？仓库又名版本库，英文名repository，我们可以简单理解成是一个目录，用于存放代码的，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除等操作Git都能跟踪到</li>
</ol>
<h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><p>1.在安装好首次使用需要先进行全局配置（一般只需要做一次）</p>
<p>桌面空白处右键，点击“Git Bash Here”以打开命令执行窗口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;用户名&quot;</span><br><span class="line">git config --global user.email &quot;邮箱地址&quot;</span><br></pre></td></tr></table></figure>

<p>2.创建仓库</p>
<ol>
<li><p>当我们需要让Git去管理某个新项目&#x2F;已存在项目的时候，就需要创建仓库</p>
</li>
<li><p>注意：</p>
<ul>
<li>创建仓库时使用的目录不一定要求是空目录，选择一个非空目录也是可以的，但是不建议</li>
<li>为了避免在学习或使用过程中出现各种奇葩问题，请不要使用包含中文的目录名(父目录亦是如此)</li>
</ul>
</li>
<li><p>创建空目录</p>
<ul>
<li>方式一：鼠标右键，新建</li>
<li>方式二：mkdir 文件名</li>
</ul>
</li>
<li><p>进入空项目目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd 文件名</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回上一级</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ..</span><br></pre></td></tr></table></figure></li>
</ol>
<p>3.Git仓库初始化</p>
<ol>
<li>指令：<strong>git init</strong></li>
<li>表现：执行之后会在项目目录中创建“.git”的隐藏目录，再查看中修改显示查看隐藏文件，就可以看到.git文件<br><img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211008234144.png" alt="img"></li>
</ol>
<p>4.Git常用命令</p>
<table>
<thead>
<tr>
<th><strong>命令名称</strong></th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>git config –global user.name 用户名</td>
<td>设置用户名</td>
</tr>
<tr>
<td>git config –global user.email 邮箱</td>
<td>设置用户邮箱</td>
</tr>
<tr>
<td>git init</td>
<td>初始化本地库</td>
</tr>
<tr>
<td>git status</td>
<td>查看本地库状态</td>
</tr>
<tr>
<td>git add 文件名</td>
<td>添加到暂存区</td>
</tr>
<tr>
<td>git commit -m “日志信息” 文件名</td>
<td>提交到本地库</td>
</tr>
<tr>
<td>git reflog</td>
<td>查看历史记录</td>
</tr>
<tr>
<td>git reset –hard 版本号</td>
<td>版本穿梭</td>
</tr>
</tbody></table>
<p>5.Git常用命令操作</p>
<ol>
<li>查看的当前状态：<strong>git status</strong></li>
<li>添加到暂存区：<ul>
<li>添加一个文件：git add 文件名</li>
<li>添加多个文件：<ul>
<li>git add 后面跟多个文件名1 文件名2 文件名3..</li>
<li><strong>git add .</strong> — 添加当前目录到目前暂存区中</li>
</ul>
</li>
</ul>
</li>
<li>提交至版本库：<strong>git commit -m “注释内容”</strong>，这里的m为massage</li>
</ol>
<p>在后续对于文件（可以操作1个或多个）操作之后，重复使用git add与git commit指令即可</p>
<h3 id="回退到指定的版本"><a href="#回退到指定的版本" class="headerlink" title="回退到指定的版本"></a>回退到指定的版本</h3><p><img src="/2022/08/01/Git/image-16.png" alt="image-16"></p>
<h2 id="远程仓库操作"><a href="#远程仓库操作" class="headerlink" title="远程仓库操作"></a>远程仓库操作</h2><table>
<thead>
<tr>
<th>命令名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>git remote -v</td>
<td>查看当前所有远程地址别名</td>
</tr>
<tr>
<td>git remote add 别名 远程地址</td>
<td>起别名</td>
</tr>
<tr>
<td>git push 别名 分支</td>
<td>推送本地分支上的内容到远程仓库</td>
</tr>
<tr>
<td>git clone 远程地址</td>
<td>将远程仓库的内容克隆到本地</td>
</tr>
<tr>
<td>git pull 远程库地址别名 远程分支名</td>
<td>将远程仓库对于分支最新内容拉下来后与当前本地分支直接合并</td>
</tr>
</tbody></table>
<h3 id="创建远程仓库别名"><a href="#创建远程仓库别名" class="headerlink" title="创建远程仓库别名"></a>创建远程仓库别名</h3><ol>
<li><p>基本语法</p>
<p><strong>git</strong> <strong>remote -v</strong> 查看当前所有远程地址别名</p>
<p><strong>git</strong>  <strong>remote</strong>  <strong>add</strong>   别名  远程地址</p>
</li>
<li><p>案例</p>
</li>
</ol>
<p><img src="/2022/08/01/Git/image-17.png" alt="image-17"></p>
<h3 id="推送本地分支到远程仓库"><a href="#推送本地分支到远程仓库" class="headerlink" title="推送本地分支到远程仓库"></a>推送本地分支到远程仓库</h3><ol>
<li><p>基本语法</p>
<p><strong>git push</strong> 别名 分支</p>
</li>
<li><p>案例</p>
<p><img src="/2022/08/01/Git/image-18.png" alt="image-18"></p>
</li>
</ol>
<p><img src="/2022/08/01/Git/image-19.png" alt="image-19"></p>
<p>此时发现已将我们master 分支上的内容推送到GitHub 创建的远程仓库。</p>
<h3 id="克隆远程仓库到本地"><a href="#克隆远程仓库到本地" class="headerlink" title="克隆远程仓库到本地"></a>克隆远程仓库到本地</h3><p><strong>1）</strong> 基本语法</p>
<p><strong>git clone</strong>  远程地址</p>
<p><strong>2）</strong> 案例实操</p>
<p><img src="/2022/08/01/Git/image-20.png" alt="image-20"></p>
<p> 其中<a href="https://github.com/atguiguyueyue/git-shTest.git%E5%9C%B0%E5%9D%80%E6%98%AF%E8%87%AA%E5%B7%B1%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%9C%B0%E5%9D%80%EF%BC%8C%E5%85%8B%E9%9A%86%E7%BB%93%E6%9E%9C%EF%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93">https://github.com/atguiguyueyue/git-shTest.git地址是自己远程仓库地址，克隆结果：初始化本地仓库</a></p>
<p><img src="/2022/08/01/Git/image-21.png" alt="image-21">小结：clone 会做如下操作。1、拉取代码。2、初始化本地仓库。3、创建别名</p>
<h3 id="拉取远程库内容"><a href="#拉取远程库内容" class="headerlink" title="拉取远程库内容"></a>拉取远程库内容</h3><ol>
<li><p>基本语法</p>
<p><strong>git pull</strong> 远程库地址别名 远程分支名</p>
</li>
<li><p>案例</p>
<p><img src="/2022/08/01/Git/image-22.png" alt="image-22"></p>
</li>
</ol>
<h2 id="SSH免密登录（推荐）"><a href="#SSH免密登录（推荐）" class="headerlink" title="SSH免密登录（推荐）"></a>SSH免密登录（推荐）</h2><ol>
<li><p>实际操作</p>
<ol>
<li><p>打开Git Bash，创建公私钥对文件，输入指令：ssh-keygen-t rsa -<strong>C</strong> “邮箱地址”(其中<strong>c</strong>要大写)<br><img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211008235347.png" alt="img"></p>
</li>
<li><p>上传公钥文件内容（文件内容在id_rsa.pub文件内，不要直接打开文件，用记事本或代码编辑器打开，打开后复制内容，到github的添加公钥提示中填写公钥）</p>
<ul>
<li><p>id_rsa.pub文件位置一般位于：c盘 -&gt; 用户（users） -&gt; admin（Administrator） -&gt; .ssh -&gt; id_rsa.pub</p>
</li>
<li><p>在浏览器中登录Github，点击头像–&gt;Settings–&gt;SSH and GPG Keys–&gt;New SSH key</p>
</li>
<li><p>将id_rsa.pub 文件中内容，粘贴到Key对应的文本框中</p>
</li>
<li><p>在Title文本框中任意填写一个名称，来标识Key从何而来</p>
<p><img src="/2022/08/01/Git/image-23.png" alt="image-23"></p>
</li>
</ul>
<p>接下来再往远程仓库push 东西的时候使用 SSH 连接就不需要登录了。</p>
</li>
<li><p>执行后续git操作，与之前相同</p>
<ul>
<li>clone线上仓库到本地：git clone</li>
<li>进入线上仓库：git 线上仓库文件名</li>
<li>提交暂存区：git add 线上仓库文件名</li>
<li>提交本地仓库：git commit -m “文件描述”</li>
<li>提交线上仓库：git push</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="git工作流程"><a href="#git工作流程" class="headerlink" title="git工作流程"></a>git工作流程</h2><p><img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211124174005.png" alt="img"></p>
<h2 id="分支管理（重点）"><a href="#分支管理（重点）" class="headerlink" title="分支管理（重点）"></a>分支管理（重点）</h2><ol>
<li><p>什么是分支：相当于一个项目的每个模块</p>
</li>
<li><p>在版本回退的章节里，每次提交后都会有记录，Git把它们串成时间线，形成类似于时间轴的东西，这个时间轴就是一个分支， 我们称之为master分支</p>
</li>
<li><p>在开发的时候往往是团队协作，多人进行开发，因此光有一个分支是无法满足多人同时开发的需求的，并且在分支上工作并不影响其他分支的正常使用，会更加安全，Git鼓励开发者使用分支去完成一些开发任务</p>
</li>
<li><p>分支相关指令</p>
<ol>
<li><p>查看分支：</p>
<p>git branch</p>
<ul>
<li>“*”标记表示当前分支</li>
</ul>
</li>
<li><p>创建分支：<strong>git branch 分支名</strong><br><img src="/2022/08/01/Git/image-24.png" alt="image-24"></p>
</li>
<li><p>切换分支：<strong>git checkout 分支名</strong><br><img src="/2022/08/01/Git/image-25.png" alt="image-25"></p>
</li>
<li><p>创建一个新的分支并同时切换该分支：<strong>git checkout -b 分支名</strong>，-b中的b为branch</p>
</li>
<li><p>合并分支：</p>
<p>git merge 被合并的分支名</p>
<p>注意合并时，要先将分支切换（git checkout）到master再进行合并</p>
<p><img src="/2022/08/01/Git/image-26.png" alt="image-26"></p>
</li>
<li><p>删除分支：</p>
<p>git branch -d 分支名</p>
<ul>
<li>注意：删除分支的时候，一定要先退出删除的分支，然后才能删除</li>
</ul>
</li>
<li><p>提交分支：<strong>git push origin 分支名</strong></p>
</li>
<li><p>拉取分支：<strong>git pull origin 分支名</strong></p>
</li>
</ol>
</li>
<li><p>在本地进行分支操作结束后，需要将master分支提交到线上远程仓库：git push</p>
</li>
</ol>
<h2 id="冲突的产生与解决"><a href="#冲突的产生与解决" class="headerlink" title="冲突的产生与解决"></a>冲突的产生与解决</h2><ol>
<li><p>如果在两个不同的分支中，对同一个文件进行了不同的修改，Git就无法干净的合并，这时需要我们打开包含冲突的文件进行手动解决冲突</p>
<p><img src="/2022/08/01/Git/image-27.png" alt="image-27"></p>
</li>
<li><p>解决方法</p>
<p>1.手动解决冲突，通过vscode打开冲突文件，根据需求通过vscode给的四种选择方式进行选择保留</p>
<p><img src="/2022/08/01/Git/image-28.png" alt="image-28"></p>
<p>2.通过以下代码告诉Git解决了分支合并冲突</p>
<p><img src="/2022/08/01/Git/image-29.png" alt="image-29"></p>
</li>
</ol>
<h2 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h2><ol>
<li><p>场景：在项目目录下有很多万年不变的文件目录，例如CSS、js、images等，或者还有一些目录即便有改动，我们也不想让它提交到远程仓库的文档，此时我们可以使用”忽略文件“机制来空现需求</p>
</li>
<li><p>忽略文件需要新建一个名为.gitignore的文件，该文件用于声明忽略文件或不忽略文件的规则，规则对当前目录及其子目录生效</p>
<ol>
<li>新建.gitignore文件方法<ul>
<li>指令法：touch .gitignore</li>
</ul>
</li>
<li>直接鼠标右击创建（windows10版本支持）</li>
</ol>
</li>
<li><p>注意：该文件因为没有文件名，windows10以前的版本没办法直接在windows目录下直接创建，可以通过命令行Git Bash来touch创建</p>
</li>
<li><p>对.gitignore文件进行编写，常见规则写法如下</p>
<table>
<thead>
<tr>
<th>&#x2F;文件名&#x2F;</th>
<th>过滤整个文件</th>
</tr>
</thead>
<tbody><tr>
<td>*.zip</td>
<td>过滤所有.zip文件</td>
</tr>
<tr>
<td>index.html</td>
<td>过滤具体某个文件</td>
</tr>
<tr>
<td>!index.php</td>
<td>不过滤具体某个文件</td>
</tr>
</tbody></table>
<ol>
<li>编写规则：”#”为注释</li>
</ol>
</li>
<li><p>规则编写完毕后，正常操作，然后push即可，对应文件会被过滤掉，不会被上传</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML</title>
    <url>/2022/08/01/HTML/</url>
    <content><![CDATA[<h1 id="HTML简介"><a href="#HTML简介" class="headerlink" title="HTML简介"></a>HTML简介</h1><h2 id="HTML编写要求"><a href="#HTML编写要求" class="headerlink" title="HTML编写要求"></a>HTML编写要求</h2><ol>
<li><p>什么是html</p>
<ol>
<li>HyperText Markup Language：超文本标记语言，网页语言<ul>
<li>超文本：超出文本的范畴，使用html可以轻松实现这样的操作</li>
<li>标记：html所有的操作都是通过标记实现的，标记就是一个标签&lt;标签语言&gt;</li>
<li>网页语言</li>
</ul>
</li>
<li>一个HTML程序<ul>
<li>创建Java文件.java<br>先编译，后运行(JVM虚拟机)</li>
<li>HTML后缀是.html或.htm<br>直接通过浏览器就可以运行</li>
</ul>
</li>
</ol>
</li>
<li><p>html的规范</p>
<ol>
<li><p>一个html文件开始标签和结束标签:</p>
</li>
<li><p>html包含两部分内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;head&gt; 设置相关信息 &lt;/head&gt;</span><br><span class="line">&lt;boby&gt; 显示在页面上的内容都写在boby里面 &lt;/boby&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>html的标签有开始标签，也要有结束标签</p>
<ul>
<li>例：<code>&lt;head&gt;&lt;/head&gt;</code></li>
</ul>
</li>
<li><p>html的代码不区分大小写</p>
</li>
<li><p>有些标签，没有结束标签，在标签内结束</p>
<ul>
<li>比如：换行 <code>&lt;/br&gt; &lt;/hr&gt;</code></li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="文档类型声明标签"><a href="#文档类型声明标签" class="headerlink" title="文档类型声明标签"></a>文档类型声明标签</h2><ol>
<li><p>文档类型声明标签</p>
<ol>
<li><p><code>&lt;!DOCTYPE&gt;</code></p>
<p><code>&lt;!DOCTYPE html&gt;</code></p>
<ul>
<li>这句话的代码意思是：当前也页面采取的是HTML5版本来显示网页</li>
</ul>
</li>
<li><p>注意：</p>
<ul>
<li><code>&lt;!DOCTYPE&gt;</code>声明位于文档中的最前面的位置，处于<code>&lt;html&gt;</code>标签之前</li>
<li><code>&lt;!DOCTYPE&gt;</code>不是一个HTML标签，它就是文档类型声明标签</li>
</ul>
</li>
</ol>
</li>
<li><p>lang语言种类</p>
<ol>
<li>en定义语言为英语</li>
<li>Zh-CN定义语言为中文</li>
<li>简单来说定义为en就是英文网页；</li>
<li>定义为zh-CM就是中文网页，其实对于文档显示来说，定义成en的文档也可以显示中文，定义成zh-CN的文档也可以显示英文</li>
<li>这个属性对浏览器和搜索引擎还是有作用的</li>
</ol>
</li>
<li><p>字符集</p>
<ol>
<li><code>&lt;meta charset=&quot;UTF-8&quot;/&gt;</code></li>
<li>UTF-8被称为万国码</li>
</ol>
</li>
<li><p>HTML操作思想（重点）</p>
<ol>
<li>网页中有很多数据，不同的数据可能需要不同的显示效果，这个时候就需要使用标签把操作的数据包起来（封装起来），通过修改标签的属性值实现标签内数据样式的变化</li>
<li>一个标签相当于一个容器，想要修改容器内数据的样式，只需要改变容器的属性值，就可以实现容器内数据样式的变化</li>
</ol>
</li>
</ol>
<h1 id="HTML中常用的标签"><a href="#HTML中常用的标签" class="headerlink" title="HTML中常用的标签"></a>HTML中常用的标签</h1><h2 id="段落和换行标签"><a href="#段落和换行标签" class="headerlink" title="段落和换行标签"></a>段落和换行标签</h2><ol>
<li>段落标签：可以把HTML文档分割为若干段落<br><code>&lt;p&gt; 文本内容 &lt;/p&gt;</code></li>
<li>换行标签：强制换行<br><code>&lt;br/&gt;</code></li>
</ol>
<h2 id="文本格式化标签"><a href="#文本格式化标签" class="headerlink" title="文本格式化标签"></a>文本格式化标签</h2><p>1.标签语义：突出重要性</p>
<table>
<thead>
<tr>
<th>语义</th>
<th>标签</th>
</tr>
</thead>
<tbody><tr>
<td>字体加粗</td>
<td><code>&lt;strong&gt;&lt;/strong&gt;</code></td>
</tr>
<tr>
<td>字体倾斜</td>
<td><code>&lt;em&gt;&lt;/em&gt;</code></td>
</tr>
<tr>
<td>字体删除线</td>
<td><code>&lt;del&gt;&lt;/del&gt;</code></td>
</tr>
<tr>
<td>字体下划线</td>
<td><code>&lt;ins&gt;&lt;/ins&gt;</code></td>
</tr>
</tbody></table>
<p>2.<div>和<span>标签</span></div></p>
<ol>
<li>div：表示分割，分区，占一行（相当于一个大盒子）</li>
<li>span：跨度，跨距（相当于一个小盒子）</li>
</ol>
<h2 id="文字标签和注释标签"><a href="#文字标签和注释标签" class="headerlink" title="文字标签和注释标签"></a>文字标签和注释标签</h2><ol>
<li>文字标签：修改文字的样式<ol>
<li><code>&lt;font&gt;&lt;/font&gt;</code></li>
<li>属性:<ul>
<li>size：文字的大写 取值范围：1-7</li>
<li>color：文字颜色<ul>
<li>有两种表示方式</li>
<li>英文单词：red green blue black white yellow gray..</li>
<li>使用十六进制数表示，通过工具实现不同的颜色</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li>注释标签<ol>
<li>java注释有三种</li>
<li>html的注释：<code>&lt;!--html注释内容--&gt;</code></li>
</ol>
</li>
</ol>
<h2 id="标题标签、水平线标签和特殊字符"><a href="#标题标签、水平线标签和特殊字符" class="headerlink" title="标题标签、水平线标签和特殊字符"></a>标题标签、水平线标签和特殊字符</h2><ol>
<li><p>标题标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;h1&gt;&lt;/h1&gt; &lt;h2&gt;&lt;/h2&gt; &lt;h3&gt;&lt;/h3&gt; .. &lt;h6&gt;&lt;/h6&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>从h1到h6，标题依次变小，同时会自动换行</li>
</ol>
</li>
<li><p>水平线标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;hr/&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>属性<ul>
<li>size：水平线的粗细，取值范围1-7</li>
<li>color：颜色</li>
</ul>
</li>
<li>代码</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;hr size=&quot;4&quot; color=&quot;blue&quot;/&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>特殊字符</p>
<ol>
<li><p>想要在页面上显示这样的内容<code>&lt;html&gt;</code>:是网页的开始！</p>
</li>
<li><p>需要对特殊字符进行转义</p>
<table>
<thead>
<tr>
<th>特殊字符</th>
<th>转义</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;</td>
<td>&amp;lt；</td>
</tr>
<tr>
<td>&gt;</td>
<td>&amp;gt；</td>
</tr>
<tr>
<td>空格</td>
<td>&amp;nbsp；</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ol>
<h2 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h2><ol>
<li><p>自定义标签（重点）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dl&gt;&lt;/dl&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>在dl里面 <code>&lt;dt&gt; &lt;/dt&gt;</code>：上层内容</li>
<li>在dl里面 <code>&lt;dd&gt; &lt;/dd&gt;</code>：下层内容</li>
<li><code>&lt;dl&gt;&lt;/dl&gt;</code>里面只能包含<code>&lt;dt&gt;</code>和<code>&lt;dd&gt;</code></li>
<li><code>&lt;dt&gt;</code>和<code>&lt;dd&gt;</code>个数没有限制，经常是一个<code>&lt;dt&gt;</code>对应多个<code>&lt;dd&gt;</code></li>
</ol>
</li>
<li><p>有序列表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ol&gt; &lt;/ol&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>属性 type：设置排序方式（1（默认），a，i）</p>
</li>
<li><p>在ol标签里面<code>&lt;li&gt;具体内容&lt;/li&gt;</code></p>
</li>
<li><p>无序列表(重点)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt; &lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>无序列表的各个列表项之间没有顺序级别之分，是并列的</li>
<li><code>&lt;ul&gt;&lt;/ul&gt;</code>中只能嵌套<code>&lt;li&gt;&lt;/li&gt;</code>，直接在<code>&lt;ul&gt;&lt;/ul&gt;</code>标签中输入其他标签或者文字的做法是不被允许的</li>
<li><code>&lt;li&gt;</code>与<code>&lt;/li&gt;</code>之间相当于一个容器，可以容纳所有元素</li>
<li>无序列表会带有自己的样式属性，但在实际使用时，我们会使用CSS来设置</li>
<li>属性 type：实心圆disc(默认) 空心圆circle 实心方块square</li>
<li>在ul里面<code>&lt;li&gt;</code>具体内容<code>&lt;/li&gt;</code></li>
<li>去掉无序列表的项目符号：list-style: none;</li>
</ol>
</li>
</ol>
<h2 id="图像标签（重点）"><a href="#图像标签（重点）" class="headerlink" title="图像标签（重点）"></a>图像标签（重点）</h2><ol>
<li><p>图像标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;图片路径&quot; width=&quot;宽度&quot; height=&quot;高度&quot;/&gt;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>src</th>
<th>类型</th>
<th>图片的路径</th>
</tr>
</thead>
<tbody><tr>
<td>alt</td>
<td>文本</td>
<td>替换文本，图像无法显示时用文字替换</td>
</tr>
<tr>
<td>title</td>
<td>文本</td>
<td>提示文本，鼠标放到图像之上后 ，显示的文件</td>
</tr>
<tr>
<td>border</td>
<td>像素</td>
<td>设置图像的边框粗细</td>
</tr>
<tr>
<td>width</td>
<td>像素</td>
<td>图片的宽度</td>
</tr>
<tr>
<td>height</td>
<td>像素</td>
<td>图片的高度</td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="路径的介绍（重点）"><a href="#路径的介绍（重点）" class="headerlink" title="路径的介绍（重点）"></a>路径的介绍（重点）</h2><ol>
<li>路径分为：绝对路径和相对路径<ol>
<li>绝对路径：盘符地址或网页地址</li>
<li>相对路径：一个文件相对于另外一个文件的位置</li>
</ol>
</li>
</ol>
<h2 id="超链接标签（重点）"><a href="#超链接标签（重点）" class="headerlink" title="超链接标签（重点）"></a>超链接标签（重点）</h2><ol>
<li><p>链接资源</p>
<ol>
<li><code>&lt;a href=&quot;链接到的资源路径&quot; target=&quot;打开方式&quot;&gt; 显示在页面中的内容&lt;/a&gt;</code></li>
</ol>
<ul>
<li>href：链接的资源的地址  </li>
<li>target：设置打开的方式，默认是在当前页打开<ul>
<li>_blank：在一个新窗口打开</li>
<li>_self：在当前页打开<br><code>&lt;a href=&quot;HelloWorld.html&quot; target=&quot;_blank&quot;&gt;这是一个超链接&lt;/a&gt;</code></li>
</ul>
</li>
</ul>
</li>
<li><p>当超链接标签href中不加任何内容，则打开文件所在文件夹路径</p>
</li>
<li><p>当超链接不需要到任何的地址，在href里加#</p>
</li>
<li><p>链接分类</p>
<ol>
<li>外部链接</li>
<li>内部链接：网站页面之间的相互连接，直接链接内部页面名称即可</li>
<li>空链接：如果当时没有确定链接目标时，<code>&lt;a href=&quot;#&quot;&gt;首页&lt;/a&gt;</code></li>
<li>下载链接：如果href里面地址是一个文件或者压缩包，就会下载这个文件</li>
<li>网页元素链接：网页中的 各种网页元素，如文本，表格，音频，视频等都可以添加超链接</li>
<li>锚点链接（重点）：点击锚点链接时，可以快速定位到页面中某个位置</li>
</ol>
<ul>
<li>在链接文本的href属性中，设置属性值为#名字的形式，如<code>&lt;a href=&quot;#two&quot;&gt;第2集&lt;/a&gt;</code></li>
<li>找到目标位置标签，在其中添加id属性 &#x3D; 名字，如：<code>&lt;h3 id=&quot;two&quot;&gt;第2集介绍&lt;/h3&gt;</code></li>
</ul>
</li>
<li><p>定位资源</p>
<ol>
<li>定位资源：定义一个位置<br><code>&lt;a name=&quot;top&quot;&gt; 顶部 &lt;/a&gt;</code></li>
<li>回到这个位置<br><code>&lt;a name=&quot;#top&quot;&gt; 顶部 &lt;/a&gt;</code></li>
<li>引入一个标签<br><code>&lt;pre&gt; &lt;/pre&gt;</code>：原样输出</li>
</ol>
</li>
</ol>
<h2 id="表格标签（重点）"><a href="#表格标签（重点）" class="headerlink" title="表格标签（重点）"></a>表格标签（重点）</h2><ol>
<li><p>可以对数据进行格式化，使数据显示的更清晰</p>
</li>
<li><p>表格的写法</p>
<ol>
<li><p>首先定义一个表格的范围使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;table&gt;&lt;/table&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>定义一行使用一个<code>&lt;tr&gt;&lt;/tr&gt;</code></li>
<li>定义一个单元格使用一个<code>&lt;td&gt;&lt;/td&gt;</code></li>
</ul>
</li>
</ol>
</li>
<li><p><code>&lt;table&gt;&lt;/table&gt;</code></p>
<ol>
<li>例：<code>&lt;table border=&quot;1&quot; bordercolor=&quot;black&quot; cellspacing=&quot;0&quot; width=&quot;500&quot; height=&quot;300&quot;&gt;</code></li>
</ol>
</li>
<li><p>表格标签属性</p>
<ol>
<li>align：表格在页面中的位置，属性值(left center right)</li>
<li>border：表格线</li>
<li>bordercolor：表格线的颜色</li>
<li>cellpadding:单元格与其内容之间的距离</li>
<li>cellspacing：单元格之间的距离</li>
<li>width：表格的宽度</li>
<li>height：表格的高度</li>
</ol>
</li>
<li><p>在table里面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;tr&gt;&lt;/tr&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>设置对齐方式：align(left center right)</li>
<li>在tr里面<code>&lt;td&gt;&lt;/td&gt;</code><br>设置显示方式：align(left center right)</li>
<li>使用<code>&lt;th&gt;&lt;/th&gt;</code>也可以表示单元格：表示实现居中和加粗</li>
</ol>
</li>
<li><p>表格结构标签</p>
<ol>
<li><code>&lt;thead&gt;&lt;/thead&gt;</code>：用于定义表格的头部，存放表头</li>
<li><code>&lt;tbody&gt;&lt;/tbody&gt;</code>：用于定义表格的主题，存放主体</li>
</ol>
</li>
<li><p>表格的标题<br><code>&lt;caption&gt;&lt;/caption&gt;</code></p>
</li>
<li><p>合并单元格</p>
<ol>
<li>跨行：rowspan<ul>
<li>删除多余单元格</li>
<li>将需要合并的那一行的其他不需要的信息全部删掉<br><code>&lt;tr&gt;&lt;th rowspan=&quot;3&quot;&gt;人员信息&lt;/th&gt;&lt;/tr&gt;</code></li>
</ul>
</li>
<li>跨列：colspan<ul>
<li>删除多余单元格</li>
<li>将需要合并的那一 列的其他不需要的信息全部删掉<br><code>&lt;th colspan=&quot;3&quot;&gt;人员信息&lt;/th&gt;</code></li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="表单标签（重点）"><a href="#表单标签（重点）" class="headerlink" title="表单标签（重点）"></a>表单标签（重点）</h2><ol>
<li><p><code>&lt;form&gt;&lt;/form&gt;</code></p>
<ol>
<li>属性：<ul>
<li>action：提交到地址，默认提交到当前的页面<ul>
<li>method：表单的提交方式<ul>
<li>常用的有两种 get和post，默认是get请求</li>
</ul>
</li>
<li>enctype：一般请求下不需要，做文件上传时需要设置这个属性</li>
</ul>
</li>
</ul>
</li>
<li>面试题：get和post的区别<ul>
<li>get请求地址栏会携带提交的数据，post不会携带（在请求体里面，http协议时讲）</li>
<li>get请求安全级别较低，post较高</li>
<li>get请求数据大小有限制，post没有限制</li>
</ul>
</li>
<li>输入项：可以输入内容或者选择内容的部分</li>
<li>大部分的输入项使用<code>&lt;input type=&quot;输入项的类型&quot;/&gt;</code></li>
<li>在输入项里面必需要有一个name属性(name属性：当前input表单的名字，后台可以通过name属性找到这个表单，name的主要作用就是用来区别于不同的表单)</li>
</ol>
</li>
<li><p>input输入表单元素</p>
<ol>
<li><p>普通输入项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot;/&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>maxlength：规定输入字段中的最大长度</li>
</ul>
</li>
<li><p>密码输入项：<code>&lt;input type=&quot;password&quot;/&gt;</code></p>
</li>
<li><p>单选输入项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;radio&quot;/&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>在里面需要属性name</li>
<li>若需要两个单选输入项互斥，将两者的name属性值设置相同即可</li>
<li>name的属性值必须要相同</li>
<li>必须有一个value值</li>
<li>实现要默认选中的属性：<code>checked=&quot;checked&quot;</code></li>
</ul>
</li>
<li><p>复选输入项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;checkbox&quot;/&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>在里面需要属性name</li>
<li>name的属性值必须要相同</li>
<li>必须有一个value值</li>
<li>实现默认选中的属性：<code>checked=&quot;checked&quot;</code></li>
</ul>
</li>
<li><p>文件输入项(在后面上传时候用到)：<code>&lt;input type=&quot;file&quot;/&gt;</code></p>
</li>
<li><p>隐藏项（不会显示在页面上，但是存在于html代码里面）<br><code>&lt;input type=&quot;hidden&quot;/&gt;</code></p>
</li>
<li><p>提交按钮<br><code>&lt;input type=&quot;submit&quot;/&gt;</code><br><code>&lt;input type=&quot;submit&quot; value=&quot;注册&quot;/&gt;</code></p>
</li>
<li><p>使用图片提交<br><code>&lt;input type=&quot;image&quot; src=&quot;图片路径&quot;/&gt;</code></p>
</li>
<li><p>重置按钮：回到输入项的初始状态<br><code>&lt;input type=&quot;reset&quot;/&gt;</code></p>
</li>
<li><p>普通按钮（和js一起使用）<br><code>&lt;input type=&quot;button&quot; value=&quot;&quot;/&gt;</code></p>
</li>
</ol>
</li>
<li><p>select下拉表单元素</p>
<ol>
<li><p>下拉输入项(不是在input标签里面的)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;select name=&quot;birth&quot;&gt;  </span><br><span class="line">  &lt;option value=&quot;1991&quot;&gt;1991&lt;/option&gt;  </span><br><span class="line">  &lt;option value=&quot;1992&quot;&gt;1992&lt;/option&gt;  </span><br><span class="line">  &lt;option value=&quot;1993&quot;&gt;1993&lt;/option&gt;  </span><br><span class="line">&lt;/select&gt;  </span><br></pre></td></tr></table></figure>

<ul>
<li>实现默认选中的属性<br><code>selected=&quot;selected&quot;</code></li>
</ul>
</li>
</ol>
</li>
<li><p>方法：select() — 让文本框内的文字处于选定状态</p>
<ol>
<li>语法：<code>input.select();</code></li>
</ol>
</li>
<li><p>textarea文本域元素</p>
<ol>
<li>文本域<br><code>&lt;textarea clos=&quot;20&quot; rows=&quot;10&quot;&gt;..&lt;/textarea&gt;</code></li>
</ol>
</li>
<li><p>案例：使用表单标签实现注册页面案例：见IDEA</p>
<ol>
<li>使用表格实现页面效果</li>
<li>超链接实现页面效果</li>
<li>超链接不想要无操作的效果：<code>href=&quot;#&quot;</code></li>
<li>如果表格里面的单元格没有内容，使用空格作为占位符<code>$nbsp;</code></li>
<li>使用图片提交表单<code>&lt;input type=&quot;image&quot; src=&quot;图片的路径&quot;？&gt;</code></li>
</ol>
</li>
</ol>
<h2 id="label标签"><a href="#label标签" class="headerlink" title="label标签"></a>label标签</h2><ol>
<li><p><code>&lt;label&gt;</code>：标签为input元素定义标注（标签）</p>
</li>
<li><p><code>&lt;label&gt;</code>的作用：增加用户体验，当点击<code>&lt;label&gt;</code>标签中的文字等任意内容，就会选中该表单控件所关联的按钮或表单</p>
<ol>
<li>注意：需要让表单中的id值等于label标签中的for值</li>
</ol>
</li>
<li><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;label for = &quot;sex&quot;&gt;男&lt;/label&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type = &quot;radio&quot; name = &quot;sex&quot; id = &quot;sex&quot;/&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>核心：<code>&lt;label&gt;</code>标签的for属性应当与相关元素的id属性相同</li>
</ul>
</li>
</ol>
<h2 id="HTML中的其他常用标签的使用"><a href="#HTML中的其他常用标签的使用" class="headerlink" title="HTML中的其他常用标签的使用"></a>HTML中的其他常用标签的使用</h2><ol>
<li><code>&lt;b&gt;</code>：加粗</li>
<li><code>&lt;u&gt;</code>：下划线</li>
<li><code>&lt;s&gt;</code>：删除线s</li>
<li><code>&lt;i&gt;</code>：斜体</li>
<li><code>&lt;pre&gt;</code>：原样输出</li>
<li><code>&lt;sub&gt;</code>：下标</li>
<li><code>&lt;sup&gt;</code>：上标</li>
<li><code>&lt;p&gt;</code>：段落标签，换行，比<code>&lt;br/&gt;</code>多一行</li>
<li><code>&lt;div&gt;</code>：自动换行</li>
<li><code>&lt;span&gt;</code>：在一行显示</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>查阅文档：经常查阅文档是一个非常好的学习习惯。<br>常用的查阅文档网址： </p>
<ul>
<li>百度:  <a href="http://www.baidu.com/">http://www.baidu.com</a></li>
<li>W3C:  <a href="http://www.w3school.com.cn/">http://www.w3school.com.cn/</a></li>
<li>MDN:  <a href="https://developer.mozilla.org/zh-CN/">https://developer.mozilla.org/zh-CN/</a></li>
</ul>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript内置对象和数据类型</title>
    <url>/2022/08/01/JavaScript%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h1><ol>
<li>JavaScript中对象分为三种：自定义对象，内置对象，浏览器对象</li>
<li>内置对象就是指JS语言自带的一些对象，这些对象供开发者使用，并提供了一些常用的或是最基本而必要的功能(属性和方法)</li>
</ol>
<h2 id="查文档"><a href="#查文档" class="headerlink" title="查文档"></a>查文档</h2><ol>
<li>学习一个内置对象的使用，只要学会其常用成员的使用即可，可以通过查文档学习，可以通过MDN&#x2F;W3C来查询</li>
<li>MDN网址： <a href="https://developer.mozilla.org/zh-CN/">https://developer.mozilla.org/zh-CN/</a></li>
</ol>
<h2 id="Math数学对象"><a href="#Math数学对象" class="headerlink" title="Math数学对象"></a>Math数学对象</h2><ol>
<li><p>Math对象不是构造函数，它具有数学常数和函数的属性和方法；跟数学相关的运算(求绝对值，取整、最大值等)可以使用Math中的成员</p>
</li>
<li><p>Math对象部分属性和方法</p>
<table>
<thead>
<tr>
<th>属性或方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>math.PI</td>
<td>圆周率</td>
</tr>
<tr>
<td>math.floor()</td>
<td>向下取整</td>
</tr>
<tr>
<td>math.ceil()</td>
<td>向上取整</td>
</tr>
<tr>
<td>math.round()</td>
<td>四舍五入版，就近取整（负数中.5特殊，往大取；如-1.5四舍五入得-1）</td>
</tr>
<tr>
<td>math.abs()</td>
<td>绝对值</td>
</tr>
<tr>
<td>math.max()</td>
<td>最大值</td>
</tr>
<tr>
<td>math.min()</td>
<td>最小值</td>
</tr>
</tbody></table>
</li>
<li><p>math对象随机数方法</p>
<ul>
<li>math.random();</li>
</ul>
<ol>
<li>返回一个随机的小数，范围[0, 1)</li>
<li>这个方法内不跟参数</li>
<li>想要得到两个数之间的随机整数并且包含这2个整数<ul>
<li>return Math.floor(Math.random() * (max - min + 1)) + min;</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="Date日期对象"><a href="#Date日期对象" class="headerlink" title="Date日期对象"></a>Date日期对象</h2><ol>
<li><p>Date日期对象：是一个构造函数，必须使用new来创建日期对象（实例化）</p>
</li>
<li><p>Date实例用来处理日期和时间</p>
</li>
<li><p>使用Date对象</p>
<ol>
<li><p>没有参数：返回当前系统的当前时间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var date = new Date();</span><br></pre></td></tr></table></figure>
</li>
<li><p>有参数：返回参数的时间；日期格式字符串为’2019-5-1’，可以写成new Date(‘2019-5-1’)或new Date(‘2019&#x2F;5&#x2F;1’)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var date = new Date(&#x27;2019-5-1&#x27;);</span><br><span class="line">var date = new Date(&#x27;2019/5/1&#x27;);</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="日期格式化"><a href="#日期格式化" class="headerlink" title="日期格式化"></a>日期格式化</h3><ol>
<li><p>获取日期指定的部分，手动得到需要的格式</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>getFullYear()</td>
<td>获取当年</td>
</tr>
<tr>
<td>getMonth()</td>
<td>获取当月（0~11）</td>
</tr>
<tr>
<td>getDate()</td>
<td>获取当天日期</td>
</tr>
<tr>
<td>getDay()</td>
<td>获取星期几（周日0 到 周六6）</td>
</tr>
<tr>
<td>getHours()</td>
<td>获取当前小时</td>
</tr>
<tr>
<td>getMinutes()</td>
<td>获取当前分钟</td>
</tr>
<tr>
<td>getSeconds()</td>
<td>获取当前秒钟</td>
</tr>
</tbody></table>
</li>
<li><p>案例：格式化日期年月日星期</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  // 创建日期对象</span><br><span class="line">  var date = new Date();</span><br><span class="line"></span><br><span class="line">  var year = date.getFullYear();</span><br><span class="line">  var month = date.getMonth();</span><br><span class="line">  var dates = date.getDate();</span><br><span class="line">  var day = date.getDay();</span><br><span class="line">  var arr = [&#x27;星期日&#x27;, &#x27;星期一&#x27;, &#x27;星期二&#x27;, &#x27;星期三&#x27;, &#x27;星期四&#x27;, &#x27;星期五&#x27;, &#x27;星期六&#x27;];</span><br><span class="line"></span><br><span class="line">  console.log(&#x27;现在的时间是：&#x27; + year + &#x27;年&#x27; + (month + 1) + &#x27;月&#x27; + dates + &#x27;日&#x27; + &#x27; &#x27; + arr[day]);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="获取总的毫秒数"><a href="#获取总的毫秒数" class="headerlink" title="获取总的毫秒数"></a>获取总的毫秒数</h3><ol>
<li><p>Date对象是基于1970年1月1日（世界标准时间）起的毫秒数（时间戳）</p>
</li>
<li><p>通过value Of()和getTime()两个函数都可以得到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var date = new Date();</span><br><span class="line">console.log(date.valueOf()); // 就是现在时间距离1970年1月1日总的毫秒数</span><br><span class="line">console.log(date.getTime()); // 就是现在时间距离1970年1月1日总的毫秒数</span><br></pre></td></tr></table></figure>
</li>
<li><p>简单写法（常用）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var date = +new Date(); // +new Date() 返回的就是总的毫秒数</span><br></pre></td></tr></table></figure>
</li>
<li><p>H5新增获取总毫秒数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(Date.new());</span><br></pre></td></tr></table></figure>
</li>
<li><p>将总毫秒数转换为天、时、分、秒（时间戳转换为时分秒）</p>
<ol>
<li><p>转换公式如下：</p>
<ul>
<li>计算天数：parseInt(总秒数&#x2F;60&#x2F;60&#x2F;24);</li>
<li>计算小时：parseInt(总秒数&#x2F;60&#x2F;60%24);</li>
<li>计算分钟：parseInt(总秒数&#x2F;60%60);</li>
<li>计算秒数：parseInt(总秒数%60);</li>
</ul>
</li>
<li><p>案例：倒计时</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  function countTime(time) &#123;</span><br><span class="line">    // 到当前时间的总毫秒数</span><br><span class="line">    var nowTime = +new Date();</span><br><span class="line">    // 距离用户设置时间time的总毫秒数</span><br><span class="line">    var inputTime = +new Date(time);</span><br><span class="line">    // 现在距离设置时间所剩余的秒数</span><br><span class="line">    var times = (inputTime - nowTime) / 1000;</span><br><span class="line"></span><br><span class="line">    // 天</span><br><span class="line">    var day = parseInt(times / 60 / 60 / 24);</span><br><span class="line">    day = day &lt; 10 ? &#x27;0&#x27; + day : day;</span><br><span class="line">    // 时</span><br><span class="line">    var hour = parseInt(times / 60 / 60 % 24);</span><br><span class="line">    hour = hour &lt; 10 ? &#x27;0&#x27; + hour : hour;</span><br><span class="line">    // 分</span><br><span class="line">    var minute = parseInt(times / 60 % 60);</span><br><span class="line">    minute = minute &lt; 10 ? &#x27;0&#x27; + minute : minute;</span><br><span class="line">    // 秒</span><br><span class="line">    var second = parseInt(times % 60);</span><br><span class="line">    second = second &lt; 10 ? &#x27;0&#x27; + second : second;</span><br><span class="line"></span><br><span class="line">    return day + &#x27;天&#x27; + hour + &#x27;时&#x27; + minute + &#x27;分&#x27; + second + &#x27;秒&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(countTime(&#x27;2021-7-22 18:00:00&#x27;));</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="数组对象"><a href="#数组对象" class="headerlink" title="数组对象"></a>数组对象</h2><h3 id="检测是否为数组"><a href="#检测是否为数组" class="headerlink" title="检测是否为数组"></a>检测是否为数组</h3><ol>
<li><p>方式一：instanceof — 运算符，用来检测是否为数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [];</span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line">console.log(arr instanceof Array); // true</span><br><span class="line">console.log(obj instanceof Array); // false</span><br></pre></td></tr></table></figure>
</li>
<li><p>方式二：Array.isArray(参数); — H5新增的方法，ie9以上版本支持</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(Array.isArray(arr)); // true</span><br><span class="line">console.log(Array.isArray(obj)); // false</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="添加数组元素"><a href="#添加数组元素" class="headerlink" title="添加数组元素"></a>添加数组元素</h3><ol>
<li><p>push(参数1..)：在数组的末尾添加一个或多个元素</p>
<ol>
<li><p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [1, 2, 3];</span><br><span class="line">arr.push(4, &#x27;pink&#x27;);</span><br></pre></td></tr></table></figure>

<ul>
<li>数组元素直接写数组元素</li>
<li>push完毕以后，返回的结果是新数组的长度</li>
<li>原数组也会发生变化</li>
</ul>
</li>
</ol>
</li>
<li><p>unshift(参数1..)：在数组的开头，添加一个或者多个数组元素</p>
<ol>
<li>语法<code>arr.unshift(&#39;red&#39;, &#39;purple&#39;);</code><ul>
<li>数组元素直接写数组元素</li>
<li>unshift完毕以后，返回的结果是新数组的长度</li>
<li>原数组会发生变化</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="删除数组元素"><a href="#删除数组元素" class="headerlink" title="删除数组元素"></a>删除数组元素</h3><ol>
<li>pop()：删除数组的最后一个元素(内部无参数)<ol>
<li>语法：<code>arr.pop();</code><ul>
<li>pop()没有参数</li>
<li>pop完毕以后，返回值是删除的元素</li>
<li>原数组会发生变化</li>
</ul>
</li>
</ol>
</li>
<li>shift()：删除数组的第一个元素(内部无参数)<ol>
<li>语法：<code>arr.shift();</code><ul>
<li>shift()没有参数</li>
<li>shift完毕以后，返回值是删除的元素</li>
<li>原数组会发生变化</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="数组翻转和排序"><a href="#数组翻转和排序" class="headerlink" title="数组翻转和排序"></a>数组翻转和排序</h3><ol>
<li><p>reverse()：颠倒数组中元素的顺序（内部无参数）</p>
<ol>
<li>语法：<code>arr.reverse();</code></li>
</ol>
</li>
<li><p>sort()：对数组中的元素进行排序（内部无参数）</p>
<ol>
<li><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arr.sort(function(a, b)&#123;</span><br><span class="line">  return a -b; //升序排序</span><br><span class="line">  return b - a; //降序排序</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="数组索引方法"><a href="#数组索引方法" class="headerlink" title="数组索引方法"></a>数组索引方法</h3><ol>
<li>indexOf(数组元素, [开始查找位置的索引])：数组中查找给定元素的第一个索引（从前到后查找）<ol>
<li>语法：<code>arr.indexOf(&#39;blue&#39;);</code><ul>
<li>只返回第一个满足条件的索引号</li>
<li>若数组内没有该元素，则返回-1</li>
</ul>
</li>
</ol>
</li>
<li>lastIndexOf(数组元素)：数组中查找给定元素的最后一个索引（从后到前查找）<ol>
<li>语法：<code>arr.lastIndexOf(&#39;blue&#39;);</code><ul>
<li>只返回最后一个满足条件的索引号</li>
<li>若数组内没有该元素，则返回-1</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="数组转换为字符串"><a href="#数组转换为字符串" class="headerlink" title="数组转换为字符串"></a>数组转换为字符串</h3><ol>
<li>toString()：将数组中的元素转换为字符串<ol>
<li>语法：<code>arr.toString();</code><ul>
<li>返回值为数组转换后的字符串</li>
</ul>
</li>
</ol>
</li>
<li>**join(‘分隔符’)**：将数组中的元素转换为字符串，可以改变连接的符号<ol>
<li>语法：<code>arr.join(&#39;-&#39;);</code></li>
</ol>
</li>
</ol>
<h3 id="数组其他方法"><a href="#数组其他方法" class="headerlink" title="数组其他方法"></a>数组其他方法</h3><ol>
<li><p>**concat()**：连接两个或者多个数组，不影响原数组</p>
<ol>
<li>语法：arr1.concat(arr2);<ul>
<li>返回值为新的数组</li>
</ul>
</li>
</ol>
</li>
<li><p>**slice(begin, end)**：数组截取，截取从数组第begin个索引到第end个索引的元素，不包含索引为end的元素</p>
<ol>
<li>语法：arr.slice(2, 4);<ul>
<li>返回值为被截取项目的新数组</li>
<li>截取元素中不包含索引为end的元素</li>
</ul>
</li>
<li><strong>若只有一个参数begin，则表示截取从begin开始往后的所有元素</strong></li>
</ol>
</li>
<li><p><strong>splice()：删除元素 &#x2F; 插入元素 &#x2F; 替换元素</strong></p>
<ol>
<li><p>语法：arr.splice(begin, count, value);</p>
<ul>
<li>删除元素：第一个参数为从第几个索引开始，第二个参数为删除多少个</li>
<li>替换元素：第一个参数为从第几个索引开始，第二个参数为要替换几个元素，后面的参数为替换前面的元素</li>
<li>插入元素：第一个参数为从第几个索引开始，第二个参数为0，后面的参数为要插入的元素</li>
</ul>
</li>
<li><p>返回值为被删除项目的新数组，会影响原数组的元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 数组中添加新元素</span><br><span class="line">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];</span><br><span class="line">fruits.splice(2,0,&quot;Lemon&quot;,&quot;Kiwi&quot;); // Banana,Orange,Lemon,Kiwi,Apple,Mango</span><br><span class="line"></span><br><span class="line">// 移除数组的第三个元素，并在数组第三个位置添加新元素</span><br><span class="line">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];</span><br><span class="line">fruits.splice(2,1,&quot;Lemon&quot;,&quot;Kiwi&quot;); // Banana,Orange,Lemon,Kiwi,Mango</span><br><span class="line"></span><br><span class="line">// 从第三个位置开始删除数组后的两个元素</span><br><span class="line">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];</span><br><span class="line">fruits.splice(2,2); // Banana,Orange</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>字符串所有的方法，都不会修改字符串本身（字符串是不可变的），操作完成会返回一个新的字符串</p>
</li>
</ol>
<h3 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h3><ol>
<li><p>基本包装类型：把简单数据类型，包装成为了复杂数据类型</p>
</li>
<li><p>对象和复杂数据类型才具有属性和方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var str = &#x27;andy&#x27;;</span><br><span class="line">str.length;</span><br></pre></td></tr></table></figure>

<ol>
<li>‘andy’为字符数据类型，属于简单数据类型，为什么会有length属性？<ul>
<li>因为基本包装类型把简单数据类型包装为了复杂数据类型<ul>
<li>第一步：把简单数据类型包装为复杂数据类型，执行过程如下<br><code>var temp = new String(&#39;andy&#39;);</code></li>
<li>第二步：把临时变量的值给str<br><code>str = temp;</code></li>
<li>第三步：销毁临时变量<br><code>temp = null;</code></li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="根据字符返回位置"><a href="#根据字符返回位置" class="headerlink" title="根据字符返回位置"></a>根据字符返回位置</h3><ol>
<li><p>indexOf(‘要查找的字符’, [开始查找位置的索引])：字符串中查找给定元素的第一个索引（从前到后查找）</p>
<ol>
<li><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">str.indexOf(&#x27;a&#x27;, 5);</span><br></pre></td></tr></table></figure>

<ul>
<li>返回值为指定内容在原字符串中的位置，若找不到则返回-1</li>
</ul>
</li>
</ol>
</li>
<li><p>lastIndexOf(‘要查找的字符’)：字符串中查找给定元素的最后一个索引（从后到前查找）</p>
<ol>
<li><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">str.lastIndexOf(&#x27;b&#x27;);</span><br></pre></td></tr></table></figure>

<ul>
<li>返回值为指定内容在原字符串中的位置，若找不到则返回-1</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="根据位置返回字符（重点）"><a href="#根据位置返回字符（重点）" class="headerlink" title="根据位置返回字符（重点）"></a>根据位置返回字符（重点）</h3><ol>
<li><p>charAt(index)：返回指定位置的字符（index为字符串的索引号）</p>
<ol>
<li>语法：<code>str.charAt(2);</code></li>
</ol>
</li>
<li><p>charCodeAT(index)：获取指定位置处字符的ASCII码（index为索引号）</p>
<ol>
<li><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">str.charCodeAt(3);</span><br></pre></td></tr></table></figure>

<ul>
<li>目的是可以判断用户按下了哪个键</li>
</ul>
</li>
</ol>
</li>
<li><p>str[index]：返回指定位置的字符（HTML5，IE8+支持）</p>
<ol>
<li>语法：<code>str[1];</code></li>
</ol>
</li>
<li><p>案例：统计一个字符串中每个字符出现的次数，求出出现最多的字符及其出现次数</p>
<ul>
<li><p>以下算法很常用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  var str = &#x27;abcoefoxyozzopp&#x27;;</span><br><span class="line">  var statistical = &#123;&#125;;</span><br><span class="line">  for (var i = 0; i &lt; str.length; i++) &#123;</span><br><span class="line">    var chars = str.charAt(i); // 遍历字符串内的每一个字符</span><br><span class="line">    // statistical[chats]是一个属性值，当对象中没有该属性时，属性值为0</span><br><span class="line">    if (statistical[chars]) &#123;</span><br><span class="line">      // 代表该字符已经在对象出现过，将属性值自增1       </span><br><span class="line">      statistical[chars]++;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 代表该字符在对象中第一次出现，让该属性的值为1</span><br><span class="line">      statistical[chars] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(statistical);</span><br><span class="line"></span><br><span class="line">  // 遍历对象</span><br><span class="line">  var max = 0;</span><br><span class="line">  var ch = &#x27;&#x27;;</span><br><span class="line">  for (var k in statistical) &#123; // k为变量，输出为属性名</span><br><span class="line">    if (statistical[k] &gt; max) &#123;</span><br><span class="line">      max = statistical[k]; // statistical[k]输出为属性值</span><br><span class="line">      ch = k;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(&#x27;字符串中出现最多的字符为：&#x27; + ch + &#x27;，出现次数为&#x27; + max + &#x27;次&#x27;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="字符串操作方法（重点）"><a href="#字符串操作方法（重点）" class="headerlink" title="字符串操作方法（重点）"></a><strong>字符串操作方法（重点）</strong></h3><ol>
<li><p>concat(str1, str2, str3..)：用于连接两个或多个字符串，拼接字符串，等效与+，但+更常用</p>
<ol>
<li><p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">str.concat(str1, str2, str3..)</span><br><span class="line">str.concat(&#x27;red&#x27;);</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>substr(start, length)：从start位置开始（索引号），length为取的个数</p>
<ol>
<li><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">str.substr(1, 3);</span><br></pre></td></tr></table></figure>

<ul>
<li>返回值为被截取的字符</li>
</ul>
</li>
</ol>
</li>
<li><p>slice(begin, end)：字符串截取，截取从字符串第begin个索引到第end个索引的字符，不包含索引为end的字符</p>
<ol>
<li><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">str.slice(2, 4);</span><br></pre></td></tr></table></figure>

<ul>
<li>返回值为被截取的字符</li>
<li>截取元素中不包含索引为end的字符</li>
</ul>
</li>
</ol>
</li>
<li><p>substring(begin, end)：字符串截取，截取从字符串第begin个索引到第end个索引的字符，不包含索引为end的字符</p>
<ol>
<li><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">str.substring(2, 4);</span><br></pre></td></tr></table></figure>

<ul>
<li>返回值为被截取的字符</li>
<li>截取元素中不包含索引为end的字符</li>
<li>基本和slice相同，但是不接受负值</li>
</ul>
</li>
</ol>
</li>
<li><p>split(str, num)：通过<strong>指定分隔符对字符串进行切片</strong>，如果参数num有指定值，则分隔num+1个子字符串</p>
<ol>
<li><p>str：分隔符，默认为所有的空字符，包括空格、换行(\n)、制表符(\t)等</p>
</li>
<li><p>num：分割次数。默认为 -1, 即分隔所有</p>
</li>
<li><p>注意：返回值为一个<strong>数组</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">str = &quot;Line1-abcdef \nLine2-abc \nLine4-abcd&quot;;</span><br><span class="line">print str.split( );       # 以空格为分隔符，包含 \n</span><br><span class="line">print str.split(&#x27; &#x27;, 1 ); # 以空格为分隔符，分隔成两个</span><br><span class="line"></span><br><span class="line">// 以上输出如下</span><br><span class="line">// [&#x27;Line1-abcdef&#x27;, &#x27;Line2-abc&#x27;, &#x27;Line4-abcd&#x27;]</span><br><span class="line">// [&#x27;Line1-abcdef&#x27;, &#x27;\nLine2-abc \nLine4-abcd&#x27;]</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="替换字符串"><a href="#替换字符串" class="headerlink" title="替换字符串"></a>替换字符串</h3><ol>
<li><p>replace(‘被替换的字符’, ‘替换为的字符’)：替换字符串中指定的字符</p>
<ol>
<li><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">str.replace(&#x27;a&#x27;, &#x27;b&#x27;);</span><br></pre></td></tr></table></figure>

<ul>
<li>返回值为被替换后的字符串</li>
</ul>
</li>
<li><p>案例：替换敏感词</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  var str = &#x27;内置对象就是指JS语言自带的一些对象，这些对象供开发者使用，并提供了一些常用的或是最基本而必要的功能(属性和方法)&#x27;;</span><br><span class="line"></span><br><span class="line">  while (str.indexOf(&#x27;些&#x27;) !== -1) &#123;</span><br><span class="line">    str = str.replace(&#x27;些&#x27;, &#x27;*&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(str);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="字符串转换为数组"><a href="#字符串转换为数组" class="headerlink" title="字符串转换为数组"></a>字符串转换为数组</h3><ol>
<li><p>**split(‘分隔符’)**：将字符串中的字符转换为数组元素，分隔符为需要转换为数组的字符串所带的符号</p>
<ol>
<li><p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var str = &#x27;red-green-blue&#x27;;</span><br><span class="line">str.split(&#x27;-&#x27;);</span><br></pre></td></tr></table></figure>

<ul>
<li>返回值为字符串转换后的数组</li>
</ul>
</li>
</ol>
</li>
</ol>
<h1 id="简单数据类型和复杂数据类型"><a href="#简单数据类型和复杂数据类型" class="headerlink" title="简单数据类型和复杂数据类型"></a>简单数据类型和复杂数据类型</h1><ol>
<li>简单类型又叫做基本数据类型或者值类型，复杂类型又叫做引用类型</li>
</ol>
<h2 id="简单数据类型"><a href="#简单数据类型" class="headerlink" title="简单数据类型"></a>简单数据类型</h2><ol>
<li>简单数据类型（值类型）：简单数据类型&#x2F;基本数据类型，在存储时变量中存储的是值本身，因此叫做值类型</li>
<li>五大简单数据类型（值类型）：string, number, boolean, undefined, null</li>
</ol>
<h3 id="null"><a href="#null" class="headerlink" title="null"></a>null</h3><ol>
<li><p>简单数据类型null，返回的是一个空对象 — object</p>
</li>
<li><p>若存在一个变量我们打算存储为对象，却暂时没有想好放什么，这时就可以给null</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var timer = null;</span><br><span class="line">console.log(typeof timer);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ol>
<li>栈（操作系统）：由操作系统自动分配释放存放函数的参数值，局部变量的值等</li>
<li>简单数据类型存放到栈里面：存放的是值</li>
</ol>
<h3 id="简单数据类型传参"><a href="#简单数据类型传参" class="headerlink" title="简单数据类型传参"></a>简单数据类型传参</h3><ol>
<li>函数的形参可以看做是一个变量，当我们把一个值类型变量作为参数传给函数的形参时，其实是把变量在栈空间里的值复制了一份给形参，那么在方法内部对形参做任何修改，都不会影响到的外部变量</li>
</ol>
<h2 id="复杂数据类型"><a href="#复杂数据类型" class="headerlink" title="复杂数据类型"></a>复杂数据类型</h2><ol>
<li>复杂数据类型（引用类型）：在存储是变量中存储的仅仅是地址（引用）</li>
<li>通过new关键字创建的对象（系统对象，自定义对象），如Object，Array，Date等</li>
</ol>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><ol>
<li>堆（操作系统）：存储复杂数据类型（对象），一般由程序员分配释放，若程序员步释放，则由垃圾回收机制回收</li>
<li>复杂数据类型存放到堆里面：首先在栈里面存放地址（十六进制表示），然后这个地址指向堆里面的数据</li>
</ol>
<h3 id="复杂数据类型传参"><a href="#复杂数据类型传参" class="headerlink" title="复杂数据类型传参"></a>复杂数据类型传参</h3><ol>
<li><p>函数的形参也可以看做是一个变量，当我们把引用类型变量传给形参时，实是把变量在栈空间里保存的堆地址复制给了形参，形参和实参其实保存的是同一个堆地址，所以操作的是同一个对象</p>
</li>
<li><p>案例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  function Person(name) &#123;</span><br><span class="line">    // 将栈内存中地址为0xaabbcc指向堆内存中对象p的name属性值改为&#x27;刘德华&#x27;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function f1(x) &#123; // 这里x在栈内存中的地址为0xaabbcc，指向了堆内存中的对象</span><br><span class="line">    // 输出堆内存中对象的name属性值，因为地址一致，因此地址指向相同，为同一对象</span><br><span class="line">    console.log(x.name); // 第二：输出刘德华</span><br><span class="line">    // 将堆内存中对象的name属性值改为&#x27;张学友&#x27;</span><br><span class="line">    x.name = &#x27;张学友&#x27;;</span><br><span class="line">    console.log(x.name); // 第三：输出张学友</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 创建对象p，将对象p的地址存储进栈内存，假设地址为0xaabbcc；地址指向堆内存中的对象，对象的name属性值为&#x27;刘德华&#x27;</span><br><span class="line">  var p = new Person(&#x27;刘德华&#x27;);</span><br><span class="line">  // 通过栈内存中的地址0xaabbcc，找到堆内存中p对象的name属性值</span><br><span class="line">  console.log(p.name); // 第一：输出刘德华</span><br><span class="line">  // 将栈内存中p对象的堆地址0xaabbcc复制给形参</span><br><span class="line">  f1(p);</span><br><span class="line">  // 此时栈内存中0xaabbcc地址指向的对象属性值已经被更改</span><br><span class="line">  console.log(p.name); // 第四：输出张学友</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript函数、作用域和预解析</title>
    <url>/2022/08/01/JavaScript%E5%87%BD%E6%95%B0%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%A2%84%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数的概念"><a href="#函数的概念" class="headerlink" title="函数的概念"></a>函数的概念</h2><ol>
<li>在JS里面，可能会定义非常多的相同代码或者功能相似的代码，这些代码可能需要大量重复使用；虽然for循环语句也能实现一些简单的重复操作，但是比较具有局限性，此时就可以使用JS中的函数</li>
<li>函数：封装一段可以被大量重复执行的代码块</li>
</ol>
<h2 id="函数的使用"><a href="#函数的使用" class="headerlink" title="函数的使用"></a>函数的使用</h2><ol>
<li>函数使用分为两步：声明函数和调用函数</li>
</ol>
<h3 id="声明函数"><a href="#声明函数" class="headerlink" title="声明函数"></a>声明函数</h3><ol>
<li><p>声明函数的两种方式</p>
<ol>
<li><p>常用：利用函数关键字自定义函数（命名函数）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function 函数名(形参1, 形参2..) &#123;</span><br><span class="line">  //函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数表达式（匿名函数）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var fun =  function() &#123;&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>fun是变量名，不是函数名</li>
<li>函数表达式声明方式跟变量差不多，只不过变量里面存的是值，而函数表达式里面存的是函数</li>
<li>函数表达式也可以进行传递参数，方式与命名函数一致</li>
</ul>
</li>
</ol>
</li>
<li><p>function是声明函数的关键字，必须小写</p>
</li>
<li><p>形参（形式参数）是用来接受实参（实际参数）的，类似于一个变量</p>
</li>
<li><p>函数一般是为了实现某个功能才定义的，所以通常将函数名命名为动词</p>
</li>
<li><p>函数可以带参数也可以不带参数</p>
</li>
</ol>
<h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><ol>
<li>语法：<ul>
<li>函数名(实参1, 实参2..);</li>
</ul>
</li>
<li>通过调用函数名来执行函数体代码</li>
<li>调用时千万不要忘记添加小括号</li>
</ol>
<h3 id="函数的封装"><a href="#函数的封装" class="headerlink" title="函数的封装"></a>函数的封装</h3><ol>
<li>函数的封装是把一个或者多个功能通过函数的方式封装起来，对外只提供一个简单的函数接口</li>
</ol>
<h2 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h2><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>形参</td>
<td>形式上的参数 函数定义的时候传递的参数 当前并不知道</td>
</tr>
<tr>
<td>实参</td>
<td>实际上的参数 函数调用的时候传递的参数 实参是传递给形参的</td>
</tr>
</tbody></table>
<h3 id="形参"><a href="#形参" class="headerlink" title="形参"></a>形参</h3><ol>
<li>在声明函数时，可以在函数名称后面的小括号中添加一些参数，这些参数被称为形参</li>
</ol>
<h3 id="实参"><a href="#实参" class="headerlink" title="实参"></a>实参</h3><ol>
<li>在调用函数时，同样也需要传递相应的参数，这些参数被称为实参</li>
</ol>
<h3 id="形参与实参匹配"><a href="#形参与实参匹配" class="headerlink" title="形参与实参匹配"></a>形参与实参匹配</h3><ol>
<li>若实参的个数和形参的个数一致——则正常输出结果</li>
<li>实参的个数多于形参的个数——只取到形参的个数</li>
<li>实参的个数小于形参的个数——多于的形参定义为undefined，最终的结果就是NaN</li>
</ol>
<h2 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h2><h3 id="返回值的格式"><a href="#返回值的格式" class="headerlink" title="返回值的格式"></a>返回值的格式</h3><ol>
<li><p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function 函数名() &#123;</span><br><span class="line">  return 需要返回的结果;</span><br><span class="line">&#125;</span><br><span class="line">var result = 函数名();</span><br><span class="line">console.log(result); //输出结果</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数只是实现某种功能，最终的结果需要返回给函数的调用者函数名()，通过return实现的</p>
</li>
<li><p>在实际开发中 ，我们经常用一个变量来接受函数的返回结果</p>
</li>
<li><p>函数都是有返回值的</p>
<ol>
<li>如果有return则返回return后面的值</li>
<li>如果没有return则返回undefined</li>
</ol>
</li>
</ol>
<h3 id="break，continue，return的区别"><a href="#break，continue，return的区别" class="headerlink" title="break，continue，return的区别"></a>break，continue，return的区别</h3><ol>
<li>break：结束当前的循环体（如for，while）</li>
<li>continue：跳出本次循环，继续执行下次循环（如for，while）</li>
<li>return：不仅可以退出循环，还能够返回return语句中的值，同时还可以结束当前的函数体内的代码</li>
</ol>
<h2 id="函数可以调用另外一个函数"><a href="#函数可以调用另外一个函数" class="headerlink" title="函数可以调用另外一个函数"></a>函数可以调用另外一个函数</h2><ol>
<li>每个函数都是独立的代码块,用于完成特殊任务,因此经常会用到函数相互调用的情况</li>
</ol>
<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><h2 id="作用域概述"><a href="#作用域概述" class="headerlink" title="作用域概述"></a>作用域概述</h2><ol>
<li>通常来说，一段程序代码中所用到的名字并不总是有效和可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域</li>
<li>作用域的使用提高了程序逻辑的局部性，增强了程序的可靠性，减少了名字冲突</li>
</ol>
<h2 id="JavaScript作用域"><a href="#JavaScript作用域" class="headerlink" title="JavaScript作用域"></a>JavaScript作用域</h2><ol>
<li>JavaScript作用域：就是代码名字（变量）在某个范围内起作用和效果，目的是为了提高程序的可靠性和减少命名冲突</li>
</ol>
<h3 id="全局作用域和局部作用域"><a href="#全局作用域和局部作用域" class="headerlink" title="全局作用域和局部作用域"></a>全局作用域和局部作用域</h3><ol>
<li>全局作用域：整个script标签或者一个单独的js文件</li>
<li>局部作用域：在函数内部就是局部作用域，这个代码的名字（变量）只在函数内部起效果和作用</li>
</ol>
<h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><ol>
<li>在JavaScript中，根据作用域的不同，变量可以分为两种：<ol>
<li>全局变量：在全局作用域下的变量<ul>
<li>全局变量在代码的任何位置都可以使用</li>
<li>在全局作用域下var声明的变量是全局变量</li>
<li>特殊情况下，在函数内不使用var声明的变量也是全局变量(不建议使用)</li>
</ul>
</li>
<li>局部变量：在局部作用域下的变量；函数的形参也可以看作是局部变量<ul>
<li>局部变量只能在该函数内部使用</li>
<li>在函数内部var声明的变量是局部变量</li>
<li>函数的形参实际上就是局部变量</li>
</ul>
</li>
</ol>
</li>
<li>从执行效率来看全局变量和局部变量<ol>
<li>全局变量只有浏览器关闭时才会销毁，比较占用内存资源</li>
<li>局部变量当程序执行完毕时就会销毁，比较节约内存资源</li>
</ol>
</li>
</ol>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><ol>
<li>内部函数访问外部函数的变量，采取的是链式查找的方式来决定取那个值这种结构我们称为作用域链（就近原则）</li>
</ol>
<h1 id="预解析（面试题）"><a href="#预解析（面试题）" class="headerlink" title="预解析（面试题）"></a>预解析（面试题）</h1><h2 id="预解析概述"><a href="#预解析概述" class="headerlink" title="预解析概述"></a>预解析概述</h2><ol>
<li>JavaScript代码是由浏览器中的JavaScript解析器来执行的</li>
<li>JavaScript解析器在运行JavaScript代码的时候分为两步：预解析和代码执行<ol>
<li>预解析js引擎会把js里面所有的var还有function提升到当前作用域的最前面</li>
<li>代码执行按照代码书写的顺序从上往下执行</li>
</ol>
</li>
<li>预解析分为：<ol>
<li>变量预解析（变量提升）：把所有的变量声明提升到当前的作用域最前面，不提升赋值操作</li>
<li>函数预解析（函数提升）：把所有的函数声明提升到当前作用域的最前面，不调用函数</li>
</ol>
</li>
<li>预解析案例一<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20210925020805.png" alt="img"></li>
<li>预解析案例二，经典面试题（重点）<br><img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20210925020847.png" alt="img"></li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript基础</title>
    <url>/2022/08/01/JavaScript%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="JavaScript基础"><a href="#JavaScript基础" class="headerlink" title="JavaScript基础"></a>JavaScript基础</h1><h2 id="什么是JavaScript"><a href="#什么是JavaScript" class="headerlink" title="什么是JavaScript"></a>什么是JavaScript</h2><ul>
<li>JavaScript是一种运行在客户端的脚本语言</li>
<li>脚本语言：不需要编译，运行过程由js解释器逐行进行解释并执行</li>
<li>现在也可以基于Node.js技术进行服务器端编程</li>
</ul>
<h2 id="JavaScript作用"><a href="#JavaScript作用" class="headerlink" title="JavaScript作用"></a>JavaScript作用</h2><ul>
<li>表单动态校验（密码强度检测）（JS产生最初的目的）</li>
<li>网页特效</li>
<li>服务端开发（Node.js)</li>
<li>桌面程序（Electron）</li>
<li>App（Cordova）</li>
<li>控制硬件-物联网（Ruff）</li>
<li>游戏开发（cocos2d-js）</li>
</ul>
<h2 id="浏览器执行JS简介"><a href="#浏览器执行JS简介" class="headerlink" title="浏览器执行JS简介"></a>浏览器执行JS简介</h2><p>浏览器分成两部分：渲染引擎和 JS 引擎</p>
<ul>
<li>渲染引擎：用来解析HTML与CSS，俗称内核，比如 chrome 浏览器的 blink ，老版本的 webkit</li>
<li>JS 引擎：也称为 JS 解释器。 用来读取网页中的JavaScript代码，对其处理后运行，比如 chrome 浏览器的 V8</li>
</ul>
<p>浏览器本身并不会执行JS代码，而是通过内置 JavaScript 引擎(解释器) 来执行 JS 代码 。JS 引擎执行代码时逐行解释每一句源码（转换为机器语言），然后由计算机去执行，所以 JavaScript 语言归为脚本语言，会逐行解释执行。</p>
<h2 id="JS的组成"><a href="#JS的组成" class="headerlink" title="JS的组成"></a>JS的组成</h2><p>JavaScript 包括 ECMAScript、DOM、BOM</p>
<ul>
<li><p>ECMAScript</p>
<p>ECMAScript：ECMAScript 规定了JS的编程语法和基础核心知识，是所有浏览器厂商共同遵守的一套JS语法工业标准。</p>
</li>
<li><p>DOM文档对象模型<br>文档对象模型（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展标记语言的标准编程接口。通过 DOM 提供的接口可以对页面上的各种元素进行操作（大小、位置、颜色等）。</p>
</li>
<li><p>BOM浏览器对象模型<br>BOM (Browser Object Model，简称BOM) 是指浏览器对象模型，它提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。通过BOM可以操作浏览器窗口，比如弹出框、控制浏览器跳转、获取分辨率等。</p>
</li>
</ul>
<h1 id="JS基本语法"><a href="#JS基本语法" class="headerlink" title="JS基本语法"></a>JS基本语法</h1><h2 id="输入输出语句"><a href="#输入输出语句" class="headerlink" title="输入输出语句"></a>输入输出语句</h2><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>归属</th>
</tr>
</thead>
<tbody><tr>
<td>alert(msg);</td>
<td>浏览器弹出警示框</td>
<td>浏览器</td>
</tr>
<tr>
<td>console.log(msg);</td>
<td>浏览器控制台打印输出信息</td>
<td>浏览器</td>
</tr>
<tr>
<td>prompt(info);</td>
<td>浏览看弹出输入框，用户可以输入</td>
<td>浏览器</td>
</tr>
</tbody></table>
<ul>
<li><code>alert()</code> 主要用来显示消息给用户</li>
<li><code>console.log()</code> 用来给程序员看自己运行时的消息</li>
</ul>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>变量是用于存放数据的容器，我们通过变量名获取数据，甚至数据可以修改</p>
<p>本质：变量是程序在内存中申请的一块用来存放数据的空间</p>
<h2 id="变量初始化"><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化</h2><p>var是一个JS关键字，用来声明变量(variable变量的意思)。使用该关键字声明变量后，计算机会自动为变量分配内存空间。</p>
<p>age 是程序员定义的变量名，我们要通过变量名来访问内存中分配的空间<br>&#x2F;&#x2F;声明变量同时赋值为18<br>var age &#x3D; 18;<br>&#x2F;&#x2F;同时声明多个变量时，只需要写一个 var， 多个变量名之间使用英文逗号隔开。</p>
<p>var age &#x3D; 18, address &#x3D;’火影村’,salary &#x3D; 15000;</p>
<h2 id="声明变量特殊情况"><a href="#声明变量特殊情况" class="headerlink" title="声明变量特殊情况"></a>声明变量特殊情况</h2><table>
<thead>
<tr>
<th>情况</th>
<th>说明</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>var age; console.log(age);</td>
<td>只声明，不赋值</td>
<td>undefined</td>
</tr>
<tr>
<td>console.log(age)</td>
<td>不声明 不赋值 直接使用</td>
<td>报错</td>
</tr>
<tr>
<td>age &#x3D; 10;console.log(age);</td>
<td>不声明 只赋值</td>
<td>10</td>
</tr>
</tbody></table>
<h2 id="变量的命名规范"><a href="#变量的命名规范" class="headerlink" title="变量的命名规范"></a>变量的命名规范</h2><ul>
<li><p>由字母(A-Z,a-z)，数字(0-9)，下划线(_)，美元符号($)组成，如:usrAge,num01,__name</p>
</li>
<li><p>严格区分大小写。 var app; 和 var App; 是两个变量</p>
</li>
<li><p>不能以数字开头。</p>
</li>
<li><p>不能是关键字，保留字。例如：var,for,while</p>
</li>
<li><p>遵循驼峰命名法。首字母小写，后面单词的首字母需要大写。myFirstName</p>
</li>
<li><p>推荐翻译网站：有道 爱词霸</p>
</li>
<li><p>name尽量不使用来命名，在有些网站有特殊意义</p>
</li>
</ul>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>1.JavaScript <strong>是一种弱类型或者说动态语言。</strong>这意味着不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var age = 10; 			 //这是一个数字型</span><br><span class="line">var areYouOk = &#x27;使得&#x27;;	//这是一个字符串</span><br></pre></td></tr></table></figure>

<p>在代码运行时，变量的数据类型是由 JS引擎 根据 &#x3D; 右边变量值的数据类型来判断 的，运行完毕之后， 变量就确定了数据类型。</p>
<p>2.JavaScript 拥有动态类型，同时也意味着相同的变量可用作不同的类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var x = 6;		//x为数字</span><br><span class="line">var x = &quot;Bill&quot;;	//x为字符串</span><br></pre></td></tr></table></figure>

<p>JS 把数据类型分为两类：</p>
<ul>
<li>基本数据类型(Number,String,Boolean,Undefined,Null)</li>
<li>复杂数据类型(Object)</li>
</ul>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><table>
<thead>
<tr>
<th>简单数据类型</th>
<th>说明</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>Number</td>
<td>数字型，包含整数型和浮点型</td>
<td>0</td>
</tr>
<tr>
<td>Boolean</td>
<td>布尔值类型，true（加法运算中当1看）和false（加法运算中当0看）</td>
<td>false</td>
</tr>
<tr>
<td>String</td>
<td>字符串类型</td>
<td>“”</td>
</tr>
<tr>
<td>Undefined</td>
<td>var a; 声明了变量a但是没有给值，此时a &#x3D; undefined</td>
<td>undefined</td>
</tr>
<tr>
<td>Null</td>
<td>var a &#x3D; null; 声明了变量a为空值</td>
<td>null</td>
</tr>
</tbody></table>
<h2 id="数字型进制"><a href="#数字型进制" class="headerlink" title="数字型进制"></a>数字型进制</h2><p>最常见的进制有二进制、八进制、十进制、十六进制。</p>
<p>1.八进制数字序列范围：0~7</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var num1 = 07; 		//对应十进制的7</span><br><span class="line">var Num2 = 019;		//对应十进制的19</span><br><span class="line">var num3 = 08;		//对应十进制的8</span><br></pre></td></tr></table></figure>

<p>2.十六进制数字序列范围：0<del>9以及A</del>F</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var num = 0xA;</span><br></pre></td></tr></table></figure>

<p><strong>⭐在JS中八进制前面加0，十六进制前面加 0x</strong></p>
<ol>
<li><p>数字型范围<br>JS中数值的最大值：Number.MAX_VALUE<br>JS中数值的最小值：Number.MIN_VALUE</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">consol.log(Number.MAX_VALUE);</span><br><span class="line">consol.log(Number.MIN_VALUE);</span><br></pre></td></tr></table></figure>
</li>
<li><p>数字型的三个特殊值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alert(Infinity); 	//Infinity(无穷大)</span><br><span class="line">alert(-Infinity); 	//-Infinity(无穷小)</span><br><span class="line">alert(NaN);       	//NaN - Not a Number ,代表任何一个非数值</span><br></pre></td></tr></table></figure>

<ol>
<li>Infinity ，代表无穷大，大于任何数值</li>
<li>-Infinity ，代表无穷小，小于任何数值</li>
<li>Nan ，Not a Number，代表一个非数值</li>
</ol>
</li>
<li><p>isNaN(): 这个方法用来判断非数字，并且返回一个值，如果是数字返回的是false，如果不是数字返回的是true</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var userAge = 21;</span><br><span class="line">var isOk = isNan(userAge);</span><br><span class="line">console.log(isOk);		//false,21不是一个非数字</span><br><span class="line"></span><br><span class="line">var userName = &quot;andy&quot;;</span><br><span class="line">console.log(isNan(userName));	//true,&quot;andy&quot;是一个非数字</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="字符串型String"><a href="#字符串型String" class="headerlink" title="字符串型String"></a>字符串型String</h2><p>字符串型可以是引号中的任意文本，其语法为 “双引号” 和 “单引号’’</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var strMsg = &quot;我爱北京天安门~&quot;;		//使用双引号表示字符串</span><br><span class="line">var strMsg = &#x27;我爱北京&#x27;;			  //使用单引号表示字符串</span><br></pre></td></tr></table></figure>


<ul>
<li>因为 HTML 标签里面的属性使用的是双引号，JS 这里我们更推荐使用单引号。</li>
</ul>
<ol>
<li><p>字符串引号嵌套<br>JS可以用 单引号嵌套双引号，或者用 双引号嵌套单引号（外双内单，外单内双）</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var strMsg =&#x27;我是一个“天才”&#x27; //可以用 &#x27; &#x27; 包含 &quot; &quot;</span><br><span class="line">var strMsg2 =&quot;我是&#x27;天才&#x27;&quot; //可以用&quot; &quot;  包含  &#x27;&#x27;</span><br></pre></td></tr></table></figure>

</li>
<li><p>字符串转义符<br>类似HTML里面的特殊字符，字符串中也有特殊字符，我们称之为转义符。</p>
</li>
</ol>
<p>转义符都是 \ 开头的，常用的转义符及其说明如下：</p>
<table>
<thead>
<tr>
<th>转义符</th>
<th>解释说明</th>
</tr>
</thead>
<tbody><tr>
<td>\n</td>
<td>换行符，n是newline</td>
</tr>
<tr>
<td>\ \</td>
<td>斜杠\</td>
</tr>
<tr>
<td>\ ’</td>
<td>’ 单引号</td>
</tr>
<tr>
<td>\ ‘’</td>
<td>‘’ 双引号</td>
</tr>
<tr>
<td>\ t</td>
<td>tab 缩进</td>
</tr>
<tr>
<td>\ b</td>
<td>空格，b是blank的意思</td>
</tr>
</tbody></table>
<ol start="3">
<li><p>字符串长度<br>字符串是由若干字符组成的，这些字符的数量就是字符串的长度。通过字符串的 length 属性可以获取整个字符串的长度。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//通过字符串的length属性可以获取整个字符串的长度</span><br><span class="line">var strMsg = &quot;我是天才！&quot;;</span><br><span class="line">alert(strMsg.length);     //显示5</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串的拼接</p>
<ol>
<li><p>多个字符串之间可以使用 + 进行拼接，其拼接方式为 字符串 + 任何类型 &#x3D; 拼接之后的新字符串</p>
</li>
<li><p>拼接前会把与字符串相加的任何类型转成字符串，再拼接成一个新的字符串</p>
</li>
<li><p>注意：字符串 + 任何类型 &#x3D;拼接之后的新字符串</p>
<ol>
<li>字符串相加</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alert(&#x27;hello&#x27; + &#x27; &#x27; + &#x27;World&#x27;);  //hello World</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>数值字符串相加</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alert(&#x27;100&#x27; + &#x27;100&#x27;); //100100</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>数值字符串+数值</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alert(&#x27;12&#x27;+12); //1212</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>数值+数值</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alert(12+12); //24</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<p>⭐<strong>号总结口诀：数值相加，字符相连</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var  age = 18;</span><br><span class="line">console.log(&#x27;我今年&#x27;+age+&#x27;岁&#x27;);</span><br><span class="line">console.log(&#x27;我今年&#x27;+age+&#x27;岁&#x27;);  //引引加加，最终也是上面的形式</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>字符串拼接加强</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(&#x27;老师&#x27; + 18);			//只要有字符就会相连</span><br><span class="line">var age = 18;</span><br><span class="line">// console.log(&#x27;老师age岁了&#x27;);	//这样不行,会输出&quot;老师age岁了&quot;</span><br><span class="line">console.log(&#x27;老师&#x27; + age);		 // 老师18</span><br><span class="line">console.log(&#x27;老师&#x27; + age + &#x27;岁啦&#x27;);	// 老师18岁啦</span><br></pre></td></tr></table></figure>

<p>我们经常会将字符串和变量来拼接，因为变量可以很方便地修改里面的值<br>变量是不能添加引号的，因为加引号的变量会变成字符串<br>如果变量两侧都有字符串拼接，口诀&#x3D;&#x3D;“引引加加 ”，删掉数字&#x3D;&#x3D;变量写加中间</p>
<h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><h3 id="转换为字符串"><a href="#转换为字符串" class="headerlink" title="转换为字符串"></a>转换为字符串</h3><table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
<th>案例</th>
</tr>
</thead>
<tbody><tr>
<td>toString()</td>
<td>转换为字符串</td>
<td>var num &#x3D; 1; alert(num.toString());</td>
</tr>
<tr>
<td>String()强制转换</td>
<td>转换为字符串</td>
<td>var num &#x3D; 1; alert(String(num));</td>
</tr>
<tr>
<td>加号拼接字符串</td>
<td>和字符串拼接的结果都是字符串</td>
<td>var num &#x3D; 1; alert(num + “我是字符串”);</td>
</tr>
</tbody></table>
<ol>
<li>toString()和String()使用方式不一样</li>
<li>三种转换方式,更喜欢用第三种加号拼接字符串转换方式，这一种方式也称之为隐式转换</li>
</ol>
<h3 id="转换为数字型（重点）"><a href="#转换为数字型（重点）" class="headerlink" title="转换为数字型（重点）"></a>转换为数字型（重点）</h3><table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
<th>案例</th>
</tr>
</thead>
<tbody><tr>
<td>parseInt(string)函数</td>
<td>将string类型转成整数数值型(可以用于去除单位)</td>
<td>parseInt(‘78’)</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 将string类型转成整数数值型</span><br><span class="line">var str = &#x27;10.32&#x27;;</span><br><span class="line">console.log(parseInt(str)); //10 取整</span><br><span class="line">// 可以用于去除单位</span><br><span class="line">console.log(parseInt(&#x27;12px&#x27;)); //12</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>parseFloat(string)函数</td>
<td>将string类型转成浮点数数值型(可以用于去除单位) parseFloat(‘78.21’)</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 将string类型转成浮点数数值型</span><br><span class="line">var str1 = &#x27;10.24&#x27;;</span><br><span class="line">console.log(parseFloat(str1)); //10.24</span><br><span class="line">// 可以用于去除单位</span><br><span class="line">console.log(parseFloat(&#x27;120px&#x27;)); //120</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
<th>案例</th>
</tr>
</thead>
<tbody><tr>
<td>Number强制转换函数</td>
<td>将string类型转换为数值型</td>
<td>Number(‘12’)</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 将string类型转换为数值型</span><br><span class="line">var str2 = &#x27;123&#x27;;</span><br><span class="line">console.log(Number(str2)); //123</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
<th>案例</th>
</tr>
</thead>
<tbody><tr>
<td>js隐式转换(- * &#x2F;)</td>
<td>利用算术运算隐式转换为数值</td>
<td>‘12’-0</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 利用算术运算隐式转换为数值</span><br><span class="line">console.log(&#x27;12&#x27; - 0); //12</span><br><span class="line">console.log(&#x27;120&#x27; / 10); //12</span><br><span class="line">console.log(&#x27;12&#x27; * 1); //12</span><br></pre></td></tr></table></figure>

<h3 id="转换为布尔型"><a href="#转换为布尔型" class="headerlink" title="转换为布尔型"></a>转换为布尔型</h3><table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
<th>案例</th>
</tr>
</thead>
<tbody><tr>
<td>boolean()函数</td>
<td>其他类型转成布尔型</td>
<td>Boolean(‘true’)</td>
</tr>
</tbody></table>
<ol>
<li>代表空、否定的值都会被转换为false，如’’、0、NaN、null、undefined</li>
<li>其余值都会被转换为true</li>
</ol>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><ol>
<li>运算符(operator)也被称为操作符,是用于实现赋值、比较和执行算数运算等功能的符号</li>
<li>JavaScript中常用的运算符有：<ol>
<li>算术运算符</li>
<li>递增和递减运算符</li>
<li>比较运算符</li>
<li>逻辑运算符</li>
<li>赋值运算符</li>
</ol>
</li>
</ol>
<h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><ol>
<li><p>概念：算术运算使用的符号，用于执行两个变量或值的算术运算</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>‘+’</td>
<td>加</td>
<td>10 + 20 &#x3D; 30</td>
</tr>
<tr>
<td>‘-‘</td>
<td>减</td>
<td>10 - 20 &#x3D; -10</td>
</tr>
<tr>
<td>‘*’</td>
<td>乘</td>
<td>10 * 20 &#x3D; 200</td>
</tr>
<tr>
<td>‘&#x2F;‘</td>
<td>除</td>
<td>10 &#x2F; 20 &#x3D; 0.5</td>
</tr>
<tr>
<td>‘%’</td>
<td>取余数(取模)</td>
<td>返回除法的余数</td>
</tr>
</tbody></table>
</li>
<li><p>表达式：由数字、运算符、变量等以能求得数值的有意义排列方法所得的组合</p>
</li>
</ol>
<h2 id="递增和递减运算符"><a href="#递增和递减运算符" class="headerlink" title="递增和递减运算符"></a>递增和递减运算符</h2><ol>
<li>递增（++）和递减（–）</li>
<li>在JavaScript中,递增(++)和递减(–)既可以放在变量前面,也可以放在变量后面<ol>
<li>放在变量前面时，称为前置递增(递减)运算符<ul>
<li>++num：先自增（自减），后返回值</li>
</ul>
</li>
<li>放在变量后面时，称为后置递增(递减)运算符<ul>
<li>num++：先返回值，后自增（自减）</li>
</ul>
</li>
</ol>
</li>
<li>递增和递减运算符必须和变量配合使用</li>
</ol>
<h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><ol>
<li><p>概念：比较运算符（关系运算符）是两个数据进行比较时所使用的运算符，比较运算后，会返回一个布尔值（true&#x2F;false）作为比较运算的结果</p>
<table>
<thead>
<tr>
<th>运算符名称</th>
<th>说明</th>
<th>案例</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>‘&lt;’</td>
<td>小于</td>
<td>1 &lt; 2</td>
<td>true</td>
</tr>
<tr>
<td>‘&gt;’</td>
<td>大于</td>
<td>1 &gt; 2</td>
<td>false</td>
</tr>
<tr>
<td>‘&gt;&#x3D;’</td>
<td>大于等于</td>
<td>2 &gt;&#x3D; 2</td>
<td>true</td>
</tr>
<tr>
<td>‘&lt;&#x3D;’</td>
<td>小于等于</td>
<td>3 &lt;&#x3D; 2</td>
<td>false</td>
</tr>
<tr>
<td>‘&#x3D;&#x3D;’</td>
<td>判等（会转型）</td>
<td>37 &#x3D;&#x3D; 37</td>
<td>true</td>
</tr>
<tr>
<td>‘!&#x3D;’</td>
<td>不等于</td>
<td>37 !&#x3D; 37</td>
<td>false</td>
</tr>
<tr>
<td>‘&#x3D;&#x3D;&#x3D; !&#x3D;&#x3D;’</td>
<td>全等（要求值和数据类型都一致）</td>
<td>37 &#x3D;&#x3D;&#x3D; ‘37’</td>
<td>false</td>
</tr>
</tbody></table>
</li>
<li><p>小结</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D; 赋值</td>
<td>把右边给左边</td>
<td></td>
</tr>
<tr>
<td>&#x3D;&#x3D;</td>
<td>判断</td>
<td>判断两边值是否相等（注意此时有隐式转换）</td>
</tr>
<tr>
<td>&#x3D;&#x3D;&#x3D;</td>
<td>全等</td>
<td>判断两边的值和数据类型是否完全相等</td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><ol>
<li>概念：逻辑运算符是用来进行布尔值运算的运算符,其返回值是布尔值；后面开发中经常用于多个条件的判断<ol>
<li>&amp;&amp;：”逻辑与”，简称”与” and（一假则假，全真为真）</li>
<li>||：”逻辑或”，简称”或” or（一真则真，全假为假 ）</li>
<li>!（取反符）：”逻辑非”，简称”非” not</li>
</ol>
</li>
</ol>
<h3 id="短路运算（逻辑中断重点）"><a href="#短路运算（逻辑中断重点）" class="headerlink" title="短路运算（逻辑中断重点）"></a>短路运算（逻辑中断重点）</h3><ol>
<li>短路运算原理：当有多个表达式（值）时，左边的表达式值可以确定结果时，就不再继续运算右边的表达式的值</li>
<li>逻辑与短路运算<ol>
<li>语法：表达式1 &amp;&amp; 表达式2<ul>
<li>如果第一个表达式的值为真，则返回表达式2</li>
<li>如果第一个表达式的值为假，则返回表达式1</li>
</ul>
</li>
</ol>
</li>
<li>逻辑或短路运算<ol>
<li>语法：表达式1 || 表达式2<ul>
<li>如果第一个表达式的值为真，则返回表达式1</li>
<li>如果第一个表达式的值为假，则返回表达式2</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><ol>
<li>基本赋值运算符：&#x3D;</li>
<li>扩展的赋值运算符：+&#x3D;，-&#x3D;，*&#x3D;，&#x2F;&#x3D;，%&#x3D;</li>
<li>先执行等号右边再赋值给左边</li>
</ol>
<h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><table>
<thead>
<tr>
<th>优先级</th>
<th>运算符</th>
<th>顺序</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>小括号</td>
<td>()</td>
</tr>
<tr>
<td>2</td>
<td>一元运算符</td>
<td>++ – !</td>
</tr>
<tr>
<td>3</td>
<td>算术运算符</td>
<td>先* &#x2F; %，后+ -</td>
</tr>
<tr>
<td>4</td>
<td>关系运算符</td>
<td>&gt; &gt;&#x3D; &lt; &lt;&#x3D;</td>
</tr>
<tr>
<td>5</td>
<td>相等运算符</td>
<td>&#x3D;&#x3D; !&#x3D; &#x3D;&#x3D;&#x3D; !&#x3D;&#x3D;</td>
</tr>
<tr>
<td>6</td>
<td>逻辑运算符</td>
<td>先&amp;&amp;，后</td>
</tr>
<tr>
<td>7</td>
<td>赋值运算符</td>
<td>&#x3D;</td>
</tr>
<tr>
<td>8</td>
<td>逗号运算符</td>
<td>,</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript流程控制</title>
    <url>/2022/08/01/JavaScript%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><ol>
<li>流程控制主要有三种结构，分别是顺序结构、分支结构和循环结构，这三种结构代表三种代码执行的顺序<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20210925011108.png" alt="img"></li>
</ol>
<h1 id="流程控制-顺序结构"><a href="#流程控制-顺序结构" class="headerlink" title="流程控制-顺序结构"></a>流程控制-顺序结构</h1><ol>
<li>顺序结构是程序中最简单、最基本的流程控制，它没有特定的语法结构，程序会按照代码的先后顺序，依次执行，程序中大多数的代码都是这样执行的</li>
</ol>
<h1 id="流程控制-分支结构"><a href="#流程控制-分支结构" class="headerlink" title="流程控制-分支结构"></a>流程控制-分支结构</h1><ol>
<li>由上到下执行代码的过程中，根据不同的条件，执行不同的路径代码(执行代码多选一的过程 ) ，从而得到不同的结果</li>
</ol>
<h2 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h2><h3 id="if分支语句"><a href="#if分支语句" class="headerlink" title="if分支语句"></a>if分支语句</h3><ol>
<li><p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (条件表达式) &#123;</span><br><span class="line">  //执行语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行思路：</p>
<ol>
<li>若if条件表达式结果为真（true）则执行大括号里面的执行语句</li>
<li>若if条件表达式结果为假（false）则不执行大括号里面的语句，执行if语句后面的代码</li>
</ol>
</li>
</ol>
<h3 id="if…else…双分支语句"><a href="#if…else…双分支语句" class="headerlink" title="if…else…双分支语句"></a>if…else…双分支语句</h3><ol>
<li><p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (条件表达式) &#123;</span><br><span class="line">  //执行语句1</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  //执行语句2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行思路：</p>
<ol>
<li>若条件表达式结果为真（true）则执行语句1</li>
<li>若条件表达式结果为假（false）则执行语句2</li>
</ol>
</li>
</ol>
<h3 id="if…else-if-…-else…多分支语句"><a href="#if…else-if-…-else…多分支语句" class="headerlink" title="if…else if … else…多分支语句"></a>if…else if … else…多分支语句</h3><ol>
<li><p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (条件表达式1) &#123;</span><br><span class="line">  //执行语句1</span><br><span class="line">&#125; else if (条件表达式2) &#123;</span><br><span class="line">  //执行语句2</span><br><span class="line">&#125; else if (条件表达式3) &#123;</span><br><span class="line">  //执行语句3</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  //执行语句4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><ol>
<li>语法<ul>
<li>条件表达式 ? 表达式1 : 表达式2；</li>
</ul>
</li>
<li>执行思路<ol>
<li>若条件表达式结果为真（true）则执行表达式1</li>
<li>若条件表达式结果为假（false）则执行表达式2</li>
</ol>
</li>
</ol>
<h2 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h2><ol>
<li><p>switch语句也是多分支语句，它用于基于不同的条件来执行不同的代码；当要针对变量设置一系列特定值的选项时，就可以使用switch</p>
</li>
<li><p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">switch (条件表达式) &#123;</span><br><span class="line">  case value1:</span><br><span class="line">    执行语句1;</span><br><span class="line">    break;</span><br><span class="line">  case value1:</span><br><span class="line">    执行语句1;</span><br><span class="line">    break;</span><br><span class="line">  ..</span><br><span class="line">  default:</span><br><span class="line">    执行最后的语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>代码演示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  switch (2) &#123;</span><br><span class="line">    case 1:</span><br><span class="line">        console.log(&#x27;这是1&#x27;);</span><br><span class="line">        break;</span><br><span class="line">    case 2:</span><br><span class="line">        console.log(&#x27;这是2&#x27;);</span><br><span class="line">        break;</span><br><span class="line">    case 3:</span><br><span class="line">        console.log(&#x27;这是3&#x27;);</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        console.log(&#x27;无&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>switch：转换，开关；case：小例子，选项</p>
</li>
<li><p>条件表达式的值和case里面的值相匹配时必须是全等（数据类型和值必须一致）</p>
</li>
</ol>
<h3 id="switch语句和if…else-if-…-else…多分支语句"><a href="#switch语句和if…else-if-…-else…多分支语句" class="headerlink" title="switch语句和if…else if … else…多分支语句"></a>switch语句和if…else if … else…多分支语句</h3><ol>
<li>一般情况下，两个语句可以互相替换</li>
<li>switch..case语句通常处理case为比较确定值的情况，而if..else..语句更加灵活，常用于范围判断（大于、等于某个范围）</li>
<li>switch语句进行条件判断后直接执行到程序的条件语句，效率更高；而if.. .else语句有几种条件，就得判断多少次</li>
<li>当分支比较少时，if.. else语句的执行效率比switch语句高</li>
<li>当分支比较多时，switch语句的执行效率比较高，而且结构更清晰</li>
</ol>
<h1 id="流程控制-循环结构（重点）"><a href="#流程控制-循环结构（重点）" class="headerlink" title="流程控制-循环结构（重点）"></a>流程控制-循环结构（重点）</h1><ol>
<li>循环的目的：重复执行某些代码</li>
<li>一组被重复执行的语句被称之为循环体，能否继续重复执行，取决于循环的终止条件</li>
<li>由循环体及循环的终止条件组成的语句，被称之为循环语句</li>
</ol>
<h2 id="for循环与双重for循环"><a href="#for循环与双重for循环" class="headerlink" title="for循环与双重for循环"></a>for循环与双重for循环</h2><h3 id="语法结构"><a href="#语法结构" class="headerlink" title="语法结构"></a>语法结构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (初始化变量; 条件表达式; 操作表达式) &#123;</span><br><span class="line">  //循环体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>执行顺序：<ol>
<li>初始化变量 –&gt; 条件表达式（判断：true） –&gt; 循环体 –&gt; 操作表达式 –&gt; 条件表达式（判断）</li>
<li>初始化变量 –&gt; 条件表达式（判断 false） –&gt; 退出循环</li>
</ol>
</li>
<li>初始化变量：通常用于作为计数器使用</li>
<li>条件表达式：终止的条件</li>
<li>操作表达式：用于更新计数器变量</li>
</ol>
<h3 id="断点调试"><a href="#断点调试" class="headerlink" title="断点调试"></a>断点调试</h3><ol>
<li>断点调试可以观察程序的运行过程</li>
<li>浏览器中按F12 –&gt; sources –&gt; 找到需要调试的文件 –&gt; 在程序的某一行设置断点</li>
<li>watch：监视，通过watch可以监视变量的值的变化，非常的常用</li>
<li>F11：程序单步执行，让程序一行行的执行，这个时候，观察watch中变量的值的变化</li>
</ol>
<h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while (条件表达式) &#123;</span><br><span class="line">  //循环体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>执行思路<ol>
<li>先执行条件表达式，如果结果为true，则执行循环体代码；如果为false，则退出循环，执行后面代码</li>
<li>执行循环体代码</li>
<li>循环体代码执行完毕后，程序会继续判断执行条件表达式，如条件仍为true，则会继续执行循环体，直到循环条件为false时，整个循环过程才会结束</li>
</ol>
</li>
</ol>
<h2 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do while循环"></a>do while循环</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">  //循环体代码</span><br><span class="line">&#125; while(条件表达式);</span><br></pre></td></tr></table></figure>

<ol>
<li>执行思路<ol>
<li>先执行一次循环体代码</li>
<li>再执行条件表达式，如果结果为true，则继续执行循环体代码，如果为false，则退出循环，继续执行后面代码</li>
</ol>
</li>
<li>注意：先再执行循环体，再判断，do…while循环语句至少会执行一次循环体代码</li>
</ol>
<h2 id="continue关键字"><a href="#continue关键字" class="headerlink" title="continue关键字"></a>continue关键字</h2><ol>
<li>continue关键字用于立即跳出本次循环，继续下一次循环（本次循环体中continue之后的代码就会少执行一次）</li>
</ol>
<h2 id="break关键字"><a href="#break关键字" class="headerlink" title="break关键字"></a>break关键字</h2><ol>
<li>break关键字用于立即跳出整个循环（循环结束）</li>
</ol>
<h2 id="arguments的使用"><a href="#arguments的使用" class="headerlink" title="arguments的使用"></a>arguments的使用</h2><ol>
<li><p>当不确定有多少个参数传递的时候，可以用arguments来获取</p>
</li>
<li><p>在JavaScript中，arguments实际上它是当前函数的一个内置对象。所有函数都内置了一个arguments对象，arguments对象中存储了传递的所有实参</p>
</li>
<li><p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function fn() &#123;</span><br><span class="line">  console.log(arguments); //里面存储量所有传递过来的实参</span><br><span class="line">&#125;</span><br><span class="line">fn(1, 2, 3);</span><br></pre></td></tr></table></figure>
</li>
<li><p>arguments展示形式是一个伪数组，因此可以进行遍历；伪数组具有以下特点</p>
<ol>
<li><p>具有length属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(arguments.length);</span><br></pre></td></tr></table></figure>
</li>
<li><p>按索引方式存储数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(arguments[2]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>不具有真正数组的push()，pop()等方法</p>
</li>
</ol>
</li>
<li><p>只有函数才有arguments对象而且是每个函数都内置好了这个arguments</p>
</li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript数组</title>
    <url>/2022/08/01/JavaScript%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="数组的创建"><a href="#数组的创建" class="headerlink" title="数组的创建"></a>数组的创建</h2><ol>
<li>数组（Array）：一组数据的集合</li>
<li>数组里面的数据要用逗号进行分隔</li>
<li>数组中可以存放任意类型的数据，例如字符串，数字，布尔值等</li>
<li>JS中创建数组有两种方式</li>
</ol>
<h3 id="利用new创建数组"><a href="#利用new创建数组" class="headerlink" title="利用new创建数组"></a>利用new创建数组</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = new Array();</span><br></pre></td></tr></table></figure>

<h3 id="利用数组字面量创建数组（常用）"><a href="#利用数组字面量创建数组（常用）" class="headerlink" title="利用数组字面量创建数组（常用）"></a>利用数组字面量创建数组（常用）</h3><ol>
<li><p>[]：表示数组的字面量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [];</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="获取数组元素"><a href="#获取数组元素" class="headerlink" title="获取数组元素"></a>获取数组元素</h2><ol>
<li>数组的索引<ol>
<li>索引（下标）：用来访问数组元素的序号（数组下标从0开始）</li>
<li>数组可以通过索引来访问、设置、修改对应的数组元素，可以通过<code>数组名[索引]</code>的形式来获取数组中的元素</li>
</ol>
</li>
</ol>
<h3 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h3><ol>
<li>遍历数组：把数组的元素从头到尾访问一次</li>
</ol>
<h3 id="数组长度"><a href="#数组长度" class="headerlink" title="数组长度"></a>数组长度</h3><ol>
<li>使用“数组名.length”可以访问数组元素的数量（数组长度）</li>
<li>arr.length动态监测数组元素的个数</li>
</ol>
<h2 id="数组中新增元素"><a href="#数组中新增元素" class="headerlink" title="数组中新增元素"></a>数组中新增元素</h2><h3 id="修改length长度"><a href="#修改length长度" class="headerlink" title="修改length长度"></a>修改length长度</h3><ol>
<li><p>通过修改length长度来实现数组扩容目的</p>
</li>
<li><p>length属性是可读写的</p>
</li>
<li><p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arr.length = 数组长度;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="修改索引号"><a href="#修改索引号" class="headerlink" title="修改索引号"></a>修改索引号</h3><ol>
<li><p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [1, 2, 3];</span><br><span class="line">arr[3] = 4;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过追加索引号，并为该索引号对应的元素赋值的方式新增元素</p>
</li>
<li><p>若索引号为已经存在，赋值则替换原来该索引位置的数组元素</p>
</li>
<li><p>不能直接给数组名赋值，否则会覆盖掉以前的数据</p>
</li>
</ol>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [2, 5, 11, 85, 3, 16, 24, 9, 7];</span><br><span class="line">  for (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">    for (var j = 0; j &lt; arr.length - 1 - i; j++) &#123;</span><br><span class="line">      if (arr[j] &lt; arr[j + 1]) &#123;</span><br><span class="line">        var temp = arr[j];</span><br><span class="line">        arr[j] = arr[j + 1];</span><br><span class="line">        arr[j + 1] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript对象</title>
    <url>/2022/08/01/JavaScript%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="什么是对象"><a href="#什么是对象" class="headerlink" title="什么是对象"></a>什么是对象</h2><ol>
<li>对象是一个具体的事物</li>
<li>在JavaScript中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象，例如字符串、数值、数组、函数等</li>
<li>对象是由属性和方法组成的<ol>
<li>属性：事物的特征，在对象中用属性来表示（常用名词）</li>
<li>方法：事物的行为，在对象中用方法来表示（常用动词）</li>
</ol>
</li>
</ol>
<h2 id="创建对象的三种方式"><a href="#创建对象的三种方式" class="headerlink" title="创建对象的三种方式"></a>创建对象的三种方式</h2><h3 id="利用字面量创建对象"><a href="#利用字面量创建对象" class="headerlink" title="利用字面量创建对象"></a>利用字面量创建对象</h3><ol>
<li><p>{}：表示对象的字面量，包含了表达这个具体事物（对象）的属性和方法</p>
</li>
<li><p>语法</p>
<ol>
<li><p>var obj &#x3D; {}; &#x2F;&#x2F; 创建了一个空的对象</p>
</li>
<li><p>&#96;&#96;&#96;<br>var obj &#x3D; { &#x2F;&#x2F; 创建一个对象<br>  userName: ‘张三’, &#x2F;&#x2F; 创建属性<br>  age: 16,<br>  sex: ‘男’;<br>  sayHi: function() { &#x2F;&#x2F; 创建方法，该函数为匿名函数<br>console.log(‘hi~’);<br>  }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      - 里面的属性或者方法采取键值对的形式，键：属性名，值：属性值</span><br><span class="line">      - 多个属性或方法中间用逗号隔开</span><br><span class="line">      - 方法冒号后面跟的是一个匿名函数</span><br><span class="line"></span><br><span class="line">### 利用new Object创建对象</span><br><span class="line"></span><br><span class="line">1. 语法</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>var obj &#x3D; new Object(); &#x2F;&#x2F;创建了一个空的对象<br>obj.uname &#x3D; ‘张三’; &#x2F;&#x2F;添加属性<br>obj.age &#x3D; 16;<br>obj.sex &#x3D; ‘男’;<br>obj.sayHi &#x3D; function() { &#x2F;&#x2F;添加方法<br>  console.log(‘hi~’);<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. 利用等号”=”赋值的方法，添加对象的属性和方法</span><br><span class="line"></span><br><span class="line">3. 每个属性和 方法之间用分号结束</span><br><span class="line"></span><br><span class="line">### 利用构造函数创建对象</span><br><span class="line"></span><br><span class="line">1. 构造函数：一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与new运算符一起使用；把对象里面的一些相同的属性和方法抽象出来封装到函数内部</span><br><span class="line"></span><br><span class="line">2. 语法格式</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>function 构造函数名(形参) {<br>  this.属性 &#x3D; 值;<br>  this.方法 &#x3D; function() {};<br>}<br>new 构造函数名(实参);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   1. 构造函数名字首字母要大写</span><br><span class="line">   2. 构造函数不需要return，就可以返回结果</span><br><span class="line">   3. 调用构造函数，必须使用new</span><br><span class="line">   4. 只要调用一次构造函数，就创建一个对象</span><br><span class="line">   5. 属性和方法钱前必须添加this</span><br><span class="line"></span><br><span class="line">## 使用对象</span><br><span class="line"></span><br><span class="line">### 调用对象的属性</span><br><span class="line"></span><br><span class="line">1. 方法一：对象名.属性名</span><br><span class="line"></span><br><span class="line">   1. 语法</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>obj.userName;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. 方法二：对象名[&#x27;属性名&#x27;]</span><br><span class="line"></span><br><span class="line">   1. 语法</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>obj[‘age’];</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 调用对象的方法</span><br><span class="line"></span><br><span class="line">1. 语法</span><br><span class="line">   - 对象名.方法名();</span><br><span class="line">2. 对象里面的方法和属性调用：对象名.方法名()，这个小点’.’，就理解为”的”</span><br><span class="line"></span><br><span class="line">## 构造函数和对象</span><br><span class="line"></span><br><span class="line">1. 构造函数，抽象了对象的公共部分，封装到函数里面，泛指某一大类</span><br><span class="line">2. 创建对象，特指某一个，通过new关键字创建对象的过程称为对象实例化</span><br><span class="line"></span><br><span class="line">## new关键字</span><br><span class="line"></span><br><span class="line">1. new在执行时会做四件事情</span><br><span class="line">   1. 在内存中创建一个新的空对象</span><br><span class="line">   2. 让this指向这个新的对象</span><br><span class="line">   3. 执行构造函数里面的代码，给这个对象添加属性和方法</span><br><span class="line">   4. 返回这个新对象（所以构造函数里面不需要return）</span><br><span class="line">2. 形象记忆</span><br><span class="line">   ![img](https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20210925020409.png)</span><br><span class="line"></span><br><span class="line">## 遍历对象属性</span><br><span class="line"></span><br><span class="line">## for..in语句</span><br><span class="line"></span><br><span class="line">1. for..in语句用于对数组或者对象的属性进行循环操作（遍历对象）</span><br><span class="line"></span><br><span class="line">2. 语法</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>for (变量 in 对象) {<br>  ..<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. 演示</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<script>
  var dog = {
 name: '煤球',
 type: '拉布拉多',
 age: '3岁',
 color: '米白色',
  }</li>
</ol>
<p>  for (var k in dog) {<br>    console.log(k); &#x2F;&#x2F; k为变量，输出的是属性名<br>    console.log(dog[k]); &#x2F;&#x2F; dog[k]输出的是属性值<br>  }<br>  &#x2F;&#x2F; for..in中的变量习惯性写k或者是key<br></script><p></p>
<pre><code>
</code></pre>
</li>
<li><p>k为变量，输出的是属性名</p>
</li>
<li><p><code>dog[k]</code>输出的是属性值</p>
</li>
<li><p>for..in中的变量习惯性写k或者是key</p>
</li>
</ol>
<h2 id="变量、属性、函数、方法总结"><a href="#变量、属性、函数、方法总结" class="headerlink" title="变量、属性、函数、方法总结"></a>变量、属性、函数、方法总结</h2><ol>
<li>变量：单独声明赋值，单独存在</li>
<li>属性：对象里面的变量称为属性，不需要声明，用来描述该对象的特征</li>
<li>函数：单独存在的，通过”函数名()”的方式就可以调用</li>
<li>方法：对象里面的函数称为方法，方法不需要声明，使用”对象.方法名()”的方式就可以调用，方法用来描述该对象的行为和功能</li>
</ol>
</li></ol>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js</title>
    <url>/2022/08/02/Node-js/</url>
    <content><![CDATA[<h1 id="Node-js基础"><a href="#Node-js基础" class="headerlink" title="Node.js基础"></a>Node.js基础</h1><p><a href="https://nodejs.org/en/">官网传送门(opens new window)</a></p>
<h2 id="初识Node-js"><a href="#初识Node-js" class="headerlink" title="初识Node.js"></a>初识Node.js</h2><blockquote>
<p>Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine</p>
<p>Node.js®是一个基于 Chrome V8 引擎 的 JavaScript 运行时环境</p>
</blockquote>
<ul>
<li>基于 <a href="http://www.expressjs.com.cn/">Express 框架 (opens new window)</a>，可以快速构建 Web 应用</li>
<li>基于 <a href="https://electronjs.org/">Electron 框架 (opens new window)</a>，可以构建跨平台的桌面应用</li>
<li>基于 <a href="http://restify.com/">restify 框架 (opens new window)</a>，可以快速构建 API 接口项目</li>
<li>读写和操作数据库、创建实用的命令行工具辅助前端开发、etc…</li>
</ul>
<h2 id="Buffer缓冲区"><a href="#Buffer缓冲区" class="headerlink" title="Buffer缓冲区"></a>Buffer缓冲区</h2><blockquote>
<p><a href="http://nodejs.cn/api/buffer.html">Buffer 缓冲区文档(opens new window)</a></p>
</blockquote>
<ul>
<li>Buffer 的结构与数组类似，操作方法也与数组类似</li>
<li>数组不能存储二进制文件，Buffer 是专门存储二进制数据的</li>
<li>Buffer 存储的是二进制数据，显示时以 16 进制的形式显示</li>
<li>Buffer 每一个元素范围是 00<del>ff，即 0</del>255、00000000~11111111</li>
<li>每一个元素占用一个字节内存</li>
<li>Buffer 是对底层内存的直接操作，因此大小一旦确定就不能修改</li>
</ul>
<p>Buffer常用方法：</p>
<ul>
<li><code>Buffer.from(str[, encoding])</code>：将一个字符串转换为 Buffer</li>
<li><code>Buffer.alloc(size)</code>：创建指定大小的 Buffer</li>
<li><code>Buffer.alloUnsafe(size)</code>：创建指定大小的 Buffer，可能包含敏感数据（分配内存时不会清除内存残留的数据）</li>
<li><code>buf.toString()</code>：将 Buffer 数据转为字符串</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var str = &#x27;Hello前端&#x27;</span><br><span class="line"></span><br><span class="line">var buf = Buffer.from(str)</span><br><span class="line"></span><br><span class="line">// 占用内存的大小，一个汉字3字节 13</span><br><span class="line">console.log(buf.length)</span><br><span class="line">// 字符串的长度 7</span><br><span class="line">console.log(str.length)</span><br><span class="line">// 8进制输出第一个元素 145</span><br><span class="line">console.log(buf[1].toString(8))</span><br><span class="line"></span><br><span class="line">//创建一个10个字节的buffer</span><br><span class="line">var buf2 = Buffer.alloc(10)</span><br><span class="line">//通过索引，来操作buf中的元素</span><br><span class="line">buf2[0] = 88</span><br><span class="line">buf2[1] = 255</span><br><span class="line">buf2[2] = 0xaa</span><br><span class="line">buf2[3] = 255</span><br><span class="line"></span><br><span class="line">var buf3 = Buffer.allocUnsafe(10)</span><br><span class="line">console.log(buf3)</span><br></pre></td></tr></table></figure>


<h2 id="fs文件系统模块"><a href="#fs文件系统模块" class="headerlink" title="fs文件系统模块"></a>fs文件系统模块</h2><ul>
<li>fs 模块中所有的操作都有两种形式可供选择:同步和异步</li>
<li>同步文件系统会阻塞程序的执行，也就是除非操作完毕，否则不会向下执行代码</li>
<li>异步文件系统不会阻塞程序的执行，而是在操作完成时，通过回调函数将结果返回</li>
<li>实际开发很少用同步方式，因此只介绍异步方式</li>
</ul>
<p>打开模式：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>读取文件，文件不存在抛异常</td>
</tr>
<tr>
<td>r+</td>
<td>读写文件，文件不存在抛异常</td>
</tr>
<tr>
<td>rs</td>
<td>同步模式下打开文件用于读取</td>
</tr>
<tr>
<td>rs+</td>
<td>同步模式下打开文件用于读写</td>
</tr>
<tr>
<td>w</td>
<td>写文件，不存在则创建，存在则覆盖原有内容</td>
</tr>
<tr>
<td>wx</td>
<td>写文件，文件存在打开失败</td>
</tr>
<tr>
<td>w+</td>
<td>读写文件，不存在创建，存在截断</td>
</tr>
<tr>
<td>wx+</td>
<td>读写，存在打开失败</td>
</tr>
<tr>
<td>a</td>
<td>追加，不存在创建</td>
</tr>
<tr>
<td>ax</td>
<td>追加，存在失败</td>
</tr>
<tr>
<td>a+</td>
<td>追加和读取，不存在创建</td>
</tr>
<tr>
<td>ax+</td>
<td>追加和读取，存在失败</td>
</tr>
</tbody></table>
<h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><h4 id="简单文件读取"><a href="#简单文件读取" class="headerlink" title="简单文件读取"></a>简单文件读取</h4><p>语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fs.readFile(path[, options], callback)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>path</code>：文件路径</p>
</li>
<li><p>&#96;&#96;&#96;<br>options</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  ：配置选项，若是字符串则指定编码格式</span><br><span class="line"></span><br><span class="line">  - `encoding`：编码格式</span><br><span class="line">  - `flag`：打开方式</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  callback</span><br></pre></td></tr></table></figure>

<p>：回调函数</p>
<ul>
<li><code>err</code>：错误信息</li>
<li><code>data</code>：读取的数据，如果未指定编码格式则返回一个 Buffer</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./files/1.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>, <span class="keyword">function</span>(<span class="params">err, data</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span>(err) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;failed!&#x27;</span> + err.<span class="property">message</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;content:&#x27;</span> + data)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制文件内容</span></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&quot;C:/Users/笔记.mp3&quot;</span>, <span class="keyword">function</span>(<span class="params">err, data</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span>(!err) &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">		<span class="comment">// 将data写入到文件中</span></span><br><span class="line">		fs.<span class="title function_">writeFile</span>(<span class="string">&quot;C:/Users/hello.jpg&quot;</span>, data, <span class="keyword">function</span>(<span class="params">err</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(!err)&#123;</span><br><span class="line">				<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;文件写入成功&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h4 id="流式文件读取"><a href="#流式文件读取" class="headerlink" title="流式文件读取"></a>流式文件读取</h4><ul>
<li>简单文件读取的方式会一次性读取文件内容到内存中，若文件较大，会占用过多内存影响系统性能，且读取速度慢</li>
<li>大文件适合用流式文件读取，它会分多次将文件读取到内存中</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var fs = require(&#x27;fs&#x27;)</span><br><span class="line"></span><br><span class="line">// 创建一个可读流</span><br><span class="line">var rs = fs.createReadStream(&#x27;C:/Users/笔记.mp3&#x27;)</span><br><span class="line">// 创建一个可写流</span><br><span class="line">var ws = fs.createWriteStream(&#x27;a.mp3&#x27;)</span><br><span class="line"></span><br><span class="line">// 监听流的开启和关闭</span><br><span class="line">// 这几个监听不是必须的</span><br><span class="line">rs.once(&#x27;open&#x27;, function () &#123;</span><br><span class="line">  console.log(&#x27;可读流打开了~~&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">rs.once(&#x27;close&#x27;, function () &#123;</span><br><span class="line">  console.log(&#x27;可读流关闭了~~&#x27;)</span><br><span class="line">  //数据读取完毕，关闭可写流</span><br><span class="line">  ws.end()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">ws.once(&#x27;open&#x27;, function () &#123;</span><br><span class="line">  console.log(&#x27;可写流打开了~~&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">ws.once(&#x27;close&#x27;, function () &#123;</span><br><span class="line">  console.log(&#x27;可写流关闭了~~&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//要读取一个可读流中的数据，要为可读流绑定一个data事件，data事件绑定完毕自动开始读取数据</span><br><span class="line">rs.on(&#x27;data&#x27;, function (data) &#123;</span><br><span class="line">  console.log(data)</span><br><span class="line">  //将读取到的数据写入到可写流中</span><br><span class="line">  ws.write(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>简便方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var fs = require(&#x27;fs&#x27;)</span><br><span class="line"></span><br><span class="line">var rs = fs.createReadStream(&#x27;C:/Users/lilichao/Desktop/笔记.mp3&#x27;)</span><br><span class="line">var ws = fs.createWriteStream(&#x27;b.mp3&#x27;)</span><br><span class="line"></span><br><span class="line">// pipe()可以将可读流中的内容，直接输出到可写流中</span><br><span class="line">rs.pipe(ws)</span><br></pre></td></tr></table></figure>



<h3 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h3><h4 id="简单文件写入"><a href="#简单文件写入" class="headerlink" title="简单文件写入"></a>简单文件写入</h4><p>语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fs.writeFile(file, data[, options], callback)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>file</code>：文件路径</li>
<li><code>data</code>：写入内容</li>
<li><code>options</code>：配置选项，包含 <code>encoding, mode, flag</code>；若是字符串则指定编码格式</li>
<li><code>callback</code>：回调函数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const fs = require(&#x27;fs&#x27;)</span><br><span class="line">fs.writeFile(&#x27;./files/2.txt&#x27;, &#x27;Hello Nodejs&#x27;, function (err) &#123;</span><br><span class="line">  if (err) &#123;</span><br><span class="line">    return console.log(&#x27;failed!&#x27; + err.message)</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(&#x27;success!&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fs.writeFile(&#x27;C:/Users/hello.txt&#x27;, &#x27;通过 writeFile 写入的内容&#x27;, &#123; flag: &#x27;w&#x27; &#125;, function (err) &#123;</span><br><span class="line">  if (!err) &#123;</span><br><span class="line">    console.log(&#x27;写入成功！&#x27;)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.log(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h4 id="流式文件写入"><a href="#流式文件写入" class="headerlink" title="流式文件写入"></a>流式文件写入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 同步、异步、简单文件的写入都不适合大文件的写入，性能较差，容易导致内存溢出</span><br><span class="line">var fs = require(&#x27;fs&#x27;)</span><br><span class="line"></span><br><span class="line">// 创建一个可写流</span><br><span class="line">var ws = fs.createWriteStream(&#x27;hello3.txt&#x27;)</span><br><span class="line"></span><br><span class="line">ws.once(&#x27;open&#x27;, function () &#123;</span><br><span class="line">  console.log(&#x27;流打开了~~&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">ws.once(&#x27;close&#x27;, function () &#123;</span><br><span class="line">  console.log(&#x27;流关闭了~~&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 通过ws向文件中输出内容</span><br><span class="line">ws.write(&#x27;通过可写流写入文件的内容&#x27;)</span><br><span class="line">ws.write(&#x27;1&#x27;)</span><br><span class="line">ws.write(&#x27;2&#x27;)</span><br><span class="line">ws.write(&#x27;3&#x27;)</span><br><span class="line">ws.write(&#x27;4&#x27;)</span><br><span class="line"></span><br><span class="line">// 关闭流</span><br><span class="line">ws.end()</span><br></pre></td></tr></table></figure>



<h3 id="路径动态拼接问题-dirname"><a href="#路径动态拼接问题-dirname" class="headerlink" title="路径动态拼接问题__dirname"></a>路径动态拼接问题<code>__dirname</code></h3><ul>
<li>在使用 fs 模块操作文件时，如果提供的操作路径是以 <code>./</code> 或 <code>../</code> 开头的相对路径时，容易出现路径动态拼接错误的问题</li>
<li>原因：代码在运行的时候，会以执行 node 命令时所处的目录，动态拼接出被操作文件的完整路径</li>
<li>解决方案：在使用 fs 模块操作文件时，直接提供完整的路径，从而防止路径动态拼接的问题</li>
<li><code>__dirname</code> 获取文件所处的绝对路径</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fs.readFile(__dirname + &#x27;/files/1.txt&#x27;, &#x27;utf8&#x27;, function(err, data) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="其它操作"><a href="#其它操作" class="headerlink" title="其它操作"></a>其它操作</h3><p>验证路径是否存在：</p>
<ul>
<li><code>fs.exists(path, callback)</code></li>
<li><code>fs.existsSync(path)</code></li>
</ul>
<p>获取文件信息：</p>
<ul>
<li><code>fs.stat(path, callback)</code></li>
<li><code>fs.stat(path)</code></li>
</ul>
<p>删除文件：</p>
<ul>
<li><code>fs.unlink(path, callback)</code></li>
<li><code>fs.unlinkSync(path)</code></li>
</ul>
<p>列出文件：</p>
<ul>
<li><code>fs.readdir(path[,options], callback)</code></li>
<li><code>fs.readdirSync(path[, options])</code></li>
</ul>
<p>截断文件：</p>
<ul>
<li><code>fs.truncate(path, len, callback)</code></li>
<li><code>fs.truncateSync(path, len)</code></li>
</ul>
<p>建立目录：</p>
<ul>
<li><code>fs.mkdir(path[, mode], callback)</code></li>
<li><code>fs.mkdirSync(path[, mode])</code></li>
</ul>
<p>删除目录：</p>
<ul>
<li><code>fs.rmdir(path, callback)</code></li>
<li><code>fs.rmdirSync(path)</code></li>
</ul>
<p>重命名文件和目录：</p>
<ul>
<li><code>fs.rename(oldPath, newPath, callback)</code></li>
<li><code>fs.renameSync(oldPath, newPath)</code></li>
</ul>
<p>监视文件更改：</p>
<ul>
<li><code>fs.watchFile(filename[, options], listener)</code></li>
</ul>
<h2 id="path路径模块"><a href="#path路径模块" class="headerlink" title="path路径模块"></a>path路径模块</h2><p>path 模块是 Node.js 官方提供的、用来处理路径的模块。它提供了一系列的方法和属性，用来满足用户对路径的处理需求。</p>
<h3 id="路径拼接path-join"><a href="#路径拼接path-join" class="headerlink" title="路径拼接path.join()"></a>路径拼接<code>path.join()</code></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;)</span><br><span class="line">const fs = require(&#x27;fs&#x27;)</span><br><span class="line"></span><br><span class="line">// 注意 ../ 会抵消前面的路径</span><br><span class="line">// ./ 会被忽略</span><br><span class="line">const pathStr = path.join(&#x27;/a&#x27;, &#x27;/b/c&#x27;, &#x27;../../&#x27;, &#x27;./d&#x27;, &#x27;e&#x27;)</span><br><span class="line">console.log(pathStr) // \a\d\e</span><br><span class="line"></span><br><span class="line">fs.readFile(path.join(__dirname, &#x27;./files/1.txt&#x27;), &#x27;utf8&#x27;, function (err, dataStr) &#123;</span><br><span class="line">  if (err) &#123;</span><br><span class="line">    return console.log(err.message)</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(dataStr)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<h3 id="获取路径中文件名path-basename"><a href="#获取路径中文件名path-basename" class="headerlink" title="获取路径中文件名path.basename()"></a>获取路径中文件名<code>path.basename()</code></h3><p>使用 <code>path.basename()</code> 方法，可以获取路径中的最后一部分，常通过该方法获取路径中的文件名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">path.basename(path[, ext])</span><br></pre></td></tr></table></figure>

<ul>
<li>path: 文件路径</li>
<li>ext: 文件扩展名</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;)</span><br><span class="line"></span><br><span class="line">// 定义文件的存放路径</span><br><span class="line">const fpath = &#x27;/a/b/c/index.html&#x27;</span><br><span class="line"></span><br><span class="line">const fullName = path.basename(fpath)</span><br><span class="line">console.log(fullName) // index.html</span><br><span class="line"></span><br><span class="line">const nameWithoutExt = path.basename(fpath, &#x27;.html&#x27;)</span><br><span class="line">console.log(nameWithoutExt) // index</span><br></pre></td></tr></table></figure>


<h3 id="获取路径中文件扩展名path-extname"><a href="#获取路径中文件扩展名path-extname" class="headerlink" title="获取路径中文件扩展名path.extname()"></a>获取路径中文件扩展名<code>path.extname()</code></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;)</span><br><span class="line"></span><br><span class="line">const fpath = &#x27;/a/b/c/index.html&#x27;</span><br><span class="line"></span><br><span class="line">const fext = path.extname(fpath)</span><br><span class="line">console.log(fext) // .html</span><br></pre></td></tr></table></figure>


<h2 id="http模块"><a href="#http模块" class="headerlink" title="http模块"></a>http模块</h2><p>http模块是Node.js官方提供的、用来创建web服务器的模块。</p>
<h3 id="创建基本Web服务器"><a href="#创建基本Web服务器" class="headerlink" title="创建基本Web服务器"></a>创建基本Web服务器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const http = require(&#x27;http&#x27;)</span><br><span class="line"></span><br><span class="line">// 创建 web 服务器实例</span><br><span class="line">const server = http.createServer()</span><br><span class="line"></span><br><span class="line">// 为服务器实例绑定 request 事件，监听客户端的请求</span><br><span class="line">server.on(&#x27;request&#x27;, function (req, res) &#123;</span><br><span class="line">  const url = req.url</span><br><span class="line">  const method = req.method</span><br><span class="line">  const str = `Your request url is $&#123;url&#125;, and request method is $&#123;method&#125;`</span><br><span class="line">  console.log(str)</span><br><span class="line"></span><br><span class="line">  // 设置 Content-Type 响应头，解决中文乱码的问题</span><br><span class="line">  res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html; charset=utf-8&#x27;)</span><br><span class="line">  // 向客户端响应内容</span><br><span class="line">  res.end(str)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(8080, function () &#123;</span><br><span class="line">  console.log(&#x27;server running at http://127.0.0.1:8080&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<h3 id="实现简陋路由效果"><a href="#实现简陋路由效果" class="headerlink" title="实现简陋路由效果"></a>实现简陋路由效果</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const http = require(&#x27;http&#x27;)</span><br><span class="line">const server = http.createServer()</span><br><span class="line"></span><br><span class="line">server.on(&#x27;request&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  const url = req.url</span><br><span class="line">  // 设置默认的响应内容为 404 Not found</span><br><span class="line">  let content = &#x27;&lt;h1&gt;404 Not found!&lt;/h1&gt;&#x27;</span><br><span class="line">  // 判断用户请求的是否为 / 或 /index.html 首页</span><br><span class="line">  // 判断用户请求的是否为 /about.html 关于页面</span><br><span class="line">  if (url === &#x27;/&#x27; || url === &#x27;/index.html&#x27;) &#123;</span><br><span class="line">    content = &#x27;&lt;h1&gt;首页&lt;/h1&gt;&#x27;</span><br><span class="line">  &#125; else if (url === &#x27;/about.html&#x27;) &#123;</span><br><span class="line">    content = &#x27;&lt;h1&gt;关于页面&lt;/h1&gt;&#x27;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html; charset=utf-8&#x27;)</span><br><span class="line">  res.end(content)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(80, () =&gt; &#123;</span><br><span class="line">  console.log(&#x27;server running at http://127.0.0.1&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><h3 id="模块化概念"><a href="#模块化概念" class="headerlink" title="模块化概念"></a>模块化概念</h3><ul>
<li>模块化是指解决一个复杂问题时，自顶向下逐层把系统划分为若干模块的过程，模块是可组合、分解和更换的单元。</li>
<li>模块化可提高代码的复用性和可维护性，实现按需加载。</li>
<li>模块化规范是对代码进行模块化拆分和组合时需要遵守的规则，如使用何种语法格式引用模块和向外暴露成员。</li>
</ul>
<h3 id="Node-js中模块的分类"><a href="#Node-js中模块的分类" class="headerlink" title="Node.js中模块的分类"></a>Node.js中模块的分类</h3><ul>
<li>内置模块</li>
<li>自定义模块</li>
<li>第三方模块</li>
</ul>
<h3 id="Node-js中的模块作用域"><a href="#Node-js中的模块作用域" class="headerlink" title="Node.js中的模块作用域"></a>Node.js中的模块作用域</h3><ul>
<li>和函数作用域类似，在自定义模块中定义的变量、方法等成员，只能在当前模块内被访问，这种模块级别的访问限制，叫做模块作用域</li>
<li>防止全局变量污染</li>
</ul>
<h3 id="模块作用域的成员"><a href="#模块作用域的成员" class="headerlink" title="模块作用域的成员"></a>模块作用域的成员</h3><ul>
<li>自定义模块中都有一个 <code>module</code> 对象，存储了和当前模块有关的信息</li>
<li>在自定义模块中，可以使用 <code>module.exports</code> 对象，将模块内的成员共享出去，供外界使用。导入自定义模块时，得到的就是 <code>module.exports</code> 指向的对象。</li>
<li>默认情况下，<code>exports</code> 和 <code>module.exports</code> 指向同一个对象。最终共享的结果，以 <code>module.exports</code> 指向的对象为准。</li>
</ul>
<h3 id="CommonJS模块化规范"><a href="#CommonJS模块化规范" class="headerlink" title="CommonJS模块化规范"></a>CommonJS模块化规范</h3><ul>
<li>每个模块内部，<code>module</code> 变量代表当前模块</li>
<li><code>module</code> 变量是一个对象，<code>module.exports</code> 是对外的接口</li>
<li>加载某个模块即加载该模块的 <code>module.exports</code> 属性</li>
</ul>
<h3 id="模块加载机制"><a href="#模块加载机制" class="headerlink" title="模块加载机制"></a>模块加载机制</h3><p>模块第一次加载后会被缓存，即多次调用 <code>require()</code> 不会导致模块的代码被执行多次，提高模块加载效率。</p>
<h4 id="内置模块加载"><a href="#内置模块加载" class="headerlink" title="内置模块加载"></a>内置模块加载</h4><p>内置模块加载优先级最高。</p>
<h4 id="自定义模块加载"><a href="#自定义模块加载" class="headerlink" title="自定义模块加载"></a>自定义模块加载</h4><p>加载自定义模块时，路径要以 <code>./</code> 或 <code>../</code> 开头，否则会作为内置模块或第三方模块加载。</p>
<p>导入自定义模块时，若省略文件扩展名，则 Node.js 会按顺序尝试加载文件：</p>
<ul>
<li>按确切的文件名加载</li>
<li>补全 <code>.js</code> 扩展名加载</li>
<li>补全 <code>.json</code> 扩展名加载</li>
<li>补全 <code>.node</code> 扩展名加载</li>
<li>报错</li>
</ul>
<h4 id="第三方模块加载"><a href="#第三方模块加载" class="headerlink" title="第三方模块加载"></a>第三方模块加载</h4><ul>
<li>若导入第三方模块， Node.js 会从<strong>当前模块的父目录</strong>开始，尝试从 <code>/node_modules</code> 文件夹中加载第三方模块。</li>
<li>如果没有找到对应的第三方模块，则移动到再<strong>上一层父目录</strong>中，进行加载，直到<strong>文件系统的根目录</strong>。</li>
</ul>
<p>例如，假设在 <code>C:\Users\bruce\project\foo.js</code> 文件里调用了 <code>require(&#39;tools&#39;)</code>，则 Node.js 会按以下顺序查找：</p>
<ul>
<li><code>C:\Users\bruce\project\node_modules\tools</code></li>
<li><code>C:\Users\bruce\node_modules\tools</code></li>
<li><code>C:\Users\node_modules\tools</code></li>
<li><code>C:\node_modules\tools</code></li>
</ul>
<h4 id="目录作为模块加载"><a href="#目录作为模块加载" class="headerlink" title="目录作为模块加载"></a>目录作为模块加载</h4><p>当把目录作为模块标识符进行加载的时候，有三种加载方式：</p>
<ul>
<li>在被加载的目录下查找 <code>package.json</code> 的文件，并寻找 <code>main</code> 属性，作为 <code>require()</code> 加载的入口</li>
<li>如果没有 <code>package.json</code> 文件，或者 <code>main</code> 入口不存在或无法解析，则 Node.js 将会试图加载目录下的 <code>index.js</code> 文件。</li>
<li>若失败则报错</li>
</ul>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>PC端的网页特效</title>
    <url>/2022/08/01/PC%E7%AB%AF%E7%9A%84%E7%BD%91%E9%A1%B5%E7%89%B9%E6%95%88/</url>
    <content><![CDATA[<h1 id="三大系列"><a href="#三大系列" class="headerlink" title="三大系列"></a>三大系列</h1><h2 id="元素偏移量offset系列"><a href="#元素偏移量offset系列" class="headerlink" title="元素偏移量offset系列"></a>元素偏移量offset系列</h2><h3 id="offset概述"><a href="#offset概述" class="headerlink" title="offset概述"></a>offset概述</h3><ol>
<li><p>offset翻译过来就是偏移量，使用offset系列相关属性可以动态的得到该元素的位置（偏移）、大小等</p>
<ol>
<li>获得元素距离带有定位父元素的位置</li>
<li>获得元素自身的大小（宽度高度）</li>
<li>注意：返回的数值都不带单位</li>
</ol>
</li>
<li><p>offset系列常用属性</p>
<table>
<thead>
<tr>
<th>offset系列属性</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>element.offsetParent</td>
<td>返回作为该元素带有定位的父级元素，若父级元素都没有定位则返回body</td>
</tr>
<tr>
<td>element.offsetTop</td>
<td>返回元素相对带有定位父元素上方的偏移，若父级元素都没有定位则返回body</td>
</tr>
<tr>
<td>element.offsetLeft</td>
<td>返回元素相对带有定位父元素左边框的偏移，若父级元素都没有定位则返回body</td>
</tr>
<tr>
<td>element.offsetWidth</td>
<td>返回自身包括padding、边框、内容区的宽度，返回数值不带单位</td>
</tr>
<tr>
<td>element.offsetHeight</td>
<td>返回自身包括padding、边框、内容区的高度，返回数值不带单位</td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="offset与style的区别"><a href="#offset与style的区别" class="headerlink" title="offset与style的区别"></a>offset与style的区别</h3><ol>
<li>offset<ol>
<li>offset可以得到任意样式表中的样式值</li>
<li>offset系列获得的数值是没有单位的</li>
<li>offsetWidth包含padding + border + width</li>
<li>offsetWidth等属性是只读属性，只能获取不能赋值</li>
<li>所以，我们想要获取元素大小位置，用offset更合适</li>
</ol>
</li>
<li>style<ol>
<li>style只能得到行内样式表中的样式值</li>
<li>style.width获得的是带有单位的字符串</li>
<li>style.width获得不包含padding和border的值</li>
<li>style.width是可读写属性，可以获取也可以赋值</li>
<li>所以，我们想要给元素更改值，则需要用style改变</li>
</ol>
</li>
</ol>
<h2 id="元素可视区client系列"><a href="#元素可视区client系列" class="headerlink" title="元素可视区client系列"></a>元素可视区client系列</h2><ol>
<li><p>client翻译过来就是客户端，我们使用client系列的相关属性来获取元素可视区的相关信息，通过client系列的相关属性可以动态的得到该元素的边框大小、元素大小等</p>
<table>
<thead>
<tr>
<th>client系列属性</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>element.clientTop</td>
<td>返回元素上边框的大小</td>
</tr>
<tr>
<td>element.clientLeft</td>
<td>返回元素左边框的大小</td>
</tr>
<tr>
<td>element.clientWidth</td>
<td>返回自身包括padding、内容区的宽度，不含边框，返回数值不带单位</td>
</tr>
<tr>
<td>element.clientHeight</td>
<td>返回自身包括padding、内容区的高度，不含边框，返回数值不带单位</td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="元素滚动scroll系列"><a href="#元素滚动scroll系列" class="headerlink" title="元素滚动scroll系列"></a>元素滚动scroll系列</h2><h3 id="元素scroll系列属性"><a href="#元素scroll系列属性" class="headerlink" title="元素scroll系列属性"></a>元素scroll系列属性</h3><ol>
<li><p>scroll翻译过来就是滚动的，我们使用scroll系列的相关属性可以动态的得到该元素的大小、滚动距离等</p>
<table>
<thead>
<tr>
<th>scroll系列属性</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>element.scrollTop</td>
<td>返回被卷去的上侧距离，返回数值不带单位</td>
</tr>
<tr>
<td>element.scrollLeft</td>
<td>返回被卷去的左侧距离，返回数值不带单位</td>
</tr>
<tr>
<td>element.scrollWidth</td>
<td>返回自身内容实际的宽度，不含边框，返回数值不带单位</td>
</tr>
<tr>
<td>element.scrollheight</td>
<td>返回自身内容实际的高度，不含边框，返回数值不带单位</td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="scroll滚动事件"><a href="#scroll滚动事件" class="headerlink" title="scroll滚动事件"></a>scroll滚动事件</h3><ol>
<li>onscroll：当滚动条被触发发生变化时会触发的事件</li>
<li>页面被卷去的头部：window.pageYOffset；页面被卷去的左侧</li>
<li>页面滚动：window.scroll(x, y);</li>
</ol>
<h2 id="三大系列总结"><a href="#三大系列总结" class="headerlink" title="三大系列总结"></a>三大系列总结</h2><h3 id="三大系列width属性对比"><a href="#三大系列width属性对比" class="headerlink" title="三大系列width属性对比"></a>三大系列width属性对比</h3><table>
<thead>
<tr>
<th>三大系列大小对比</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>element.offsetWidth</td>
<td>返回自身包括padding、边框、内容区的宽度，返回数值不带单位</td>
</tr>
<tr>
<td>element.clientWidth</td>
<td>返回自身包括padding、内容区的宽度，不含边框，返回数值不带单位</td>
</tr>
<tr>
<td>element.scrollWidth</td>
<td>返回自身内容实际的宽度，不含边框，返回数值不带单位</td>
</tr>
</tbody></table>
<ol>
<li>element.offsetWidt返回的数值包括边框<br><img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20210929113858.png" alt="img"></li>
<li>element.clientWidth<br><img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20210929113952.png" alt="img"></li>
<li>element.scrollWidth包含文字超出部分<br><img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20210929114107.png" alt="img"></li>
</ol>
<h3 id="三大系列用法"><a href="#三大系列用法" class="headerlink" title="三大系列用法"></a>三大系列用法</h3><ol>
<li><p>offset（偏移量）系列：用于获得元素位置 offsetLeft、offsetTop</p>
</li>
<li><p>client（客户端）系列：用于获取元素的大小 clientWidth、clientHeight</p>
</li>
<li><p>scroll（滚动）系列：用于获取滚动距离 scrollTop、scrollLeft</p>
</li>
</ol>
<h2 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h2><ol start="4">
<li><p>立即执行函数：不需要调用，立马能够自己执行的函数</p>
</li>
<li><p>语法</p>
<ol>
<li><p>方式一：(function() {})()</p>
<ul>
<li><p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(function(a, b) &#123;</span><br><span class="line">  console.log(a + b);</span><br><span class="line">&#125;)(1, 2);</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二个小括号可以看作是调用函数</p>
</li>
</ul>
</li>
<li><p>方式二：(function() {} ())</p>
<ul>
<li><p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(function sum(a, b) &#123;</span><br><span class="line">  console.log(a + b);</span><br><span class="line">&#125; (2, 3));</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
<li><p>主要作用：立即执行函数最大的作用就是独立创建了一个作用域，里面所有的变量都是局部变量，不会有命名冲突</p>
</li>
</ol>
<h1 id="动画函数封装"><a href="#动画函数封装" class="headerlink" title="动画函数封装"></a>动画函数封装</h1><h2 id="动画实现原理"><a href="#动画实现原理" class="headerlink" title="动画实现原理"></a>动画实现原理</h2><ol>
<li><p>核心原理：通过定时器setInterval()不断移动盒子位置</p>
</li>
<li><p>实现步骤：</p>
<ol>
<li><p>获得盒子当前位置</p>
</li>
<li><p>让盒子在当前位置加上1个移动距离</p>
</li>
<li><p>利用定时器不断重复这个操作</p>
</li>
<li><p>加一个结束定时器的条件</p>
</li>
<li><p>注意此元素需要添加定位，才能使用element.style.left</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        // 1. 获得盒子当前位置</span><br><span class="line">        // 2. 让盒子在当前位置加上1个移动距离</span><br><span class="line">        // 3. 利用定时器不断重复这个操作</span><br><span class="line">        // 4. 加一个结束定时器的条件</span><br><span class="line">        // 5. 注意此元素需要添加定位，才能使用element.style.left</span><br><span class="line">        var div = document.querySelector(&#x27;div&#x27;);</span><br><span class="line">        var timer = setInterval(function () &#123;</span><br><span class="line">            if (div.offsetLeft &gt;= 400) &#123;</span><br><span class="line">                // 停止动画，本质是停止计时器</span><br><span class="line">                clearInterval(timer);</span><br><span class="line">            &#125;</span><br><span class="line">            div.style.left = div.offsetLeft + 1 + &#x27;px&#x27;;</span><br><span class="line">        &#125;, 50);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="简单动画函数封装"><a href="#简单动画函数封装" class="headerlink" title="简单动画函数封装"></a>简单动画函数封装</h2><ol>
<li><p>简单动画函数封装两个参数：obj目标对象、target目标位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;button&gt;启动蓝色盒子&lt;/button&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">    &lt;span&gt;&lt;/span&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        // 封装动画函数</span><br><span class="line">        function animate(obj, target) &#123;</span><br><span class="line">            // 当没有这句代码时，会存在一个bug：当不断点击按钮使动画函数不断被调用，计时器会开启的越来越多，导致元素的动画速度越来越快</span><br><span class="line">            // 解决方法：让元素只有一个计时器执行</span><br><span class="line">            // 优化二：在执行下一个计时器时，清除之前的计时器；计时器第一次执行时，因为之前没有执行过计时器，则代码无效</span><br><span class="line">            clearInterval(obj.timer);</span><br><span class="line"></span><br><span class="line">            // 优化一：obj.timer 这样做的目的是 给不同的元素指定了不同的计时器</span><br><span class="line">            obj.timer = setInterval(function () &#123;</span><br><span class="line">                if (obj.offsetLeft &gt;= target) &#123;</span><br><span class="line">                    // 停止动画，本质是停止计时器</span><br><span class="line">                    clearInterval(obj.timer);</span><br><span class="line">                &#125;</span><br><span class="line">                obj.style.left = obj.offsetLeft + 1 + &#x27;px&#x27;;</span><br><span class="line">            &#125;, 50);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var div = document.querySelector(&#x27;div&#x27;);</span><br><span class="line">        var span = document.querySelector(&#x27;span&#x27;);</span><br><span class="line">        var btn = document.querySelector(&#x27;button&#x27;);</span><br><span class="line"></span><br><span class="line">        // 调用函数</span><br><span class="line">        animate(div, 400);</span><br><span class="line"></span><br><span class="line">        btn.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">            // 调用函数</span><br><span class="line">            animate(span, 300);</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="缓动动画原理"><a href="#缓动动画原理" class="headerlink" title="缓动动画原理"></a>缓动动画原理</h2><ol>
<li>缓动动画就是让元素运动速度有所变化,最常见的是让速度慢慢停下来</li>
<li>思路：<ol>
<li>让盒子每次移动的距离慢慢变小，速度就会慢慢落下来</li>
<li>核心算法： (目标值target - 现在的位置) &#x2F; 10做为每次移动的距离步长</li>
<li>停止的条件是：让当前盒子位置等于目标位置就停止定时器</li>
<li>注意：步长的小数需要进行取整，不然会出现元素无法到指定位置的bug<ul>
<li>步长为正数：向上取整</li>
<li>步长为负数：向下取整</li>
</ul>
</li>
</ol>
</li>
<li>匀速动画就是：盒子是当前的位置 + 固定的值</li>
<li>缓动动画就是：盒子当前的位置 + 变化的值（目标值target - 现在的位置） &#x2F; 10</li>
<li>演示见下</li>
</ol>
<h3 id="缓动动画添加回调函数"><a href="#缓动动画添加回调函数" class="headerlink" title="缓动动画添加回调函数"></a>缓动动画添加回调函数</h3><ol>
<li><p>回调函数原理：函数可以作为一个参数；将这个函数作为参数传到另一个函数里面，当那个函数执行完之后，再执行传进去的这个函数，这个过程就叫做回调</p>
</li>
<li><p>例：当缓动动画移动到终点后，盒子改变颜色</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;button class=&quot;btn700&quot;&gt;移动到700&lt;/button&gt;</span><br><span class="line">    &lt;button class=&quot;btn1000&quot;&gt;移动到1000&lt;/button&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        function animate(obj, target, cellback) &#123;</span><br><span class="line">            obj.timer = setInterval(function () &#123;</span><br><span class="line">                // 步长值，步长值公式：（目标值target - 现在的位置） / 10</span><br><span class="line">                // 把步长值改为整数，不然会出现元素无法到指定位置的bug，因为在JS中小数不进行计算</span><br><span class="line">                // 步长为正数：向上取 整</span><br><span class="line">                // 步长为负数：向下取整</span><br><span class="line">                var step = (target - obj.offsetLeft) / 10;</span><br><span class="line">                step = step &gt; 0 ? Math.ceil(step) : Math.floor(step);</span><br><span class="line">                // 停止的条件：让当前盒子位置等于目标位置就停止定时器</span><br><span class="line">                if (obj.offsetLeft == target) &#123;</span><br><span class="line">                    clearInterval(obj.timer);</span><br><span class="line">                    // 回调函数写到定时器结束内</span><br><span class="line">                    // 判断是否接收到回调函数，若接收到则调用函数</span><br><span class="line">                    if (cellback) &#123;</span><br><span class="line">                        cellback();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    obj.style.left = obj.offsetLeft + step + &#x27;px&#x27;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, 15);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var div = document.querySelector(&#x27;div&#x27;);</span><br><span class="line">        var btn700 = document.querySelector(&#x27;.btn700&#x27;);</span><br><span class="line">        var btn1000 = document.querySelector(&#x27;.btn1000&#x27;);</span><br><span class="line"></span><br><span class="line">        // 调用函数</span><br><span class="line">        btn700.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">            animate(div, 700, function () &#123;</span><br><span class="line">                div.style.backgroundColor = &#x27;skyblue&#x27;;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">        btn1000.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">            animate(div, 1000, function () &#123;</span><br><span class="line">                div.style.backgroundColor = &#x27;skyblue&#x27;;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="常见网页特效案例"><a href="#常见网页特效案例" class="headerlink" title="常见网页特效案例"></a>常见网页特效案例</h1><h2 id="网页轮播图"><a href="#网页轮播图" class="headerlink" title="网页轮播图"></a>网页轮播图</h2><ol>
<li>轮播图也称为焦点图，是网页中比较常见的网页特效</li>
</ol>
<h3 id="功能需求"><a href="#功能需求" class="headerlink" title="功能需求"></a>功能需求</h3><ol>
<li>鼠标经过轮播图模块，左右按钮显示，离开隐藏左右按钮<ol>
<li>显示隐藏display按钮</li>
</ol>
</li>
<li>生成动态小圆圈<ol>
<li>核心思路：小圆圈的个数要跟图片张数一致</li>
<li>所以首先先得到ul里面图片的张数(图片放入li里面，所以就是li的个数)</li>
<li>利用循环动态生成小圆圈(这个小圆圈要放入ol里面)</li>
<li>创建节点createElement(1i)</li>
<li>插入节点ol.appendChild(li)</li>
<li>第一个小圆圈需要添加current类(获得current类后小圆圈颜色变化)</li>
<li>排他思想</li>
</ol>
</li>
<li>点击小圆圈，可以播放相应图片<ol>
<li>此时用到animate动画函数，将js文件引入(注意：因为index.js依赖animate.js，所以，animate.js要写到index.js上面)</li>
<li>使用动画函数的前提，该元素必须有定位</li>
<li>注意是ul移动而不是小li</li>
<li>滚动图片的核心算法：点击某个小圆圈，就让图片滚动小圆圈的索引号乘以图片的宽度做为ul移动距离</li>
<li>此时需要知道小圆圈的索引号，我们可以在生成小圆圈的时候，给它设置一个自定义属性，点击的时候获取这个自定义属性即可</li>
</ol>
</li>
<li>点击右侧按钮一次，图片往左播放一张，以此类推，左侧按钮同理<ol>
<li>声明一个变量num，点击一次，自增1，让这个变量乘以图片宽度，就是ul的滚动距离</li>
<li>图片无缝滚动原理</li>
<li>把ul第一个li复制一份，放到ul的最后面</li>
<li>当图片滚动到克隆的最后一 张图片时，让ul快速的、不做动画的跳到最左侧：left为0</li>
<li>同时num赋值为0，可以重新开始滚动图片</li>
</ol>
</li>
<li>克隆第一张图片（在for循环外进行，不会多一个小圆圈），放在ul最后</li>
<li>图片播放的同时，下面小圆圈模块跟随一起变化<ol>
<li>最简单的做法是再声明一个变量circle，每次点击自增1，注意：左侧按钮也需要这个变量，因此要声明全局变量</li>
<li>排他思想，播放第几张图片，则第几个小圆圈的类名设置为current</li>
<li>若circle值为有效图片(除了最后一张克隆的图片)的数量时，令circle值为0，小圆圈从第一个开始</li>
</ol>
</li>
<li>鼠标不经过轮播图，轮播图也会自动播放图片<ol>
<li>添加一个定时器</li>
<li>自动播放轮播图，实际就类似于点击了右侧按钮</li>
<li>手动调用点击事件：使用手动调用右侧按钮点击事件r.click();</li>
</ol>
</li>
<li>鼠标经过，轮播图模块自动播放停止</li>
</ol>
<h2 id="节流阀"><a href="#节流阀" class="headerlink" title="节流阀"></a>节流阀</h2><ol>
<li>轮播图中运用节流阀：防止按钮连续点击造成播放过快</li>
<li>节流阀目的：当上一个函数动画内容执行完毕，再去执行下一个函数动画，让事件无法连续触发</li>
<li>核心思路：利用回调函数，添加一个量来控制，锁住函数和解锁函数<br><img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20210929115946.png" alt="img"></li>
</ol>
<h2 id="带有动画的淘宝返回顶部"><a href="#带有动画的淘宝返回顶部" class="headerlink" title="带有动画的淘宝返回顶部"></a>带有动画的淘宝返回顶部</h2><ol>
<li>此时可以继续使用封装的动画函数</li>
<li>只需要把所有的left相关的值改为跟页面垂直滚动距离相关就可以</li>
<li>页面滚动了多少，可以通过window.pageYOffset得到</li>
<li>最后是页面滚动，使用window.scrol(x, y)<br><img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20210929120104.png" alt="img"></li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-CLI</title>
    <url>/2022/08/02/Vue-CLI/</url>
    <content><![CDATA[<h1 id="Vue-CLI（Vue脚手架）"><a href="#Vue-CLI（Vue脚手架）" class="headerlink" title="Vue CLI（Vue脚手架）"></a>Vue CLI（Vue脚手架）</h1><h2 id="Vue-CLI介绍和安装"><a href="#Vue-CLI介绍和安装" class="headerlink" title="Vue CLI介绍和安装"></a>Vue CLI介绍和安装</h2><h3 id="什么是Vue-CLI"><a href="#什么是Vue-CLI" class="headerlink" title="什么是Vue CLI"></a>什么是Vue CLI</h3><ol>
<li>在开发大型项目时，需要使用到Vue CLI<ol>
<li>使用Vue.js开发大型应用时，需要考虑代码目录结构、项目结构和部署、热加载、代码单元测试等事情</li>
<li>如果每个项目都要手动完成这些工作，无疑效率比较低效，所以通常我们会使用一些脚手架工具来帮助完成这些事情</li>
</ol>
</li>
</ol>
<h3 id="CLI是什么"><a href="#CLI是什么" class="headerlink" title="CLI是什么"></a>CLI是什么</h3><ol>
<li>CLI是Command-Line Interface，翻译为命令行界面，但是俗称脚手架</li>
<li>Vue CLI是一个官方发布vue.js项目脚手架</li>
<li>使用vue-cli可以快速搭建Vue开发环境以及对应的webpack配置</li>
</ol>
<h3 id="什么是npm"><a href="#什么是npm" class="headerlink" title="什么是npm"></a>什么是npm</h3><ol>
<li>NPM的全称是Node Package Manager</li>
<li>是一个NodeJS包管理和分发工具，已经成为了非官方的发布Node模块(包)的标准</li>
<li>后续会经常使用NPM来安装一些开发过程中依赖包</li>
</ol>
<h3 id="cnpm安装"><a href="#cnpm安装" class="headerlink" title="cnpm安装"></a>cnpm安装</h3><ol>
<li>由于国内直接使用npm的官方镜像是非常慢的，这里推荐使用淘宝NPM镜像</li>
<li>可以使用淘宝定制的cnpm（gzip压缩支持）命令行工具代替默认的npm<ul>
<li>npm install -g cnpm –registry&#x3D;<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a></li>
</ul>
</li>
<li>这样就可以使用cnpm命令来安装模块<ul>
<li>cnpm install [name]</li>
</ul>
</li>
</ol>
<h3 id="安装Vue脚手架"><a href="#安装Vue脚手架" class="headerlink" title="安装Vue脚手架"></a>安装Vue脚手架</h3><ol>
<li>直接在终端输入指令：npm install -g @vue&#x2F;cli<ol>
<li>-g：进行全局安装</li>
</ol>
</li>
<li>注意以上安装的是Vue CLI3或4的版本，如果需要按照Vue CLI2的方式初始化项目时，是不可以的</li>
<li>Vue CLI3和旧版使用了相同的vue命令，所以Vue CLI2(vue-cli)被覆盖了，如果仍然需要使用旧版本的vue init功能，需要全局安装一个桥接工具<ol>
<li>安装指令：npm install @vue&#x2F;cli-init</li>
<li>安装这个就是为了使用Vue CLI2</li>
</ol>
</li>
</ol>
<h3 id="Vue初始化项目"><a href="#Vue初始化项目" class="headerlink" title="Vue初始化项目"></a>Vue初始化项目</h3><ol>
<li>Vue CLI3初始化项目：vue create my-project</li>
<li>Vue CLI2初始化项目：vue init webpack my-project<ol>
<li>vue init webpack my-project：会根据这个名称my-project创建一个文件夹，存放之后的项目，该名称也会作为默认的项目名称，但是不能包含大写字母</li>
<li>? Project name (my-project)：项目名称，不能包含大写</li>
<li>? Project description (A Vue.js project)：项目描述</li>
<li>? Author (CHHwn <a href="mailto:3355949795@qq.com">1258842059@qq.com</a>)：作者信息，会默认从git中读取信息</li>
<li>? Vue build standalone：runtime-only和runtime-compiler两个vue版本选择</li>
<li>? Install vue-router? (Y&#x2F;n)：是否选择vue路由，选择no，后面自己安装</li>
<li>? Use ESLint to lint your code? (Y&#x2F;n)：ESlint检测代码规范，根据自身情况选择</li>
<li>? Set up unit tests (Y&#x2F;n)：单元测试，根据公司要求，一般为no</li>
<li>? Setup e2e tests with Nightwatch? (Y&#x2F;n)：e2e测试，安装Nightwatch，是利用selenium或webdriver或phantomjs等进行自动化测试的框架</li>
<li>? Should we run <code>npm install</code> for you after the project has been created? (recommended)：选择使用npm或yarn</li>
</ol>
</li>
<li>若脚手架安装失败可尝试将npm-cache文件夹删除，文件夹路径：C:\Users\大哥和臭憨憨\AppData\Roaming\npm-cache</li>
</ol>
<h3 id="runtime-compiler和runtime-only两个vue版本的区别（面试常问）"><a href="#runtime-compiler和runtime-only两个vue版本的区别（面试常问）" class="headerlink" title="runtime-compiler和runtime-only两个vue版本的区别（面试常问）"></a>runtime-compiler和runtime-only两个vue版本的区别（面试常问）</h3><ol>
<li>两者的区别只在于main.js文件<ol>
<li>runtime-complier版本<br><img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211011010746.png" alt="img"></li>
<li>runtime-only版本<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211011010805.png" alt="img">- 其中render函数的参数h，也是一个函数，h的本质是createElement这个函数，h相当于是一个代号 - 在createElement函数里面，是可以传入一个组件进行注册的，然后通过return直接将注册的组件返回给render函数，这样就相当于跳过了template -&gt; ast -&gt;render步骤（该步骤属于Vue运行过程的一部分） - render: h &#x3D;&gt; h(App)</li>
</ol>
</li>
<li>Vue运行过程<ol>
<li>在以后的开发中会将html代码都写成template模板，然后解析template将其转化为ast抽象语法树，之后进行编译将ast抽象语法树中的所有东西转化为render函数，render函数会形成一个虚拟dom树，最后转化为真实dom</li>
<li>执行过程<ul>
<li>template -&gt; ast -&gt;render -&gt; virtual(虚拟) dom -&gt; 真实dom</li>
</ul>
</li>
</ol>
</li>
<li>两个vue版本的执行过程对比<ol>
<li>对于runtime-complier的vue版本，执行过程如下<ul>
<li>template -&gt; ast -&gt;render -&gt; virtual(虚拟) dom -&gt; 真实dom</li>
</ul>
</li>
<li>对于runtime-only的vue版本，执行过程如下<ul>
<li>render -&gt; virtual(虚拟) dom -&gt; 真实dom</li>
</ul>
</li>
</ol>
</li>
<li>两者对比<ol>
<li>runtime-only的执行过程更简单，性能更高</li>
<li>runtime-only跳过了template -&gt; ast -&gt;render步骤，代码执行时，内部处理代码更少<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211011010830.png" alt="img"></li>
<li>这里在创建vue选择版本时，runtime-only描述中表示轻6kb就是因为跳过了template -&gt; ast -&gt;render步骤</li>
</ol>
</li>
<li>因此在以后工作中一般选择runtime-only版本vue</li>
<li>疑问：既然使用runtime-only版本vue会跳过template -&gt; ast -&gt;render过程，那么.vue文件中的template是由谁处理的呢？<ol>
<li>是由vue-tempate-compiler插件直接将template转化为了render</li>
<li>该插件在脚手架中已经配置完成</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vuex</title>
    <url>/2022/08/02/Vuex/</url>
    <content><![CDATA[<h1 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h1><ol>
<li>官方解释：Vuex是一个专为Vue.js应用程序开发的状态管理模式</li>
<li>Vuex：实现集中式状态（数据）管理的插件</li>
<li>作用：对Vue中多个组件的共享状态进行集中式管理（读&#x2F;写），是一种组件间的通信方式，适用于任意组件间的通信</li>
<li>使用版本<ol>
<li>Vue2使用<a href="mailto:vuex@3.xx.xx">vuex@3.xx.xx</a>版本</li>
<li>Vue3使用<a href="mailto:vuex@4.xx.xx">vuex@4.xx.xx</a>版本</li>
</ol>
</li>
</ol>
<h2 id="搭建Vuex环境"><a href="#搭建Vuex环境" class="headerlink" title="搭建Vuex环境"></a>搭建Vuex环境</h2><ol>
<li><p>安装vuex：<strong>npm install vuex –save</strong>（注意版本号对应）</p>
</li>
<li><p>在项目中新建store文件夹，在该文件夹下创建index.js文件</p>
</li>
<li><p>在index.js文件中进行Vuex配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 引入vue</span><br><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">// 引入Vuex</span><br><span class="line">import Vuex from &#x27;vuex&#x27;</span><br><span class="line">// 使用Vuex</span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line">// 创建并且导出store</span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">    state: &#123;&#125;,</span><br><span class="line">    actions: &#123;&#125;</span><br><span class="line">    mutations: &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在main.js文件中引入store并挂载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import store from &#x27;./store/index&#x27;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el: &#x27;#app&#x27;,</span><br><span class="line">    store,</span><br><span class="line">    render: h =&gt; (App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Vuex工作原理图"><a href="#Vuex工作原理图" class="headerlink" title="Vuex工作原理图"></a>Vuex工作原理图</h2><p><img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/image-20220723190452821.png" alt="image-20220723190452821"></p>
<h2 id="Vuex核心概念"><a href="#Vuex核心概念" class="headerlink" title="Vuex核心概念"></a>Vuex核心概念</h2><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><ol>
<li>作用：用于保存公共数据</li>
</ol>
<h3 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h3><ol>
<li>作用：用于进行处理异步操作、发送ajax请求、处理业务逻辑等操作</li>
</ol>
<h3 id="Mutations"><a href="#Mutations" class="headerlink" title="Mutations"></a>Mutations</h3><ol>
<li><p><strong>作用：Vuex的store中state状态的更新唯一方式就是通过 — 提交Mutations</strong></p>
</li>
<li><p>通常情况下，Vuex要去我们Mutation中的方法必须是</p>
<p>同步方法</p>
<p>，原因如下</p>
<ol>
<li>当我们使用devtools时，可以devtools可以帮助我们捕捉mutation的状态</li>
<li>但是如果是异步操作，那么devtools将不能很好的追逐这个操作什么时候会被完成</li>
<li>所以在mutation中不要定义异步操作，将异步操作放入Action中</li>
</ol>
</li>
</ol>
<h3 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h3><ol>
<li>作用：类似于组件中的computed计算属性，可以对state中的数据进行加工处理后使用</li>
</ol>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ol>
<li><p>在stroe&#x2F;index.js文件进行以下配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 引入vue</span><br><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">// 引入Vuex</span><br><span class="line">import Vuex from &#x27;vuex&#x27;</span><br><span class="line">// 使用Vuex</span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line">// 创建并且导出store</span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">    // 用于保存公共数据</span><br><span class="line">    state: &#123;</span><br><span class="line">        num: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    // 用于进行处理异步操作、发送ajax请求、处理业务逻辑等操作</span><br><span class="line">    actions: &#123;</span><br><span class="line">        // context中包含了commit等方法，方便在actions中进行异步处理后将数据commit给mutations进行数据更新</span><br><span class="line">        hronous(context, value) &#123;</span><br><span class="line">            // 进行异步操作</span><br><span class="line">            ...</span><br><span class="line">            // 将进行异步处理或经过业务逻辑处理后的value，通过commit提交Mutations进行数据更新</span><br><span class="line">            context.commit(&#x27;HRONOUS&#x27;, value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 用于更新state中的变量值</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        // 更新state中的数据num</span><br><span class="line">        // 为了与Actions中的函数进行区分，mutations中的函数以全大写形式命名</span><br><span class="line">        HRONOUS(state, value) &#123;</span><br><span class="line">            state.num = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 类似于computed计算属性</span><br><span class="line">    getter: &#123;</span><br><span class="line">        bigNum(state) &#123;</span><br><span class="line">            return state.num * 10</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在组件中使用getter：<strong>this.$store.getter.属性</strong></p>
</li>
<li><p>在组件中读取Vuex中的数据：<strong>this.$store.state.属性</strong></p>
</li>
<li><p>在组件中修改Vuex中的数据：</p>
<ol>
<li>当<strong>需要</strong>进行异步操作或逻辑处理时：<strong>this.$store.dispatch(‘actions中的方法名’, 数据)</strong></li>
<li>当<strong>不需要</strong>进行异步操作或逻辑处理时：<strong>this.$store.commit(‘mutations中的方法名’, 数据)</strong></li>
</ol>
</li>
<li><p>当修改Vuex中的数据不需要进行异步操作或逻辑处理时可以跳过Actions直接commit通过Mutations进行数据更新</p>
</li>
</ol>
<h2 id="四个map方法使用"><a href="#四个map方法使用" class="headerlink" title="四个map方法使用"></a>四个map方法使用</h2><h3 id="mapState"><a href="#mapState" class="headerlink" title="mapState"></a>mapState</h3><ol>
<li><p>mapState方法：用于映射Vuex中state的数据为计算属性</p>
</li>
<li><p>可以避免在html中频繁通过使用state中的数据</p>
</li>
<li><p>使用方法，有两种写法：</p>
<ol>
<li><p>对象写法</p>
</li>
<li><p>数组写法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123;mapState&#125; from &#x27;vuex&#x27;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;!-- 使用计算属性 --&gt;</span><br><span class="line">        &lt;span&gt;&#123;&#123;num&#125;&#125;&lt;/span&gt;</span><br><span class="line">        &lt;span&gt;&#123;&#123;sum&#125;&#125;&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">// 实例化组件中的计算属性</span><br><span class="line">computed: &#123;</span><br><span class="line">    // 对象写法：借助mapState生成计算属性num、sum</span><br><span class="line">    ...mapState(&#123; num: &#x27;num&#x27;, sum: &#x27;sum&#x27; &#125;)</span><br><span class="line">    // 数组写法：借助mapState生成计算属性num</span><br><span class="line">    ...mapState([&#x27;num&#x27;, &#x27;sum&#x27;])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>…mapState({ num: ‘num’, sum: ‘sum’ })中num: ‘num’实际上为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    num() &#123;</span><br><span class="line">        return this.$store.state.num</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="mapGetters"><a href="#mapGetters" class="headerlink" title="mapGetters"></a>mapGetters</h3><ol>
<li><p>mapGetters方法：用于映射Vuex中getters的数据为计算属性</p>
</li>
<li><p>可以避免在html中频繁通过使用state中的数据</p>
</li>
<li><p>使用方法，有两种写法：</p>
<ol>
<li><p>对象写法</p>
</li>
<li><p>数组写法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123;mapGetters&#125; from &#x27;vuex&#x27;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;!-- 使用计算属性 --&gt;</span><br><span class="line">        &lt;span&gt;&#123;&#123;bigNum&#125;&#125;&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">// 实例化组件中的计算属性</span><br><span class="line">computed: &#123;</span><br><span class="line">    // 对象写法：借助mapGetters生成计算属性num</span><br><span class="line">    ...mapGetters(&#123; bigNum: &#x27;bigNum&#x27; &#125;)</span><br><span class="line">    // 数组写法：借助mapState生成计算属性num</span><br><span class="line">    ...mapGetters([&#x27;bigNum&#x27;])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>…mapGetters({ bigNum: ‘bigNum’ })中的bigNum: ‘bigNum’实际上为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    bigNum() &#123;</span><br><span class="line">        return this.$store.getters.bigNum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="mapActions"><a href="#mapActions" class="headerlink" title="mapActions"></a>mapActions</h3><ol>
<li><p>mapActions方法：用于生成与Vuex中actions对话的方法，即：this.$store.dispatch(“方法名”)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123;mapActions&#125; from &#x27;vuex&#x27;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;!-- 调用incrementOdd，并传参为num --&gt;</span><br><span class="line">        &lt;span @click=&quot;incrementOdd(num)&quot;&gt;&lt;/span&gt;</span><br><span class="line">        &lt;!-- 调用decrementWait，并传参为num --&gt;</span><br><span class="line">        &lt;span @click=&quot;decrementWait(num)&quot;&gt;&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        num: 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 实例化组件中的methods</span><br><span class="line">methods: &#123;</span><br><span class="line">    // 对象写法：生成incrementOdd、decrementWait分别用于与actions中jiaOdd、jianWait方法对话</span><br><span class="line">    // 即为this.$store.dispatch(&#x27;jiaOdd&#x27;, num)、this.$store.dispatch(&#x27;jianWait&#x27;, num)的简写形式</span><br><span class="line">    ...mapActions(&#123; increment: &#x27;jiaOdd&#x27;, decrementWait: &#x27;jianWait&#x27; &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>…mapActions({ increment: ‘jiaOdd’, decrementWait: ‘jianWait’ })中的increment: ‘jiaOdd’实际上为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    increment(num) &#123;</span><br><span class="line">        return this.$store.dispatch(&#x27;jiaOdd&#x27;, num)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="mapMutations"><a href="#mapMutations" class="headerlink" title="mapMutations"></a>mapMutations</h3><ol>
<li><p>mapMutations方法：用于生成与Vuex中mutations对话的方法，即：this.$store.commit(“方法名”)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123;mapMutations&#125; from &#x27;vuex&#x27;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;!-- 调用increment，并传参为num --&gt;</span><br><span class="line">        &lt;span @click=&quot;increment(num)&quot;&gt;&lt;/span&gt;</span><br><span class="line">        &lt;!-- 调用decrement，并传参为num --&gt;</span><br><span class="line">        &lt;span @click=&quot;decrement(num)&quot;&gt;&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        num: 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 实例化组件中的methods</span><br><span class="line">methods: &#123;</span><br><span class="line">    // 对象写法：生成increment、decrement分别用于与mutations中JIA、JIAN方法对话</span><br><span class="line">    // 即为this.$store.commit(&#x27;JIA&#x27;, num)、this.$store.commit(&#x27;JIAN&#x27;, num)的简写形式</span><br><span class="line">    ...mapMutations(&#123; increment: &#x27;JIA&#x27;, decrement: &#x27;JIAN&#x27; &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>…mapMutations({ increment: ‘JIA’, decrement: ‘JIAN’ })中的increment: ‘JIA’实际上为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    increment(num) &#123;</span><br><span class="line">        return this.$store.commit(&#x27;JIA&#x27;, num)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Vuex模块化与命名空间namespaced"><a href="#Vuex模块化与命名空间namespaced" class="headerlink" title="Vuex模块化与命名空间namespaced"></a>Vuex模块化与命名空间namespaced</h2><ol>
<li><p>目的：为了让代码更方便维护，让Vuex中不同业务类型涉及到的数据进行分类，同时可以避免不同业务数据分类间的命名冲突问题</p>
</li>
<li><p>Vuex模块化代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 引入vue</span><br><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">// 引入Vuex</span><br><span class="line">import Vuex from &#x27;vuex&#x27;</span><br><span class="line">// 使用Vuex</span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line">// 注册第一个countAbout模块</span><br><span class="line">const countAbout = &#123;</span><br><span class="line">    // 重点：开启命名空间</span><br><span class="line">    namespaced: true,</span><br><span class="line">    state: &#123;&#125;,</span><br><span class="line">    actions: &#123;&#125;,</span><br><span class="line">    mutations: &#123;&#125;,</span><br><span class="line">    getter: &#123;&#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">// 注册第一个personAbout模块</span><br><span class="line">const personAbout = &#123;</span><br><span class="line">    // 重点：开启命名空间</span><br><span class="line">    namespaced: true,</span><br><span class="line">    state: &#123;&#125;,</span><br><span class="line">    actions: &#123;&#125;,</span><br><span class="line">    mutations: &#123;&#125;,</span><br><span class="line">    getter: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建并且导出store</span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">    modoles: &#123;</span><br><span class="line">        // 第一个模块挂载</span><br><span class="line">        countAbout,</span><br><span class="line">        // 第二个模块挂载</span><br><span class="line">        personAbout</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Vuex模块化读取state、getters数据，调用dispatch、commit"><a href="#Vuex模块化读取state、getters数据，调用dispatch、commit" class="headerlink" title="Vuex模块化读取state、getters数据，调用dispatch、commit"></a>Vuex模块化读取state、getters数据，调用dispatch、commit</h3><h4 id="读取state数据"><a href="#读取state数据" class="headerlink" title="读取state数据"></a>读取state数据</h4><ol>
<li><p>开启命名空间后，在组件中读取state数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 方式一：通过$store.state读取</span><br><span class="line">this.$store.state.Vuex模块化名称.数据属性名</span><br><span class="line"></span><br><span class="line">// 方式二：通过mapState方式简写读取</span><br><span class="line">computed: &#123;</span><br><span class="line">    ...mapState(&#x27;Vuex模块化名称&#x27;, [&#x27;数据属性名&#x27;, ...])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="读取getters数据"><a href="#读取getters数据" class="headerlink" title="读取getters数据"></a>读取getters数据</h4><ol>
<li><p>开启命名空间后，在组件中读取getters数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 方式一：通过$store.getters读取</span><br><span class="line">this.$store.getters[&#x27;Vuex模块化名称/getters数据名&#x27;]</span><br><span class="line"></span><br><span class="line">// 方式二：通过mapGetters方式简写读取</span><br><span class="line">computed: &#123;</span><br><span class="line">    ...mapGetters(&#x27;Vuex模块化名称&#x27;, [&#x27;getters数据名&#x27;, ...])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="调用dispatch"><a href="#调用dispatch" class="headerlink" title="调用dispatch"></a>调用dispatch</h4><ol>
<li><p>开启命名空间后，在组件中调用dispatch</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 调用incrementOdd，并传参为num --&gt;</span><br><span class="line">&lt;span @click=&quot;incrementOdd(num)&quot;&gt;&lt;/span&gt;</span><br><span class="line"></span><br><span class="line">// 方式一：通过$store.dispatch</span><br><span class="line">this.$store.dispatch(&#x27;Vuex模块化名称/Actions中的方法名称&#x27;, value)</span><br><span class="line"></span><br><span class="line">// 方式二：通过mapActions方法简写</span><br><span class="line">methods: &#123;</span><br><span class="line">    ...mapActions(&#x27;Vuex模块化名称&#x27;, &#123;incrementOdd: &#x27;Actions中的方法名称&#x27;, ...&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="调用commit"><a href="#调用commit" class="headerlink" title="调用commit"></a>调用commit</h4><ol>
<li><p>开启命名空间后，在组件中调用commit</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 调用increment，并传参为num --&gt;</span><br><span class="line">&lt;span @click=&quot;increment(num)&quot;&gt;&lt;/span&gt;</span><br><span class="line">   </span><br><span class="line">// 方式一：通过$store.dispatch</span><br><span class="line">this.$store.commit(&#x27;Vuex模块化名称/Mutations中的方法名称&#x27;, value)</span><br><span class="line">   </span><br><span class="line">// 方式二：通过mapMutations方法简写</span><br><span class="line">methods: &#123;</span><br><span class="line">    ...mapMutations(&#x27;Vuex模块化名称&#x27;, &#123;increment: &#x27;Mutations中的方法名称&#x27;, ...&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue组件化开发</title>
    <url>/2022/08/02/Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h1 id="Vue组件化开发"><a href="#Vue组件化开发" class="headerlink" title="Vue组件化开发"></a>Vue组件化开发</h1><h2 id="组件的基本介绍"><a href="#组件的基本介绍" class="headerlink" title="组件的基本介绍"></a>组件的基本介绍</h2><h3 id="注册组件的基本步骤"><a href="#注册组件的基本步骤" class="headerlink" title="注册组件的基本步骤"></a>注册组件的基本步骤</h3><ol>
<li><p>调用Vue.extend()方法 - 创建组件构造器</p>
</li>
<li><p>调用Vue.component()方法 - 注册组件</p>
</li>
<li><p>在Vue实例的作用范围内 - 使用组件</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;   </span><br><span class="line">   //使用组件</span><br><span class="line">    &lt;my-cpm&gt;&lt;/my-cpm&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">//创建组件构造器</span><br><span class="line">const cpnC = Vue.extend(&#123;</span><br><span class="line">    template: &#x27;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;标题&lt;/h2&gt;</span><br><span class="line">        &lt;p&gt;模板&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;&#x27;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//注册组件</span><br><span class="line">Vue.component(&#x27;my-cpn&#x27;, cpmC)</span><br><span class="line"></span><br><span class="line">const app = new Vue(&#123;</span><br><span class="line">    el: &#x27;#app&#x27;,</span><br><span class="line">    data:&#123;</span><br><span class="line">        message: &#x27;&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<h3 id="全局组件-x2F-局部组件"><a href="#全局组件-x2F-局部组件" class="headerlink" title="全局组件 &#x2F; 局部组件"></a>全局组件 &#x2F; 局部组件</h3><ol>
<li><p>全局组件</p>
<ul>
<li>上面的案例</li>
</ul>
</li>
<li><p>局部组件</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;my-cpm&gt;&lt;/my-cpm&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">const cpnC = Vue.extend(&#123;</span><br><span class="line">    template: &#x27;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;标题&lt;/h2&gt;</span><br><span class="line">        &lt;p&gt;模板&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;&#x27;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const app = new Vue(&#123;</span><br><span class="line">    el: &#x27;#app&#x27;,</span><br><span class="line">    data:&#123;</span><br><span class="line">        message: &#x27;&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        cpn: cpnC</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="父组件-x2F-子组件"><a href="#父组件-x2F-子组件" class="headerlink" title="父组件 &#x2F; 子组件"></a>父组件 &#x2F; 子组件</h3><p>父子组件的错误用法: 以子标签的形式在Vue实例中使用</p>
<ol>
<li><p>因为当子组件注册到父组件的components时, Vue会编译好父组件的模块 </p>
<ol start="2">
<li>该模块的内容已经决定了父组件将要渲染的HTML (相当于父组件中已经有子组件中的内容了)</li>
</ol>
</li>
</ol>
<h3 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h3><p>Vue为了简化注册组件的过程, 提供了注册的语法塘, 省去了调用Vue.extend()的步骤. 而是可以直接使用一个对象来代替</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 全局组件</span><br><span class="line">Vue.component(&#x27;xxx&#x27;, &#123;</span><br><span class="line">    template: &#x27;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        哈哈哈哈</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &#x27;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 内部会自动调用Vue.extend()</span><br><span class="line"></span><br><span class="line">// 局部组件</span><br><span class="line">const app = new Vue(&#123;</span><br><span class="line">    el: &#x27;#app&#x27;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        meassage: &#x27;哈哈哈&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        &#x27;cpn&#x27;: &#123;</span><br><span class="line">            template: &#x27;</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                    哈哈哈哈</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>组件模板抽离写法 (简单)</p>
<ol>
<li><p>方法一<br>将模板放到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 注册一个全局组件  </span><br><span class="line">&lt;div id=&quot;id&quot;&gt;</span><br><span class="line">    &lt;cpn&gt;&lt;/cpn&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/x-tenplate&quot; id=&quot;cpn&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        哈哈哈哈</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Vue.component(&#x27;cpn&#x27;, &#123;</span><br><span class="line">    template: &#x27;#cpn&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法二<br>放入标签</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;id&quot;&gt;</span><br><span class="line">    &lt;cpn&gt;&lt;/cpn&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;template id=&quot;cpn&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        哈哈哈哈</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Vue.component(&#x27;cpn&#x27;, &#123;</span><br><span class="line">    template: &#x27;#cpn&#x27;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>组件可以访问VUE实例数据吗?<br>不能访问<br>组件是一个单独功能模块的封装 - 这个模块有自己的HTML模板, 也应该有属性自己的数据data</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Vue.component(&#x27;cpn&#x27;, &#123;</span><br><span class="line">    template: &#x27;#cpn&#x27;,</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            title: &#x27;哈哈哈&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// data属性必须是一个函数, 返回必须是一个对象</span><br></pre></td></tr></table></figure>



<h2 id="组件通讯"><a href="#组件通讯" class="headerlink" title="组件通讯"></a>组件通讯</h2><h3 id="父子组件的通讯"><a href="#父子组件的通讯" class="headerlink" title="父子组件的通讯"></a>父子组件的通讯</h3><p>父组件通过props向子组件传递数据</p>
<ul>
<li>写法一</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;cpm v-bind:cmovies=&quot;movies&quot; v-bind:cmessage=&quot;message&quot;&gt;&lt;/cpn&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;template id=&quot;cpn&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;li v-for=&quot;item in cmovies&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;</span><br><span class="line">        &lt;h2&gt;&#123;&#123;cmessage&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const cpn = &#123;</span><br><span class="line">    template: &#x27;#cpn&#x27;,</span><br><span class="line">    // 把数组里的当变量来看了</span><br><span class="line">    props: [&#x27;cmovies&#x27;, &#x27;cmessage&#x27;],</span><br><span class="line">    data () &#123;</span><br><span class="line">        return &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const app = new Vue(&#123;</span><br><span class="line">    el: &#x27;#app&#x27;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        meassage: &#x27;哈哈哈&#x27;,</span><br><span class="line">        movies: [&#x27;哈喽&#x27;, &#x27;嗨&#x27;, &#x27;哟哟&#x27;]</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        cpn</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>写法二</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    // 在使用组件的时候绑定</span><br><span class="line">    // 不支持驼峰命名  cMovies要写成c-movies</span><br><span class="line">    &lt;cpm :c-movies=&quot;movies&quot; :c-message=&quot;message&quot;&gt;&lt;/cpn&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;template id=&quot;cpn&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;li v-for=&quot;item in cMovies&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;</span><br><span class="line">        &lt;h2&gt;&#123;&#123;cMessage&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const cpn = &#123;</span><br><span class="line">    template: &#x27;#cpn&#x27;,</span><br><span class="line">    // 把数组里的当变量来看了</span><br><span class="line">    props: &#123;</span><br><span class="line">        // 类型限制 </span><br><span class="line">        // cMovies: Array,</span><br><span class="line">        // cMeesage: String,</span><br><span class="line">        </span><br><span class="line">        // 类型限制 + 提供一些默认值 or  required表示必传值,不然报错</span><br><span class="line">        cMessage: &#123;</span><br><span class="line">            type: String,</span><br><span class="line">            default: &#x27;哈&#x27;,</span><br><span class="line">            required: true</span><br><span class="line">        &#125;,  </span><br><span class="line">        cMovies: &#123;</span><br><span class="line">            type: Array, // 对象or数组类型的时候, 默认值必须是个函数</span><br><span class="line">            default() &#123;</span><br><span class="line">                return &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    data () &#123;</span><br><span class="line">        return &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const app = new Vue(&#123;</span><br><span class="line">    el: &#x27;#app&#x27;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        meassage: &#x27;哈哈哈&#x27;,</span><br><span class="line">        movies: [&#x27;哈喽&#x27;, &#x27;嗨&#x27;, &#x27;哟哟&#x27;]</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        cpn</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<p>子组件通过事件向父组件发送数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 父组件模板</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    // 2.父组件监听一个事件</span><br><span class="line">    // 不能写驼峰</span><br><span class="line">    &lt;cpm @itemclick=&quot;cpnClick&quot;&gt;&lt;/cpn&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">// 子组件模板</span><br><span class="line">&lt;template id=&quot;cpn&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;button v-for=&quot;item in categories&quot; </span><br><span class="line">                @click=&quot;btnClick(item)&quot;&gt;</span><br><span class="line">            &#123;&#123;item.name&#125;&#125;</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 子组件</span><br><span class="line">const cpn = &#123;</span><br><span class="line">    template: &#x27;#cpn&#x27;,</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            categories: [</span><br><span class="line">                &#123;id: &#x27;aaaa&#x27;, name: &#x27;热门推荐&#x27;&#125;,</span><br><span class="line">                &#123;id: &#x27;bbbb&#x27;, name: &#x27;手机数码&#x27;&#125;,</span><br><span class="line">                &#123;id: &#x27;cccc&#x27;, name: &#x27;家用家电&#x27;&#125;,</span><br><span class="line">                &#123;id: &#x27;dddd&#x27;, name: &#x27;电脑办公&#x27;&#125;,</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        btnClick(item) &#123;</span><br><span class="line">            // 要把item传给父组件</span><br><span class="line">            // 1. 发送一个事件 (自定义事件)</span><br><span class="line">            // 会把item当成默认的传到父组件去</span><br><span class="line">            this.$emit(&#x27;itemclick&#x27;, item)</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 父组件</span><br><span class="line">const app = new Vue(&#123;</span><br><span class="line">    el: &#x27;#app&#x27;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        meassage: &#x27;哈哈哈&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        cpn</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        // 3. 父组件监听的事件 </span><br><span class="line">        cpnClick(item) &#123;</span><br><span class="line">            console.log(&#x27;成功了&#x27;, item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="父子组件的访问方式"><a href="#父子组件的访问方式" class="headerlink" title="父子组件的访问方式"></a>父子组件的访问方式</h3><ol>
<li><p>父组件访问子组件</p>
<ul>
<li>$children: 拿所有子组件</li>
<li>$refs: 拿指定的子组件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// this.$children是一个数组类型, 它包含所有子组件对象  </span><br><span class="line">// 通过遍历, 取出所有子组件的message状态  </span><br><span class="line"></span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;cpm&gt;&lt;/cpn&gt;</span><br><span class="line">    &lt;cpm&gt;&lt;/cpn&gt;</span><br><span class="line">    // 使用$refs的时候, 在想要访问的子组件上添加ref属性</span><br><span class="line">    &lt;cpm ref=&quot;aaa&quot;&gt;&lt;/cpn&gt;</span><br><span class="line">    &lt;buttun @click=&quot;btnClick&quot;&gt;按钮&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;template id=&quot;cpn&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        我是子组件</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">const app = new Vue(&#123;</span><br><span class="line">    el: &#x27;#app&#x27;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        meassage: &#x27;哈哈哈&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        btnClick() &#123;</span><br><span class="line">            cosole.log(this.$children);</span><br><span class="line">            // $children 的使用方法, 一般用的少, 下标不固定</span><br><span class="line">            // this.$children[0].showMessage();</span><br><span class="line">            // this.$children[0].name;</span><br><span class="line">            </span><br><span class="line">            //for (let c of this.$children) &#123;</span><br><span class="line">            //    console.log(c.name); // 我是子组件的name</span><br><span class="line">            //    c.showMessage(); // showMessage</span><br><span class="line">            //&#125;</span><br><span class="line">            </span><br><span class="line">            // $refs 的使用方法 =&gt; 对象类型, 默认是一个空的对象</span><br><span class="line">            console.log(this.$refs.aaa.name); // 我是子组件的name</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    components: &#123;</span><br><span class="line">        cpn: &#123;</span><br><span class="line">            template: &quot;#cpn&quot;,</span><br><span class="line">            data() &#123;</span><br><span class="line">                return &#123;</span><br><span class="line">                    name: &#x27;我是子组件的name&#x27;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            methods: &#123;</span><br><span class="line">                showMessage() &#123;</span><br><span class="line">                    cosole.log(&#x27;showMessage&#x27;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>子组件访问父组件</p>
<ul>
<li>$parent: 上一级父组件</li>
<li>$root: 根组件</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;cpm&gt;&lt;/cpn&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;template id=&quot;cpn&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;ccpn&gt;&lt;/ccpn&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;template id=&quot;ccpn&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;我是子组件&lt;/h2&gt;</span><br><span class="line">        &lt;button @click=&quot;btnClick&quot;&gt;按钮&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">const app = new Vue(&#123;</span><br><span class="line">    el: &#x27;#app&#x27;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        meassage: &#x27;哈哈哈&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    components: &#123;</span><br><span class="line">        cpn: &#123;</span><br><span class="line">            template: &quot;#cpn&quot;,</span><br><span class="line">            data() &#123;</span><br><span class="line">               return &#123;</span><br><span class="line">                   name: &#x27;我是cpn的name&#x27;</span><br><span class="line">               &#125; </span><br><span class="line">            &#125;,</span><br><span class="line">            conmponents: &#123;</span><br><span class="line">                ccpn: &#123;</span><br><span class="line">                    template: &#x27;#ccpn&#x27;,</span><br><span class="line">                    btnClick() &#123;</span><br><span class="line">                        // 1. 访问父组件$parent</span><br><span class="line">                        // 不建议这么写, 一层套一层 复用性太差</span><br><span class="line">                        console.log(this.$parent);  </span><br><span class="line">                        console.log(this.$parent.name); // 我是cpn的name</span><br><span class="line">                        </span><br><span class="line">                        // 2. 访问根组件 $root</span><br><span class="line">                        console.log(this.$root.meassage);   // 哈哈哈</span><br><span class="line">                    &#125; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="跨级组件通信之provide-x2F-inject"><a href="#跨级组件通信之provide-x2F-inject" class="headerlink" title="跨级组件通信之provide&#x2F;inject"></a>跨级组件通信之provide&#x2F;inject</h3><p>provide选项允许我们指定我们想要提供给后代组件的数据&#x2F;方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">provide: function () &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    fun: this.fun, //方法</span><br><span class="line">    name: &#x27;Bob&#x27;, // 数据</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在任何后代组件里，我们都可以使用inject选项来接收指定的我们想要添加在这个实例上的属性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//接受方法</span><br><span class="line">inject: [&#x27;fun&#x27;]</span><br><span class="line">//接受数据</span><br><span class="line">inject:[&#x27;name&#x27;]</span><br></pre></td></tr></table></figure>

<h2 id="插槽slot"><a href="#插槽slot" class="headerlink" title="插槽slot"></a>插槽slot</h2><ol>
<li>作用:<ol>
<li>组件的插槽是为了让我们封装的组件更加具有扩展性</li>
<li>让使用者可以决定组件内部的一些内容到底展示什么</li>
</ol>
</li>
</ol>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ol>
<li>插槽的基本使用</li>
<li>插槽的默认值 button</li>
<li>如果有多个值同时放入到组件进行替换时, 一起作为替换元素</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    // 使用默认值替换</span><br><span class="line">    &lt;cpm&gt;&lt;/cpn&gt;</span><br><span class="line">    // 插槽替换的元素</span><br><span class="line">    &lt;cpm&gt;&lt;span&gt;这是替换的内容呀&lt;/span&gt;&lt;/cpn&gt;</span><br><span class="line">    // 多个元素</span><br><span class="line">    &lt;cpm&gt;</span><br><span class="line">        &lt;div&gt;第一个元素&lt;/div&gt;</span><br><span class="line">        &lt;p&gt;第二个元素&lt;/p&gt;</span><br><span class="line">    &lt;/cpn&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;template id=&quot;cpn&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;div&gt;这个是标题&lt;/div&gt;</span><br><span class="line">        &lt;p&gt;这个是内容&lt;/p&gt;</span><br><span class="line">        // 放入插槽</span><br><span class="line">        &lt;slot&gt;默认值元素&lt;/slot&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">const app = new Vue(&#123;</span><br><span class="line">    el: &#x27;#app&#x27;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        meassage: &#x27;哈哈哈&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        cpn: &#123;</span><br><span class="line">            template: &#x27;#cpn&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><p>在多个插槽的情况下, 替换制定插槽的内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;cpm&gt;&lt;/cpn&gt;</span><br><span class="line">    &lt;cpm&gt;&lt;button slot=&quot;left&quot;&gt;返回&lt;/button&gt;&lt;/cpn&gt;</span><br><span class="line">    &lt;cpm&gt;&lt;span slot=&quot;center&quot;&gt;中间标题&lt;/span&gt;&lt;/cpn&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;template id=&quot;cpn&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;slot name=&quot;left&quot;&gt;&lt;span&gt;左边&lt;/span&gt;&lt;/slot&gt;</span><br><span class="line">        &lt;slot name=&quot;center&quot;&gt;&lt;span&gt;中间&lt;/span&gt;&lt;/slot&gt;</span><br><span class="line">        &lt;slot name=&quot;right&quot;&gt;&lt;span&gt;右边&lt;/span&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">const app = new Vue(&#123;</span><br><span class="line">    el: &#x27;#app&#x27;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        meassage: &#x27;哈哈哈&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        cpn: &#123;</span><br><span class="line">            template: &#x27;#cpn&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><ol>
<li>编译作用域<br>父组件模板所有的东西都在父级作用域内编译, 子组件模板的所有东西会在子级作用域内编译</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;cpm v-show=&quot;isShow&quot;&gt;我是一&lt;/cpn&gt; // true</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;template id=&quot;cpn&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p v-show=&quot;isShow&quot;&gt;我是二&lt;/p&gt; // false</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">const app = new Vue(&#123;</span><br><span class="line">    el: &#x27;#app&#x27;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        isShow: true // Vue实例中的属性</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        cpn: &#123;</span><br><span class="line">            template: &#x27;#cpn&#x27;,</span><br><span class="line">            data() &#123;</span><br><span class="line">                return &#123;</span><br><span class="line">                     isShow: false // 子组件中的属性</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="作用域插槽使用"><a href="#作用域插槽使用" class="headerlink" title="作用域插槽使用"></a>作用域插槽使用</h3><p>父组件替换插槽的标签, 但是内容由子组件来提供</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">需求: </span><br><span class="line">1. 子组件中包括一组数据, num: [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;]</span><br><span class="line">2. 需要在多个界面展示 </span><br><span class="line">   某些界面是以水平方向展示</span><br><span class="line">   某些界面是以列表形式展示</span><br><span class="line">   某些界面直接展示一个数组 </span><br><span class="line">3. 内容在子组件, 希望父组件告诉我们如何展示, 怎么办?</span><br><span class="line">   利用slot作用域插槽就行了</span><br><span class="line">   </span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;cpm&gt;&lt;/cpn&gt; </span><br><span class="line">    &lt;cpm&gt;</span><br><span class="line">        // 2. 获取子组件中的num</span><br><span class="line">        &lt;template slot-scope=&quot;slot&quot;&gt;</span><br><span class="line">            // 根据之前的起名来取  如 slot.aaa</span><br><span class="line">            &lt;span  v-for=&quot;item in slot.data&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/span&gt;</span><br><span class="line">        &lt;/template&gt;</span><br><span class="line">    &lt;/cpn&gt; </span><br><span class="line">    &lt;cpm&gt;&lt;/cpn&gt; </span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;template id=&quot;cpn&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        // 1. slot定义  &#x27;data&#x27;可以随便起名 如 :aaa=&quot;num&quot;</span><br><span class="line">        &lt;slot :data=&quot;num&quot;&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &lt;li v-for=&quot;item in num&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">        &lt;/slot&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">const app = new Vue(&#123;</span><br><span class="line">    el: &#x27;#app&#x27;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        message: &#x27;哈哈哈&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        cpn: &#123;</span><br><span class="line">            template: &#x27;#cpn&#x27;,</span><br><span class="line">            data() &#123;</span><br><span class="line">                return &#123;</span><br><span class="line">                    num: [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack的安装与配置</title>
    <url>/2022/08/02/Webpack%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="Webpack的安装与配置"><a href="#Webpack的安装与配置" class="headerlink" title="Webpack的安装与配置"></a>Webpack的安装与配置</h1><h2 id="Webpack介绍"><a href="#Webpack介绍" class="headerlink" title="Webpack介绍"></a>Webpack介绍</h2><ol>
<li>Webpack：Webpack是一个现代的JavaScript应用的静态模块打包工具</li>
<li>模块和打包<ol>
<li>模块化：webpack其中一个核心就是尽可能进行模块化开发，并且帮助处理模块间的依赖关系，不仅仅是JavaScript文件，CSS、图片、json文件等在webpack中都可以当做模块来使用，这就是webpack模块化</li>
<li>打包：将webpack中的各种资源进行打包合并成一个或多个包，并且在打包的过程中，对资源进行处理；比如压缩图片、讲scss转成css，将ES6语法转成ES5语法，讲TypeScript转成JavaScript等操作</li>
</ol>
</li>
<li>webpack的使用是依赖于node环境的，使用模块化方式进行开发时，不能将js&#x2F;png&#x2F;less&#x2F;css直接放到服务器中，因此需要在这中间使用webpack进行模块化打包，打包完成后会生成一个文件夹，然后把这个文件夹放到服务器进行部署</li>
<li>webpack、node和npm之间的关系<ol>
<li>webpack的为了可以正常使用是依赖于node环境，node环境为了可以正常的执行很多代码，必须其中包含各种依赖的包，为了使用这些包，我们就需要使用npm，npm就是一个包管理工具</li>
</ol>
</li>
</ol>
<h2 id="webpack安装"><a href="#webpack安装" class="headerlink" title="webpack安装"></a>webpack安装</h2><ol>
<li>安装webpack首先需要安装Node.js，Node.js自带了软件包管理工具npm</li>
<li>查看node版本：node -v</li>
<li>全局安装webpack：npm install <a href="mailto:webpack@3.6.0">webpack@3.6.0</a> -g<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211011003252.png" alt="img"></li>
<li>webpack（后续才需要）：npm install <a href="mailto:webpack@3.6.0">webpack@3.6.0</a> –save-dev<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211011003330.png" alt="img"></li>
<li>为什么全局安装后，还需要局部安装呢？<ol>
<li>在终端直接执行webpack命令，使用的全局安装的webpack</li>
<li>当在package.json中定义了scripts时，其中包含了webpack命令，那么使用的是局部webpack</li>
</ol>
</li>
</ol>
<h2 id="webpack准备工作"><a href="#webpack准备工作" class="headerlink" title="webpack准备工作"></a>webpack准备工作</h2><h3 id="文件和文件夹解析"><a href="#文件和文件夹解析" class="headerlink" title="文件和文件夹解析"></a>文件和文件夹解析</h3><ol>
<li>dist文件夹：用于存放之后打包的文件</li>
<li>src文件夹：用于存放我们写的源文件<ol>
<li>main.js：项目文件的入口文件</li>
<li>mathUtils.js：定义了一些数学工具函数，可以在其他地方引用，并且使用</li>
</ol>
</li>
<li>index.html：浏览器打开展示的首页html</li>
<li>package.json：通过npm init生成的，npm包管理的文件</li>
</ol>
<h2 id="webpack的基本使用过程"><a href="#webpack的基本使用过程" class="headerlink" title="webpack的基本使用过程"></a>webpack的基本使用过程</h2><h3 id="js文件的打包"><a href="#js文件的打包" class="headerlink" title="js文件的打包"></a>js文件的打包</h3><ol>
<li>打开终端，在vscode中按下ctrl + ~</li>
<li>通过cd命令进入根目录</li>
<li>输入：npx webpack .&#x2F;src&#x2F;main.js .&#x2F;dist&#x2F;bundle.js<ol>
<li>这句话的作用是：用webpack将.&#x2F;src&#x2F;main.js文件（入口文件）进行打包，打包到.&#x2F;dist&#x2F;bundle.js</li>
<li>webpack在打包.&#x2F;src&#x2F;main.js时，会查看该文件是否依赖其他文件，webpack会自动处理模块之间的依赖，然后对依赖文件也进行自动打包</li>
<li>打包时给webpack一个入口文件即可</li>
</ol>
</li>
<li>使用打包后的文件：将打包文件bundle.js打包到dist文件夹后，将打包文件bundle.js引入index.html文件内，模块化代码即可运行<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211011003356.png" alt="img"></li>
</ol>
<h3 id="webpack-config-js的入口出口文件配置"><a href="#webpack-config-js的入口出口文件配置" class="headerlink" title="webpack.config.js的入口出口文件配置"></a>webpack.config.js的入口出口文件配置</h3><ol>
<li>如果当每次使用webpack的命令都需要写上入口和出口作为参数，就非常麻烦；因此就需要将这两个参数写到配置中在运行时直接读取，就需要创建一个webpack.config.js文件</li>
<li>入口和出口的配置，见以下代码<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211011003419.png" alt="img"></li>
</ol>
<h3 id="package-josn配置"><a href="#package-josn配置" class="headerlink" title="package.josn配置"></a>package.josn配置</h3><ol>
<li>package.josn会在对npm（包管理工具）进行初始化npm init后生成</li>
<li>在npm初始化过程中会需要在终端输入一系列值，目前只需要输入package name即可，可以任意输入但是保证是纯英文</li>
<li>文件生成后主要配置”scripts”<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211011003437.png" alt="img"></li>
</ol>
<h3 id="局部安装webpack"><a href="#局部安装webpack" class="headerlink" title="局部安装webpack"></a>局部安装webpack</h3><ol>
<li>目前，我们使用的webpack是全局的webpack<ol>
<li>因为一个项目往往依赖特定的webpack版本，全局的版本可能很这个项目的webpack版本不一致，导出打包出现问题</li>
<li>所以通常一个项目，都有自己局部的webpack</li>
</ol>
</li>
<li>第一步：项目中需要安装自己的局部的webpack<ol>
<li>这里我们让局部安装webpack3.6.0</li>
<li>webpack局部安装：npm install <a href="mailto:webpack@3.6.0">webpack@3.6.0</a> –save-dev<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211011003455.png" alt="img"></li>
</ol>
</li>
<li>第二步：在package.json中的scripts中定义执行脚本，package.json中的scripts脚本执行时，会按照一定的顺序寻找命令对应的位置<ol>
<li>首先会寻找本地路径中对应的命令</li>
<li>如果没有找到，会去全局的环境变量中寻找</li>
<li>执行build指令 – npm run build<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211011003512.png" alt="img"></li>
<li>设置这个脚本就是为了让webpack优先执行本地的</li>
</ol>
</li>
</ol>
<h2 id="Webpack的配置（重点）"><a href="#Webpack的配置（重点）" class="headerlink" title="Webpack的配置（重点）"></a>Webpack的配置（重点）</h2><h3 id="处理css文件的loader"><a href="#处理css文件的loader" class="headerlink" title="处理css文件的loader"></a>处理css文件的loader</h3><ol>
<li><p>loader是webpack中一个非常核心的概念</p>
</li>
<li><p>webpack的用处</p>
<ol>
<li>在之前的实例中，我们主要是用webpack来处理写的js代码，并且webpack会自动处理js之间相关的依赖</li>
<li>但是，在开发中我们不仅仅有基本的js代码处理，我们也需要加载css、图片，也包括一些高级的将ES6转成ES5代码，将TypeScript转成ES5代码，将scss、less转成css，将.jsx、.vue文件转成js文件等等</li>
<li>对于webpack本身的能力来说，对于这些转化是不支持的，此时就需要给webpack扩展对应的loader</li>
</ol>
</li>
<li><p>在书写css文件后，需要让给main.js对css文件进行依赖，此时对文件进行打包（npm run build）会报错，报错原因就是因为没有安装css-loader</p>
</li>
<li><p>css文件处理 — css-loader和style-loader使用过程</p>
<ol>
<li>步骤一：通过npm安装需要使用的loader：css-loader和style-loader<ul>
<li>css-loader安装（安装时注意版本问题）：npm install –save-dev css-loader<ul>
<li>css-loader只负责对文件进行加载，不负责解析，css样式不会生效<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211011003549.png" alt="img"></li>
</ul>
</li>
<li>style-loader安装（安装时注意版本问题）：npm install –save-dev style-loader<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211011003605.png" alt="img"></li>
</ul>
</li>
<li>步骤二：在webpack.config.js中的module关键字下进行配置<ul>
<li>配置时style-loader需要放在css-loader的前面</li>
<li>因为在处理css文件的过程中，先由css-loader加载css文件，然后再由style-loder进行处理解析，将样式添加到DOM中</li>
<li>又由于在webpack读取使用loader的过程中，是按照从右到左的顺序读取的，因此style-loader需要放在css-loader的前面<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211011003620.png" alt="img"></li>
</ul>
</li>
</ol>
</li>
<li><p>对应loader的安装方法在webpack的官网中的loader文档中有详细说明</p>
</li>
<li><p>其他需要使用到的loader都可以在webpack官网中根据文档进行安装，比如less与less-loader，安装指令为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install less less-loader --save-dev    </span><br></pre></td></tr></table></figure>

<h3 id="处理图片文件的loader"><a href="#处理图片文件的loader" class="headerlink" title="处理图片文件的loader"></a>处理图片文件的loader</h3></li>
<li><p>资源准备</p>
<ol>
<li>一张较小的图片test01.jpg(小于8kb)，一张较大的图片test02.jpg(大于8kb)</li>
<li>待会儿我们会针对这两张图片进行不同的处理</li>
</ol>
</li>
<li><p>首先将test01.jpg（小于8kb）作为css样式背景，此时打包会报错，说明缺少loader</p>
<ol>
<li>图片处理，使用url-loader，安装loader：npm install –save-dev url-loader</li>
<li>安装完毕后，修改webpack.config.js配置文件<ul>
<li>当加载的图片，小于limit时，会将图片编译成base64字符串形式，</li>
<li>当加载的图片，大于limit时，需要使用file-loader模块进行加载<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211011003644.png" alt="img"></li>
</ul>
</li>
<li>再次打包，运行index.html，就会发现背景图片已经选出来了<ul>
<li>但是背景图片是通过base64显示的，这就是limit属性的作用，当图片小于8kb时，对图片进行base64编码<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211011003705.png" alt="img"></li>
</ul>
</li>
</ol>
</li>
<li><p>然后让test01.jgp（大于8kb）作为css样式背景，此时再次运行会报错，需要通过file-loader进行处理</p>
<ol>
<li>安装file-loader：npm install –save-dev file-loader</li>
<li>再次打包，就会发现第三条文件夹下多了一个图片文件<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211011003722.png" alt="img"></li>
<li>webpack自动帮我们生成一个非常长的名字<ul>
<li>这是一个32位hash值，目的是防止名字重复</li>
<li>但是，真实开发中，我们可能对打包的图片名字有一定的要求</li>
<li>比如，将所有的图片放在一个文件夹中，跟上图片原来的名称，同时也要防止重复</li>
</ul>
</li>
<li>所以我们需要在webpack.config.js配置文件的options中添加上以下选项<ul>
<li>img：文件要打包到的文件夹</li>
<li>name：获取图片原来的名字，放在该位置</li>
<li>hash:8：为了防止图片名称冲突，依然使用hash，但是我们只保留8位</li>
<li>ext：使用图片原来的扩展名<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211011003741.png" alt="img"></li>
</ul>
</li>
<li>但是此时图片并没有显示出来，这是因为图片路径使用不正确<ul>
<li>默认情况下，webpack会将生成的路径直接返回给使用者</li>
<li>但是我们整个程序是打包在dist文件夹下的，所以这里我们需要在路径下再添加一个dist&#x2F;<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211011003758.png" alt="img"></li>
</ul>
</li>
<li>此时再次npm run build，配置成功<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211011003812.png" alt="img"></li>
</ol>
</li>
</ol>
<h3 id="ES6转转ES5的loader"><a href="#ES6转转ES5的loader" class="headerlink" title="ES6转转ES5的loader"></a>ES6转转ES5的loader</h3><ol>
<li>仔细阅读webpack打包的js文件，发现写的ES6语法并没有转成ES5，那么就意味着可能一些对ES6还不支持的浏览器没有办法很好的运行我们的代码</li>
<li>在前面说过，如果希望将ES6的语法转成ES5，那么就需要使用babel<ol>
<li>在webpack中，直接使用babel-loader就可以</li>
</ol>
</li>
<li>安装babel-loader：npm install -save-dev babel-loader@7 babel-core babel-preset-es2015</li>
<li>配置webpack.config.js文件<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211011003905.png" alt="img"></li>
<li>此时npm run build，配置成功，es6成功全部转化为es5</li>
</ol>
<h3 id="使用Vue的配置过程"><a href="#使用Vue的配置过程" class="headerlink" title="使用Vue的配置过程"></a>使用Vue的配置过程</h3><ol>
<li>后续项目中，我们会使用Vuejs进行开发，而且会以特殊的文件来组织vue的组件</li>
<li>我们希望在项目中使用Vuejs，那么必然需要对其有依赖，所以需要先进行安装<ol>
<li>因为我们后续是在实际项目中也会使用vue的，所以并不是开发时依赖</li>
<li>安装vue：npm install –save vue</li>
</ol>
</li>
<li>安装完成后，重新打包运行刚刚在main文件中编写并引用完成的vue的程序<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211011003923.png" alt="img">1. 打包过程没有任何错误(因为只是多打包了一个vue的js文件而已) 2. 但是运行程序，没有出现想要的效果，而且浏览器中有报错 3. 这个错误说的是我们使用的是runtime-only版本的Vue 4. 报错原因：Vue不同版本构建；后续我具体学习runtime-only和runtime-compiler两个vue版本的区别 - runtime-only：代码中不可以有任何的template - runtime-compiler：代码中，可以有template，因为有compiler可以用于编译template 5. 解决方法：配置webpack.config.js文件<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211011003943.png" alt="img"></li>
</ol>
<h3 id="el和template区别"><a href="#el和template区别" class="headerlink" title="el和template区别"></a>el和template区别</h3><ol>
<li>定义template属性：使用template内容替换el绑定的元素<ol>
<li>在前面的Vue实例中，我们定义了el属性，用于和index.htmI中的#app进行绑定，让Vue实例之后可以管理它其中的内容</li>
<li>这里，我们可以将div元素中的{message}}内容删掉，只保留一个基本的id为div的元素</li>
<li>但是如果我依然希望在其中显示的内容，就应该定义一个template属性<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211011004000.png" alt="img"></li>
</ol>
</li>
</ol>
<h3 id="vue的终极使用方案"><a href="#vue的终极使用方案" class="headerlink" title="vue的终极使用方案"></a>vue的终极使用方案</h3><ol>
<li>.vue文件的封装处理<ol>
<li>在vscode中安装Vetur插件，在vue文件夹中创建.vue文件，并利用快捷键“&lt;&gt;”快速生成代码，生成的代码是默认使用export default导出子组件的</li>
<li>将子组件放入.vue文件中，将template模板、js文件都放入其中，在vue文件中还可以书写css样式<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211011004038.png" alt="img"></li>
</ol>
</li>
<li>将子组件在vue文件中书写完毕并导出后，在main.js中进行引入<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211011004106.png" alt="img">1. 此时进行npm run build会报错，因为没有安装vue-loader和vue-template-compiler，注意版本问题！ - npm install <a href="mailto:&#118;&#x75;&#101;&#45;&#x6c;&#111;&#97;&#x64;&#x65;&#114;&#x40;&#x31;&#x33;&#x2e;&#x30;&#x2e;&#x30;">&#118;&#x75;&#101;&#45;&#x6c;&#111;&#97;&#x64;&#x65;&#114;&#x40;&#x31;&#x33;&#x2e;&#x30;&#x2e;&#x30;</a> <a href="mailto:&#x76;&#117;&#101;&#45;&#x74;&#x65;&#109;&#112;&#x6c;&#97;&#x74;&#x65;&#x2d;&#x63;&#x6f;&#x6d;&#x70;&#105;&#108;&#101;&#x72;&#64;&#x32;&#x2e;&#x36;&#46;&#49;&#x34;">&#x76;&#117;&#101;&#45;&#x74;&#x65;&#109;&#112;&#x6c;&#97;&#x74;&#x65;&#x2d;&#x63;&#x6f;&#x6d;&#x70;&#105;&#108;&#101;&#x72;&#64;&#x32;&#x2e;&#x36;&#46;&#49;&#x34;</a> –save-dev 2. 配置webpack.config.js文件<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211011004126.png" alt="img">3. 配置成功</li>
</ol>
<h3 id="打包html的plugin"><a href="#打包html的plugin" class="headerlink" title="打包html的plugin"></a>打包html的plugin</h3><ol>
<li><p>目前，index.html文件是存放在项目根目录的</p>
<ol>
<li><p>在真实发布项目时，发布的是dist文件夹中的内容，但是dist文件夹中如果没有index.html文件，那么打包的js等文件也就没有意义了</p>
</li>
<li><p>所以，我们需要将index.html文件打包到dist文件夹中，这个时候就可以使用html-webpack-plugin插件</p>
<ul>
<li>npm install –save-dev <a href="mailto:html-webpack-plugin@3.2.0">html-webpack-plugin@3.2.0</a></li>
</ul>
</li>
<li><p>配置webpack.config.js文件<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211011004157.png" alt="img"><img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211011004206.png" alt="img"><img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211011004215.png" alt="img"></p>
</li>
<li><p>删除根目录下index.html文件script标签的文件引入，因为当npm run build后html-webpack-plugin插件会自动在dist文件夹下生成index.html文件，并自动完成引入bundle.js文件和自动生成</p>
</li>
<li><p>配置成功<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211011004234.png" alt="img"></p>
</li>
</ol>
</li>
</ol>
<h3 id="压缩丑化的plugin"><a href="#压缩丑化的plugin" class="headerlink" title="压缩丑化的plugin"></a>压缩丑化的plugin</h3><ol>
<li>在项目发布之前，我们需要对js等文件进行压缩处理<ol>
<li>这里需要使用一个第三方插件uglifyjs-webpack-plugin，并且指定版本号1.1.1，和CLI2保持一致<ul>
<li>npm install <a href="mailto:uglifyjs-webpack-plugin@1.1.1">uglifyjs-webpack-plugin@1.1.1</a> –save-dev</li>
</ul>
</li>
<li>配置webpack.config.js文件<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211011004253.png" alt="img"><img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211011004300.png" alt="img"></li>
</ol>
</li>
<li>配置成功，bundle.js丑化成功</li>
</ol>
<h3 id="搭建本地服务器"><a href="#搭建本地服务器" class="headerlink" title="搭建本地服务器"></a>搭建本地服务器</h3><ol>
<li>webpack提供了一个可选的本地开发服务器，这个本地服务器基于node.js搭建，内部使用express框架，可以实现我们想要的让浏览器自动刷新显示我们修改后的结果</li>
<li>不过它是一个单独的模块，在webpack中使用之前需要先安装它<ul>
<li>npm install –save-dev <a href="mailto:webpack-dev-server@2.9.3">webpack-dev-server@2.9.3</a></li>
</ul>
</li>
<li>devserver也是作为webpack中的一个选项，选项本身可以设置如下属性<ol>
<li>contentBase：为哪一个文件夹提供本地服务，默认是根文件夹，我们这里要填写.&#x2F;dist</li>
<li>port：端口号</li>
<li>inline：页面实时刷新</li>
<li>historyApiFallback：在SPA页面中，依赖HTML5的history模式</li>
</ol>
</li>
<li>配置webpack.config.js文件<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211011004321.png" alt="img"></li>
<li>再去package.json中配置一个scripts<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211011004338.png" alt="img"></li>
<li>使用npm run dev命令运行成功，点击终端中生成的本地8080端口网址，项目在本地成功运行<ol>
<li>此时在本地运行的项目，会实时根据代码的改变自动刷新，在开发时测试通常使用此方法</li>
<li>项目测试成功后最后使用npm run build，进行最后的打包，然后进入服务器进行最后的部署<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211011004357.png" alt="img"></li>
</ol>
</li>
<li>在package.json文件中配置一个scripts时加上–open参数表示npm run dev后不需要点击生成的本地链接直接打开浏览器<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211011004414.png" alt="img"></li>
</ol>
<h3 id="配置文件和分离"><a href="#配置文件和分离" class="headerlink" title="配置文件和分离"></a>配置文件和分离</h3><ol>
<li>由于开发时，经常会需要调试，所以不建议进行丑化代码；只有打包阶段时，才需要进行丑化</li>
<li>而搭建本地服务器时，需要给webpack的devserver选项配置一些属性</li>
<li>因此在webpack.config.js文件中，一些配置是开发时才会使用的（丑化代码），有一些配置是生产时使用的（搭建本地服务器给webpack的devserver选项配置属性）<ol>
<li>为了防止将这些配置全部放在webpack.config.js文件而造成冲突</li>
<li>创建一个build文件夹，在其中创建三个js文件，将webpack.config.js文件进行分离<ul>
<li>base.config.js：公共配置，开发和生产时都需要依赖</li>
<li>dev.config.js：仅开发时需要依赖</li>
<li>prod.config.js：仅生产时需要依赖</li>
</ul>
</li>
<li>将配置文件分离后<ul>
<li>在开发时需要用到base.config.js和dev.config.js文件</li>
<li>在生产时需要用到base.config.js和prod.config.js文件</li>
</ul>
</li>
<li>如上，为了在开发时能将项目所需配置文件合并在一起，则需要安装插件webpack-merge<ul>
<li>npm install <a href="mailto:webpack-merge@4.1.5">webpack-merge@4.1.5</a> –save-dev</li>
</ul>
</li>
<li>下载完毕后在dev.config.js和prod.config.js文件中需要进行导入插件，然后在两者中都引入base.config.js文件，最后利用插件进行合并文件<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211011004450.png" alt="img"><img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211011004500.png" alt="img"></li>
<li>由于已经将webpack.config.js文件已经进行了配置分离，然后就可以删除webpack.config.js文件了，删除之后npm run build会报错，报错原因是系统找不到webpack.config.js文件<ul>
<li>因此我们就需要到package.json文件中去修改scripts的build和dev值<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211011004531.png" alt="img"></li>
</ul>
</li>
<li>由于把分离后的三个js文件放到了build文件夹中，则打包后的dist文件夹也会创建在build文件夹中<ul>
<li>原因：这是因为在原来的webpack.config.js文件的output对象中的path属性的路径值问题造成的</li>
<li>解决方案：将base.config.js文件中的output对象的path属性的路径修改为相对于dist文件夹的相对路径即可<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211011004546.png" alt="img"></li>
</ul>
</li>
<li>配置成功</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue使用及基础语法</title>
    <url>/2022/08/02/Vue%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Vue使用及基础语法"><a href="#Vue使用及基础语法" class="headerlink" title="Vue使用及基础语法"></a>Vue使用及基础语法</h1><h2 id="Vue安装"><a href="#Vue安装" class="headerlink" title="Vue安装"></a>Vue安装</h2><h3 id="参考Vue官网https-cn-vuejs-org"><a href="#参考Vue官网https-cn-vuejs-org" class="headerlink" title="参考Vue官网https://cn.vuejs.org/"></a>参考Vue官网<a href="https://cn.vuejs.org/">https://cn.vuejs.org/</a></h3><h2 id="Vue使用"><a href="#Vue使用" class="headerlink" title="Vue使用"></a>Vue使用</h2><h3 id="第一个Vue程序"><a href="#第一个Vue程序" class="headerlink" title="第一个Vue程序"></a>第一个Vue程序</h3><p><img src="/2022/08/02/Vue%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/image-1.png" alt="image-1"></p>
<ol>
<li><p>创建一个Vue对象</p>
</li>
<li><p>创建Vue对象的时候，传入了一些options：{}</p>
<ol>
<li><p>{}中包含了el属性：该属性决定了这个Vue对象挂载到哪一个元素上，很明显，我们这里是挂载到了id为app的元素上</p>
</li>
<li><p>{}中包含了data属性：该属性中通常会存储一些数据</p>
<p>数据可以直接定义，或者来自网络，从服务器加载</p>
</li>
</ol>
</li>
<li><p>代码可以做到响应式的</p>
</li>
</ol>
<h2 id="创建Vue实例传入的options"><a href="#创建Vue实例传入的options" class="headerlink" title="创建Vue实例传入的options"></a>创建Vue实例传入的options</h2><p>目前掌握：</p>
<ol>
<li>el（挂载点）:</li>
</ol>
<ul>
<li>类型：string | HTMLElement</li>
<li>作用：决定之后Vue实例会管理哪一个DOM。</li>
</ul>
<ol start="2">
<li>data（数据）:</li>
</ol>
<ul>
<li>类型：Object | Function （组件当中data必须是一个函数）</li>
<li>作用：Vue实例对应的数据对象。</li>
</ul>
<ol start="3">
<li>methods（方法）:</li>
</ol>
<ul>
<li>类型：{ [key: string]: Function }</li>
<li>作用：定义属于Vue的一些方法，可以在其他地方调用，也可以在指令中使用。</li>
</ul>
<h2 id="Vue生命周期"><a href="#Vue生命周期" class="headerlink" title="Vue生命周期"></a>Vue生命周期</h2><h3 id="生命周期图示"><a href="#生命周期图示" class="headerlink" title="生命周期图示"></a>生命周期图示</h3><p><img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211127152812.png" alt="img"></p>
<h3 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h3><ol>
<li>生命周期钩子 &#x3D; 生命周期函数 &#x3D; 生命周期事件</li>
</ol>
<h4 id="生命周期钩子（函数）的分类"><a href="#生命周期钩子（函数）的分类" class="headerlink" title="生命周期钩子（函数）的分类"></a>生命周期钩子（函数）的分类</h4><ol>
<li>创建期间的生命周期钩子（函数）</li>
<li>运行期间的生命周期钩子（函数）</li>
<li>销毁期间的生命周期钩子（函数）</li>
</ol>
<h4 id="创建期间的生命周期钩子"><a href="#创建期间的生命周期钩子" class="headerlink" title="创建期间的生命周期钩子"></a>创建期间的生命周期钩子</h4><ol>
<li>beforeCreate：在实例初始化之后，进行数据监听和事件&#x2F;监听器的配置之前同步调用</li>
<li>created：在实例创建完成后被立即同步调用，此时数据、计算属性、方法、事件&#x2F;监听器的回调函数都以及配置完毕，但是挂载阶段还未开始；若要调用methods，或者操作data数据，最早只能在created钩子中进行</li>
<li>beforeMount：此函数执行时模板已经在内存中，但是还未挂载到页面中</li>
</ol>
<h4 id="运行期间的生命周期钩子"><a href="#运行期间的生命周期钩子" class="headerlink" title="运行期间的生命周期钩子"></a>运行期间的生命周期钩子</h4><ol>
<li><p><strong>mounted：若如果要通过某些插件操作页面上的DOM节点，最早要在mounted中进行</strong></p>
<ol>
<li><p>注意：mounted不会保证所有的子组件也都被挂载完成。如果你希望等到整个视图都渲染完毕再执行某些操作，<strong>可以在mounted内部使用vm.$nextTick</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mounted: function() &#123; </span><br><span class="line">    this.$nextTick(function() &#123; </span><br><span class="line">        // 仅在整个视图都被渲染之后才会运行的代码 </span><br><span class="line">    &#125;) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>beforeUpdate：在数据发生改变后，DOM被更新之前被调用</p>
</li>
<li><p>update：在数据更改导致的虚拟 DOM 重新渲染和更新完毕之后被调用</p>
<ol>
<li><p>注意：update不会保证所有的子组件也都被挂载完成。如果你希望等到整个视图都渲染完毕再执行某些操作，<strong>可以在update内部使用vm.$nextTick</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update: function() &#123; </span><br><span class="line">    this.$nextTick(function() &#123; </span><br><span class="line">        // 仅在整个视图都被渲染之后才会运行的代码 </span><br><span class="line">    &#125;) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h4 id="销毁期间的生命周期钩子"><a href="#销毁期间的生命周期钩子" class="headerlink" title="销毁期间的生命周期钩子"></a>销毁期间的生命周期钩子</h4><ol>
<li><strong>beforeDestory</strong>：实例销毁之前调用，这一步实例仍然完全可用</li>
<li>destroyed：实例销毁后调用，此时组件中所有的数据，方法，指令，过滤器都不可再用</li>
</ol>
<h3 id="常用的生命周期钩子"><a href="#常用的生命周期钩子" class="headerlink" title="常用的生命周期钩子"></a>常用的生命周期钩子</h3><ol>
<li><strong>mounted：发送ajax请求、启用定时器、绑定自定义事件、订阅消息等（初始化操作）</strong></li>
<li><strong>beforeDestroy：清除定时器、绑定自定义事件、取消订阅消息等（收尾操作）</strong></li>
</ol>
<h2 id="Vue基础语法"><a href="#Vue基础语法" class="headerlink" title="Vue基础语法"></a>Vue基础语法</h2><h3 id="Mustache语法-也就是双大括号"><a href="#Mustache语法-也就是双大括号" class="headerlink" title="Mustache语法(也就是双大括号)"></a>Mustache语法(也就是双大括号)</h3><ol>
<li>该语法不仅可以直接写变量，还可以写简单的表达式，只能在标签的内容区使用</li>
</ol>
<h3 id="Vue指令"><a href="#Vue指令" class="headerlink" title="Vue指令"></a>Vue指令</h3><h4 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a>v-once</h4><ul>
<li>该指令后面不需要跟任何表达式</li>
<li>该指令表示元素和组件只渲染一次，不会随着数据的改变而改变。</li>
</ul>
<h4 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h4><ol>
<li>将解析出的HTML展示</li>
</ol>
<ul>
<li><p>该指令后面往往会跟上一个string类型</p>
</li>
<li><p>会将string的html解析出来并且进行渲染</p>
</li>
</ul>
<ol start="2">
<li>某些情况下，我们从服务器请求到的数据本身就是一个HTML代码，如果我们直接通过<code>&#123;&#123;&#125;&#125;</code>来输出，会将HTML代码也一起输出，但是我们可能希望的是按照HTML格式进行解析，并且显示对应的内容，这就得使用v-html指令。</li>
</ol>
<p><img src="/2022/08/02/Vue%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/image-2.png" alt="image-2"></p>
<h4 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h4><ul>
<li>v-text作用和Mustache比较相似：都是用于将数据显示在界面中</li>
<li>v-text通常情况下，接受一个string类型</li>
</ul>
<h4 id="v-pre"><a href="#v-pre" class="headerlink" title="v-pre"></a>v-pre</h4><ul>
<li>v-pre用于跳过这个元素和它子元素的编译过程，用于显示原本的Mustache语法。</li>
</ul>
<h2 id="绑定属性（v-bind）"><a href="#绑定属性（v-bind）" class="headerlink" title="绑定属性（v-bind）"></a>绑定属性（v-bind）</h2><h3 id="v-bind（重要）"><a href="#v-bind（重要）" class="headerlink" title="v-bind（重要）"></a>v-bind（重要）</h3><h4 id="v-bind基础"><a href="#v-bind基础" class="headerlink" title="v-bind基础"></a>v-bind基础</h4><ul>
<li>v-bind用于绑定一个或多个属性值，或者向另一个组件传递props值（组件中会有介绍props值）</li>
<li>开发中还有许多属性需要动态进行绑定，比如图片的链接src、网站的链接href、动态绑定一些类、样式等等</li>
</ul>
<p><img src="/2022/08/02/Vue%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/image-3.png" alt="image-3"></p>
<ul>
<li>v-bind有语法糖，简写方式是将v-bind替换成：即可</li>
</ul>
<h4 id="v-bind动态绑定class"><a href="#v-bind动态绑定class" class="headerlink" title="v-bind动态绑定class"></a>v-bind动态绑定class</h4><p>绑定class有两种方式</p>
<ol>
<li>对象语法，class后面跟对象</li>
</ol>
<p>用法：</p>
<ul>
<li>直接通过{}绑定一个类</li>
<li>也可以通过判断，传入多个值</li>
<li>和普通的类同时存在，并不冲突</li>
<li>如果过于复杂，可以放在一个methods或者computed中</li>
</ul>
<p><img src="/2022/08/02/Vue%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/image-4.png" alt="image-4"></p>
<ol start="2">
<li>数组语法，class后面跟数组</li>
</ol>
<p>用法：</p>
<ul>
<li>直接通过[]绑定一个类</li>
<li>也可以传入多个值</li>
<li>和普通的类同时存在，并不冲突</li>
<li>如果过于复杂，可以放在一个methods或者computed中</li>
</ul>
<p><img src="/2022/08/02/Vue%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/image-5.png" alt="image-5"></p>
<h4 id="v-bind绑定style"><a href="#v-bind绑定style" class="headerlink" title="v-bind绑定style"></a>v-bind绑定style</h4><p>v-bind:style可以绑定些CSS内联样式。<br>在写CSS属性名的时候，比如font-size</p>
<ul>
<li>可以使用驼峰式 (camelCase)  fontSize</li>
<li>或短横线分隔 (kebab-case，记得用单引号括起来) ‘font-size’</li>
</ul>
<p>绑定style有两种方式：</p>
<ol>
<li><p>对象语法</p>
<p>v-bind:style&#x3D;”{key(属性名): value(属性值)}”</p>
<p>style后面跟的是一个对象类型，对象的key是CSS属性名称，对象的value是具体赋的值，值可以来自于data中的属性</p>
<p><img src="/2022/08/02/Vue%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/image-6.png" alt="image-6"></p>
</li>
<li><p>数组语法</p>
<pre><code>v-bind:style=&quot;&#123;key(属性名): value(属性值)&#125;&quot;
 
style后面跟的是一个数组类型，多个值以，分割即可
</code></pre>
<p><img src="/2022/08/02/Vue%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/image-7.png" alt="image-7"></p>
</li>
</ol>
<h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><h3 id="计算属性基本使用"><a href="#计算属性基本使用" class="headerlink" title="计算属性基本使用"></a>计算属性基本使用</h3><ul>
<li>需要对数据进行一些转化后再显示，或者需要将多个数据结合起来进行显示则需要使用计算属性</li>
<li>计算属性是写在实例的computed选项中的</li>
</ul>
<p>computed：（计算属性）</p>
<p><img src="/2022/08/02/Vue%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/image-8.png" alt="image-8"></p>
<h3 id="计算属性的setter和getter"><a href="#计算属性的setter和getter" class="headerlink" title="计算属性的setter和getter"></a>计算属性的setter和getter</h3><p>每个计算属性都包含一个getter和一个setter（不常用）</p>
<p><img src="/2022/08/02/Vue%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/image-9.png" alt="image-9"></p>
<h3 id="计算属性的缓存-计算属性和methods的对比"><a href="#计算属性的缓存-计算属性和methods的对比" class="headerlink" title="计算属性的缓存(计算属性和methods的对比)"></a>计算属性的缓存(计算属性和methods的对比)</h3><ul>
<li>计算属性会进行缓存，如果多次使用时，计算属性只会调用一次。</li>
</ul>
<h2 id="ES6补充"><a href="#ES6补充" class="headerlink" title="ES6补充"></a>ES6补充</h2><h3 id="ES6对象字面量的增强写法"><a href="#ES6对象字面量的增强写法" class="headerlink" title="ES6对象字面量的增强写法"></a>ES6对象字面量的增强写法</h3><ul>
<li>属性的增强写法</li>
</ul>
<p><img src="/2022/08/02/Vue%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/image-10.png" alt="image-10"></p>
<ul>
<li>函数的增强写法</li>
</ul>
<p><img src="/2022/08/02/Vue%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/image-11.png" alt="image-11"></p>
<h2 id="事件监听v-on"><a href="#事件监听v-on" class="headerlink" title="事件监听v-on"></a>事件监听v-on</h2><h3 id="v-on基础"><a href="#v-on基础" class="headerlink" title="v-on基础"></a>v-on基础</h3><p>v-on介绍</p>
<ul>
<li>作用：绑定事件监听器</li>
<li>缩写（语法糖）：@</li>
<li>预期：Function | Inline Statement | Object</li>
<li>参数：event</li>
</ul>
<h3 id="v-on参数"><a href="#v-on参数" class="headerlink" title="v-on参数"></a>v-on参数</h3><p>当通过methods中定义方法，以供@click调用时，需要注意参数问题：<br>情况一：如果该方法不需要额外参数，那么方法后的()可以不添加。</p>
<ul>
<li>注意：如果方法本身中有一个参数，那么会默认将原生事件event参数传递进去</li>
</ul>
<p>情况二：如果需要同时传入某个参数，同时需要event时，可以通过$event传入事件。</p>
<h3 id="v-on修饰符"><a href="#v-on修饰符" class="headerlink" title="v-on修饰符"></a>v-on修饰符</h3><ul>
<li>.stop - 调用 event.stopPropagation()。阻止冒泡<a href="mailto:&#45;&#x40;&#x63;&#108;&#x69;&#99;&#x6b;&#46;&#x73;&#116;&#111;&#x70;">&#45;&#x40;&#x63;&#108;&#x69;&#99;&#x6b;&#46;&#x73;&#116;&#111;&#x70;</a></li>
<li>.prevent - 调用 event.preventDefault()。阻止默认行为<a href="mailto:&#45;&#x40;&#x63;&#108;&#105;&#99;&#107;&#46;&#x70;&#x72;&#101;&#118;&#x65;&#x6e;&#116;">&#45;&#x40;&#x63;&#108;&#105;&#99;&#107;&#46;&#x70;&#x72;&#101;&#118;&#x65;&#x6e;&#116;</a></li>
<li>.{keyCode | keyAlias} - 只当事件是从特定键触发时才触发回调。</li>
<li>.native - 监听组件根元素的原生事件。</li>
<li>.once - 只触发一次回调。</li>
</ul>
<h2 id="条件判断v-if，v-else-if，v-else"><a href="#条件判断v-if，v-else-if，v-else" class="headerlink" title="条件判断v-if，v-else-if，v-else"></a>条件判断v-if，v-else-if，v-else</h2><h3 id="v-if，v-else-if，v-else"><a href="#v-if，v-else-if，v-else" class="headerlink" title="v-if，v-else-if，v-else"></a>v-if，v-else-if，v-else</h3><ul>
<li>与JavaScript的条件语句if、else、else if类似。</li>
<li>简单的条件判断可以使用v-if和v-else，比较复杂的逻辑判断，建议用计算属性computed中写。</li>
</ul>
<p><img src="/2022/08/02/Vue%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/image-12.png" alt="image-12"></p>
<h3 id="v-show和v-if"><a href="#v-show和v-if" class="headerlink" title="v-show和v-if"></a>v-show和v-if</h3><ol>
<li>v-show：用于决定元素是否进行渲染</li>
<li>v-show和v-if的用法和功能非常相似，它们的区别是<ol>
<li>v-if当条件为false时，不会有对应的元素在DOM中，是通过操作（添加或移除）DOM元素切换显示状态</li>
<li>v-show当条件为false时，仅仅是在元素内添加行内样式display: none</li>
</ol>
</li>
<li>开发中的选择<ol>
<li>当需要在显示与隐藏之间来回切换使用：v-show</li>
<li>当只有一次切换使用：v-if</li>
</ol>
</li>
</ol>
<h2 id="遍历循环v-for"><a href="#遍历循环v-for" class="headerlink" title="遍历循环v-for"></a>遍历循环v-for</h2><h3 id="v-for遍历数组"><a href="#v-for遍历数组" class="headerlink" title="v-for遍历数组"></a>v-for遍历数组</h3><h3 id="v-for遍历对象"><a href="#v-for遍历对象" class="headerlink" title="v-for遍历对象"></a>v-for遍历对象</h3><ol>
<li>获取key和value，格式：(key, value)</li>
<li>获取key、value和index，格式：(key, value, index)</li>
</ol>
<p><img src="/2022/08/02/Vue%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/image-13.png" alt="image-13"></p>
<p>3.案例：点击文字颜色改变，通过索引号实现（常用）</p>
<p><img src="/2022/08/02/Vue%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/image-14.png" alt="image-14"></p>
<h3 id="数组中是响应式的方法"><a href="#数组中是响应式的方法" class="headerlink" title="数组中是响应式的方法"></a>数组中是响应式的方法</h3><ol>
<li>push()：在数组末位添加元素</li>
<li>unshift()：在数组首位添加元素</li>
<li>pop()：在数组末位删除元素</li>
<li>shift()：在数组首位删除元素</li>
<li><strong>splice()：删除元素 &#x2F; 插入元素 &#x2F; 替换元素</strong></li>
</ol>
<ul>
<li>删除元素: 第二个参数传入你要删除几个元素(如果没有传,就删除后面所有的元素)</li>
<li>替换元素: 第二个参数, 表示我们要替换几个元素, 后面是用于替换前面的元素</li>
<li>插入元素: 第二个参数, 传入0, 并且后面跟上要插入的元素</li>
</ul>
<h2 id="JavaScript中三个高阶函数的使用"><a href="#JavaScript中三个高阶函数的使用" class="headerlink" title="JavaScript中三个高阶函数的使用"></a>JavaScript中三个高阶函数的使用</h2><h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><ol>
<li>filter()：检查数值元素，并返回符合条件所有元素的数组</li>
<li>语法：array.filter(function(currentValue, index, arr), thisValue)<ol>
<li>currentValue：当前被遍历的元素的值</li>
<li>index：可选，当前元素的索引值</li>
<li>arr：可选，当前元素属于的数组对象</li>
</ol>
</li>
</ol>
<h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><ol>
<li>map()：通过指定函数处理数组的每个元素，并返回处理后的数组</li>
<li>语法：array.map(function(currentValue, index, arr), thisValue)<ol>
<li>currentValue：当前被遍历的元素的值</li>
<li>index：可选，当前元素的索引值</li>
<li>arr：可选，当前元素属于的数组对象</li>
</ol>
</li>
</ol>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h3><ol>
<li><p>reduce()：将数组元素计算为一个值</p>
</li>
<li><p>语法：array.reduce(function(total, currentValue, currentIndex, arr), initialValue)</p>
<ol>
<li>total：必需，初始值，或者计算结束后的返回值</li>
<li>currentValue：必需，当前遍历元素的值</li>
<li>currentIndex：可选，当前元素的索引</li>
<li>arr：可选当前元素所属的数组对象</li>
<li>initialValue：可选，传递给函数的初始值</li>
</ol>
<p><img src="/2022/08/02/Vue%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/image-15.png" alt="image-15"></p>
</li>
</ol>
<h2 id="表单绑定v-model"><a href="#表单绑定v-model" class="headerlink" title="表单绑定v-model"></a>表单绑定v-model</h2><h3 id="表单绑定v-model-1"><a href="#表单绑定v-model-1" class="headerlink" title="表单绑定v-model"></a>表单绑定v-model</h3><ol>
<li>表单控件在实际开发中是非常常见的。特别是对于用户信息的提交，需要大量的表单。</li>
<li>Vue中使用v-model指令来实现表单元素和数据的双向绑定。</li>
<li>案例的解析：<ol>
<li>当我们在输入框输入内容时</li>
<li>因为input中的v-model绑定了message，所以会实时将输入的内容传递给message，message发生改变。</li>
<li>当message发生改变时，因为上面我们使用Mustache语法，将message的值插入到DOM中，所以DOM会发生响应的改变。</li>
<li>所以，通过v-model实现了双向的绑定。</li>
</ol>
</li>
</ol>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line"> &lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;</span><br><span class="line">  &#123;&#123;message&#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const app = new Vue(&#123;</span><br><span class="line">    el: &#x27;#app&#x27;,</span><br><span class="line">    data: &#123;</span><br><span class="line">      message: &#x27;你好啊&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="v-model原理"><a href="#v-model原理" class="headerlink" title="v-model原理"></a>v-model原理</h3><ol>
<li><p>v-model其实是一个语法糖，它的背后本质上是包含两个操作：</p>
<ol>
<li><p>v-bind绑定一个value属性</p>
</li>
<li><p>v-on指令给当前元素绑定input事件</p>
</li>
</ol>
</li>
<li><p>也就是说下面的代码：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>等同于下面的代码：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; v-bind:value=&quot;message&quot; v-on:input=&quot;message = $event.target.value&quot;&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;!--&lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;--&gt;</span><br><span class="line"> </span><br><span class="line">  &lt;!-- 上面等同于 --&gt;</span><br><span class="line">  &lt;!--&lt;input type=&quot;text&quot; :value=&quot;message&quot; @input=&quot;valueChange&quot;&gt;--&gt;</span><br><span class="line"> </span><br><span class="line">  &lt;!-- 也就是 --&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; :value=&quot;message&quot; @input=&quot;message = $event.target.value&quot;&gt;</span><br><span class="line">  &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const app = new Vue(&#123;</span><br><span class="line">    el: &#x27;#app&#x27;,</span><br><span class="line">    data: &#123;</span><br><span class="line">      message: &#x27;你好啊&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      valueChange(event) &#123;</span><br><span class="line">        this.message = event.target.value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="v-model结合radio类型使用"><a href="#v-model结合radio类型使用" class="headerlink" title="v-model结合radio类型使用"></a>v-model结合radio类型使用</h3><ol>
<li>当存在多个单选框时</li>
<li>单选按钮radio的value会影响v-model的值(input得有value属性，value是什么获取到的就是什么)</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;label for=&quot;male&quot;&gt;</span><br><span class="line">    &lt;!-- 需要加相同的name 否则可以多选 --&gt;</span><br><span class="line">    &lt;!-- &lt;input type=&quot;radio&quot; id=&quot;male&quot; value=&quot;男&quot; name=&quot;sex&quot;&gt;男 --&gt;</span><br><span class="line">    &lt;!-- 一旦v-moddel绑定的是同一个变量，name可以不用写 --&gt;</span><br><span class="line">    &lt;input type=&quot;radio&quot; id=&quot;male&quot; value=&quot;男&quot; v-model=&quot;sex&quot;&gt;男</span><br><span class="line">  &lt;/label&gt;</span><br><span class="line">  &lt;label for=&quot;female&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;radio&quot; id=&quot;female&quot; value=&quot;女&quot; v-model=&quot;sex&quot;&gt;女</span><br><span class="line">  &lt;/label&gt;</span><br><span class="line">  &lt;label for=&quot;other&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;radio&quot; id=&quot;other&quot; value=&quot;其他&quot; v-model=&quot;sex&quot;&gt;其他</span><br><span class="line">  &lt;/label&gt;</span><br><span class="line">  &lt;h2&gt;您选择的性别是: &#123;&#123;sex&#125;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const app = new Vue(&#123;</span><br><span class="line">    el: &#x27;#app&#x27;,</span><br><span class="line">    data: &#123;</span><br><span class="line">      message: &#x27;你好啊&#x27;,</span><br><span class="line">      sex: &#x27;女&#x27; // 可以给radio默认值</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="v-model结合checkbox类型使用"><a href="#v-model结合checkbox类型使用" class="headerlink" title="v-model结合checkbox类型使用"></a>v-model结合checkbox类型使用</h3><ol>
<li>复选框分为两种情况：单个勾选框和多个勾选框</li>
<li>单个勾选框：<ol>
<li>v-model即为布尔值。</li>
<li>此时input的value并不影响v-model的值。</li>
</ol>
</li>
<li>多个复选框：<ol>
<li>当是多个复选框时，因为可以选中多个，所以对应的data中属性是一个数组。</li>
<li>当选中某一个时，就会将input的value添加到数组中。</li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">   &lt;!--1.checkbox单选框 --&gt;</span><br><span class="line">   &lt;!-- </span><br><span class="line">     v-model即为布尔值true/false。</span><br><span class="line">     此时input的value并不影响v-model的值</span><br><span class="line">--&gt;</span><br><span class="line">   &lt;label for=&quot;agree&quot;&gt;</span><br><span class="line">     &lt;input type=&quot;checkbox&quot; id=&quot;agree&quot; v-model=&quot;isAgree&quot;&gt;同意协议</span><br><span class="line">   &lt;/label&gt;</span><br><span class="line">   &lt;h2&gt;您选择的是: &#123;&#123;isAgree&#125;&#125;&lt;/h2&gt;</span><br><span class="line">   &lt;button :disabled=&quot;!isAgree&quot;&gt;下一步&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!--2.checkbox多选框--&gt;</span><br><span class="line">   &lt;!-- </span><br><span class="line">     当是多个复选框时，因为可以选中多个，所以对应的data中属性是一个数组。</span><br><span class="line">     当选中某一个时，就会将input的value添加到数组中。</span><br><span class="line">  --&gt;</span><br><span class="line">   &lt;input type=&quot;checkbox&quot; value=&quot;篮球&quot; v-model=&quot;hobbies&quot;&gt;篮球</span><br><span class="line">   &lt;input type=&quot;checkbox&quot; value=&quot;足球&quot; v-model=&quot;hobbies&quot;&gt;足球</span><br><span class="line">   &lt;input type=&quot;checkbox&quot; value=&quot;乒乓球&quot; v-model=&quot;hobbies&quot;&gt;乒乓球</span><br><span class="line">   &lt;input type=&quot;checkbox&quot; value=&quot;羽毛球&quot; v-model=&quot;hobbies&quot;&gt;羽毛球</span><br><span class="line">   &lt;h2&gt;您的爱好是: &#123;&#123;hobbies&#125;&#125;&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 值绑定 动态的给value赋值 --&gt;</span><br><span class="line">   &lt;label v-for=&quot;item in originHobbies&quot; :for=&quot;item&quot;&gt;</span><br><span class="line">     &lt;input type=&quot;checkbox&quot; :value=&quot;item&quot; :id=&quot;item&quot; v-model=&quot;hobbies&quot;&gt;&#123;&#123;item&#125;&#125;</span><br><span class="line">   &lt;/label&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"> &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"> &lt;script&gt;</span><br><span class="line">   const app = new Vue(&#123;</span><br><span class="line">     el: &#x27;#app&#x27;,</span><br><span class="line">     data: &#123;</span><br><span class="line">       message: &#x27;你好啊&#x27;,</span><br><span class="line">       isAgree: false, // 单选框</span><br><span class="line"></span><br><span class="line">       hobbies: [], // 多选框,</span><br><span class="line">       originHobbies: [&#x27;篮球&#x27;, &#x27;足球&#x27;, &#x27;乒乓球&#x27;, &#x27;羽毛球&#x27;, &#x27;台球&#x27;, &#x27;高尔夫球&#x27;]</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;)</span><br><span class="line"> &lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="v-model结合select类型使用"><a href="#v-model结合select类型使用" class="headerlink" title="v-model结合select类型使用"></a>v-model结合select类型使用</h3><ol>
<li>和checkbox一样，select也分单选和多选两种情况。</li>
<li>单选：只能选中一个值。<ol>
<li>v-model绑定的是一个值。</li>
<li>当我们选中option中的一个时，会将它对应的value赋值到mySelect中</li>
</ol>
</li>
<li>多选：可以选中多个值。<ol>
<li>v-model绑定的是一个数组。</li>
<li>当选中多个值时，就会将选中的option对应的value添加到数组mySelects中</li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;!--1.选择一个--&gt;</span><br><span class="line">  &lt;!-- </span><br><span class="line">  单选：只能选中一个值。</span><br><span class="line">  v-model绑定的是一个值。</span><br><span class="line">  当我们选中option中的一个时，会将它对应的value赋值到mySelect中</span><br><span class="line"> --&gt;</span><br><span class="line">  &lt;!-- v-model绑定在select标签 --&gt;</span><br><span class="line">  &lt;select name=&quot;abc&quot; v-model=&quot;fruit&quot;&gt;</span><br><span class="line">    &lt;option value=&quot;苹果&quot;&gt;苹果&lt;/option&gt;</span><br><span class="line">    &lt;option value=&quot;香蕉&quot;&gt;香蕉&lt;/option&gt;</span><br><span class="line">    &lt;option value=&quot;榴莲&quot;&gt;榴莲&lt;/option&gt;</span><br><span class="line">    &lt;option value=&quot;葡萄&quot;&gt;葡萄&lt;/option&gt;</span><br><span class="line">  &lt;/select&gt;</span><br><span class="line">  &lt;h2&gt;您选择的水果是: &#123;&#123;fruit&#125;&#125;&lt;/h2&gt;</span><br><span class="line"> </span><br><span class="line">  &lt;!--2.选择多个--&gt;</span><br><span class="line">  &lt;!-- </span><br><span class="line">  v-model绑定的是一个数组。</span><br><span class="line">  当选中多个值时，就会将选中的option对应的value添加到数组mySelects中</span><br><span class="line"> --&gt;</span><br><span class="line">  &lt;!-- 加上multiple属性就可以多选 要按ctrl才能多选 --&gt;</span><br><span class="line">  &lt;select name=&quot;abc&quot; v-model=&quot;fruits&quot; multiple&gt;</span><br><span class="line">    &lt;option value=&quot;苹果&quot;&gt;苹果&lt;/option&gt;</span><br><span class="line">    &lt;option value=&quot;香蕉&quot;&gt;香蕉&lt;/option&gt;</span><br><span class="line">    &lt;option value=&quot;榴莲&quot;&gt;榴莲&lt;/option&gt;</span><br><span class="line">    &lt;option value=&quot;葡萄&quot;&gt;葡萄&lt;/option&gt;</span><br><span class="line">  &lt;/select&gt;</span><br><span class="line">  &lt;h2&gt;您选择的水果是: &#123;&#123;fruits&#125;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const app = new Vue(&#123;</span><br><span class="line">    el: &#x27;#app&#x27;,</span><br><span class="line">    data: &#123;</span><br><span class="line">      message: &#x27;你好啊&#x27;,</span><br><span class="line">      fruit: &#x27;香蕉&#x27;,</span><br><span class="line">      fruits: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="input中的值绑定"><a href="#input中的值绑定" class="headerlink" title="input中的值绑定"></a>input中的值绑定</h3><ol>
<li>前面的value中的值，都是在定义input的时候直接给定的。但是真实开发中，这些input的值可能是从网络获取或定义在data中的，所以我们可以通过v-bind:value动态的给value绑定值。</li>
</ol>
<h3 id="v-model-修饰符的使用"><a href="#v-model-修饰符的使用" class="headerlink" title="v-model 修饰符的使用"></a>v-model 修饰符的使用</h3><ol>
<li>lazy修饰符：<ol>
<li>默认情况下，v-model默认是在input事件中同步输入框的数据的。</li>
<li>也就是说，一旦有数据发生改变对应的data中的数据就会自动发生改变。</li>
<li>lazy修饰符可以让数据在失去焦点或者回车时才会更新</li>
</ol>
</li>
<li>number修饰符：<ol>
<li>默认情况下，在输入框中无论输入的是字母还是数字都会被当做字符串类型进行处理。</li>
<li>但是如果我们希望处理的是数字类型，那么最好直接将内容当做数字处理。</li>
<li>number修饰符可以让在输入框中输入的内容自动转成数字类型</li>
</ol>
</li>
<li>trim修饰符：<ol>
<li>如果输入的内容首尾有很多空格，通常我们希望将其去除</li>
<li>trim修饰符可以过滤内容左右两边的空格</li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;!--1.修饰符: lazy 让数据在失去焦点或者回车时才会更新--&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; v-model.lazy=&quot;message&quot;&gt;</span><br><span class="line">  &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  &lt;!--2.修饰符: number 让在输入框中输入的内容自动转成数字类型--&gt;</span><br><span class="line">  &lt;input type=&quot;number&quot; v-model.number=&quot;age&quot;&gt;</span><br><span class="line">  &lt;h2&gt;&#123;&#123;age&#125;&#125;-&#123;&#123;typeof age&#125;&#125;&lt;/h2&gt;</span><br><span class="line"> </span><br><span class="line">  &lt;!--3.修饰符: trim 过滤内容左右两边的空格--&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; v-model.trim=&quot;name&quot;&gt;</span><br><span class="line">  &lt;h2&gt;您输入的名字:&#123;&#123;name&#125;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const app = new Vue(&#123;</span><br><span class="line">    el: &#x27;#app&#x27;,</span><br><span class="line">    data: &#123;</span><br><span class="line">      message: &#x27;你好啊&#x27;,</span><br><span class="line">      age: 0,</span><br><span class="line">      name: &#x27;&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"> </span><br><span class="line">  var age = 0</span><br><span class="line">  age = &#x27;1111&#x27;</span><br><span class="line">  age = &#x27;222&#x27;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>axios</title>
    <url>/2022/08/02/axios/</url>
    <content><![CDATA[<h1 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h1><ol>
<li><p>axios是一个基于Promise的HTTP库</p>
</li>
<li><p>安装方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install axios</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="axios请求方式"><a href="#axios请求方式" class="headerlink" title="axios请求方式"></a>axios请求方式</h2><ol>
<li><p>axios(config)请求方式</p>
<p><img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211120121916.png" alt="img"><img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211120121933.png" alt="img"></p>
</li>
<li><p>axios.request(config)请求方式</p>
</li>
<li><p>axios.get(url[, config])请求方式</p>
</li>
<li><p>axios.delete(url[, config])请求方式</p>
</li>
<li><p>axios.head(url[, config])请求方式</p>
</li>
<li><p>axios.post(url[, data[, config]1)请求方式</p>
</li>
<li><p>axios.put(url[, data[ config])请求方式</p>
</li>
<li><p>axios.patch(url[, data[, config])请求方式</p>
</li>
</ol>
<h2 id="发送并发请求"><a href="#发送并发请求" class="headerlink" title="发送并发请求"></a>发送并发请求</h2><ol>
<li><p>有时候，可能会遇到需要同时发送两个或更多请求</p>
<ol>
<li><p>使用<strong>axios.all()方法</strong>，可以放入多个请求的数组</p>
</li>
<li><p><strong>axios.all([])返回的结果是一个数组</strong></p>
<ul>
<li><p>使用axios.spread()方法可将数组[res1, res2]展开为res1，res2</p>
<p><img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211120122152.png" alt="img"></p>
</li>
<li><p>直接使用数组索引的方式取出（常用）</p>
<p><img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211120122242.png" alt="img"></p>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="axios的常见配置选项"><a href="#axios的常见配置选项" class="headerlink" title="axios的常见配置选项"></a>axios的常见配置选项</h2><ol>
<li>axios常见的配置选项<ol>
<li>请求地址 ——– <strong>url</strong>: ‘&#x2F;user’</li>
<li>请求类型 ——– <strong>method</strong>: ‘get’</li>
<li>url查询对象 —-params: {id: 12}<ul>
<li>当请求类型为<strong>get</strong>时，将查询对象中的属性和属性值以”?”开头拼接在url之后</li>
</ul>
</li>
<li>request body（请求体） —– date: {key: ‘aa’}<ul>
<li>当请求类型为post时，需要用该配置传递属性</li>
</ul>
</li>
<li>请求根路径 —— <strong>baseURL</strong>: “<a href="http://www.mt.com/api&quot;">http://www.mt.com/api&quot;</a></li>
<li>超时设置 —— <strong>timeout</strong>: 100</li>
</ol>
</li>
</ol>
<h2 id="axios的实例和模块封装"><a href="#axios的实例和模块封装" class="headerlink" title="axios的实例和模块封装"></a>axios的实例和模块封装</h2><ol>
<li><p>全局配置url的弊端</p>
<ol>
<li>在进行axios请求时，由于请求地址url的的根目录都相同，所以为了方便，就会进行全局配置，之后需要发送请求时，url就不需要加上根目录；但是在实际开发中不推荐这种方法</li>
<li>因为进行全局配置后，如果请求地址的根目录发生改变时，再发送axios请求时，就会与全局配置的url根目录产生冲突，为了解决这个问题，就<strong>需要创建对应不同的axios请求的实例</strong></li>
</ol>
</li>
<li><p>创建对应不同url的axios的实例与</p>
<p>为什么要进行模块封装</p>
<ol>
<li><p><strong>创建对应不同url的axios的实例</strong>：由于在进行axios请求时，往往url的根目录会不同，因此就需要针对不同url的根目录创建实例</p>
</li>
<li><p><strong>为什么要进行模块封装</strong>：在开发项目时，可能会有多个模块都需要进行axios请求，这样很多模块都需要重复创建实例，而创建对应的axios实例需要依赖axios，就需要在每个模块中引入axios，当某一天axios被替代或者是不再维护时，到时候就需要进行大量修改，为了避免这种情况，就需要进行模块封装；将所有的axios的实例都封装到一个js文件中，方便以后的维护</p>
</li>
<li><p>引入模块封装</p>
<p><img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211120122955.png" alt="img"></p>
</li>
</ol>
</li>
</ol>
<h3 id="模块封装request-x2F-axios请求（interceptors拦截器）"><a href="#模块封装request-x2F-axios请求（interceptors拦截器）" class="headerlink" title="模块封装request&#x2F;axios请求（interceptors拦截器）"></a>模块封装request&#x2F;axios请求（interceptors拦截器）</h3><ol>
<li><p><strong>模块化封装的方法</strong>：创建一个network文件夹，并在文件夹内创建一个request.js文件，在其中进行封装</p>
</li>
<li><p><strong>创建实例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 引入axios</span><br><span class="line">import axios from &#x27;axios&#x27;</span><br><span class="line"></span><br><span class="line">// 创建一个axios实例</span><br><span class="line">const instance = axios.create(&#123;</span><br><span class="line">    // axios常见的配置选项：请求根路径baseURL和超时设置timeout</span><br><span class="line">    baseURL: &#x27;http://kumanxuan1.f3322.net:8001&#x27;,</span><br><span class="line">    timeout: 5000</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>请求拦截</strong>：请求拦截后，必须对config进行返回，不然在内部进行发送请求时就拿不到config</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 请求拦截</span><br><span class="line">instance.interceptors.request.use(config =&gt; &#123;</span><br><span class="line">    // 拦截后的操作</span><br><span class="line">    // console.log(config);</span><br><span class="line">    // 请求拦截后，必须对config进行返回</span><br><span class="line">    return config;</span><br><span class="line">&#125;, err =&gt; &#123;</span><br><span class="line">    return Promise.reject(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol>
<li>请求拦截的作用，在拦截请求后，对拦截数据可以进行以下操作<ul>
<li>在config中的一些信息不符合服务器的要求，因此需要进行拦截后对数据进行处理</li>
<li>在每次发送网络请求时，希望在界面中显示一个正在请求的加载图标</li>
<li>某些网络请求<strong>（登陆必须携带token令牌）</strong>，必须携带一些特殊的信息</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>响应拦截</strong>：将响应回来的结果进行处理，一般只需要<strong>提取data数据</strong>即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 响应拦截</span><br><span class="line">instance.interceptors.response.use(res =&gt; &#123;</span><br><span class="line">    // 对响应的数据进行处理，返回data值</span><br><span class="line">    return res.data;</span><br><span class="line">&#125;, err =&gt; &#123;</span><br><span class="line">    return Promise.reject(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>导出拦截器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export default instance;</span><br></pre></td></tr></table></figure>
</li>
<li><p>axios拦截器：request.js文件</p>
<p><img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211128202806.png" alt="img"></p>
</li>
</ol>
<h3 id="拦截器使用"><a href="#拦截器使用" class="headerlink" title="拦截器使用"></a>拦截器使用</h3><ol>
<li><p><strong>使用拦截器</strong>：在network文件夹夹内创建一个api.js接口文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 引入request.js文件</span><br><span class="line">import request from &#x27;./request.js&#x27;</span><br><span class="line"></span><br><span class="line">// 按需导出api</span><br><span class="line">// 请求首页数据</span><br><span class="line">export const GetHomeData = () =&gt; request.get(&#x27;/index/index&#x27;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在组件中引入需要使用的api</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 在组件中引入api</span><br><span class="line">import &#123; GetHomeData &#125; from &quot;../request/api.js&quot;;</span><br></pre></td></tr></table></figure>

<p><img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211128212147.png" alt="img"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>eCharts数据的可视化</title>
    <url>/2022/08/01/eCharts%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
    <content><![CDATA[<h1 id="什么是数据可视化"><a href="#什么是数据可视化" class="headerlink" title="什么是数据可视化"></a>什么是数据可视化</h1><h2 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h2><ol>
<li>数据可视化主要目的：借助于图形化手段，清晰有效地传达与沟通信息</li>
<li>数据可视化可以把数据从冰冷的数字转换成图形，揭示蕴含在数据中的规律和道理</li>
</ol>
<h2 id="数据可视化的场景"><a href="#数据可视化的场景" class="headerlink" title="数据可视化的场景"></a>数据可视化的场景</h2><ol>
<li>目前互联网公司通常有这么几大类的可视化需求<ol>
<li>通用报表</li>
<li>移动端图表</li>
<li>大屏可视化</li>
<li>图编辑&amp;图分析</li>
<li>地理可视化</li>
</ol>
</li>
</ol>
<h2 id="常见的数据可视化库"><a href="#常见的数据可视化库" class="headerlink" title="常见的数据可视化库"></a>常见的数据可视化库</h2><ol>
<li>D3.js：目前Web端评价最高的Javascript可视化工具库(入手难)</li>
<li>ECharts.js：百度出品的一个开源Javascript数据可视化库</li>
<li>Highcharts.js：国外的前端数据可视化库，非商用免费，被许多国外大公司所使用</li>
<li>AntV：蚂蚁金服全新一代数据可视化解决方案</li>
<li>Highcharts和Echarts就像是Office和WPS的关系</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li>数据可视化主要目的：借助于图形化手段，清晰有效地传达与沟通信息</li>
<li>数据可视化在我们互联网公司中经常用于通用数据报表，移动端图表，大屏可视化，图编辑等</li>
<li>数据可视化库有很多，接下来我们重点学习ECharts</li>
</ol>
<h1 id="数据可视化项目概述"><a href="#数据可视化项目概述" class="headerlink" title="数据可视化项目概述"></a>数据可视化项目概述</h1><h2 id="项目目的"><a href="#项目目的" class="headerlink" title="项目目的"></a>项目目的</h2><h3 id="市场需求"><a href="#市场需求" class="headerlink" title="市场需求"></a>市场需求</h3><ol>
<li>应对现在数据可视化的趋，越来越多企业需要在很多场景(营销数据，生产数据，用户数据)下使用，可视化图表来展示体现数据，让数据更加直观，数据特点更加突出</li>
</ol>
<h3 id="学习阶段需求"><a href="#学习阶段需求" class="headerlink" title="学习阶段需求"></a>学习阶段需求</h3><ol>
<li>承上启下<ol>
<li>承上<ul>
<li>复习一起学习的内容</li>
<li>HTML5 + CSS3布局相关技术</li>
<li>JavaScript \ jQuery相关技术</li>
</ul>
</li>
<li>启下<ul>
<li>为学习服务器编程做铺垫</li>
<li>如何把服务区里面的数据渲染到页面中</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="项目技术"><a href="#项目技术" class="headerlink" title="项目技术"></a>项目技术</h2><ol>
<li>HTML5 + CSS3布局</li>
<li>CSS3动画、渐变</li>
<li>jQuery库 + 原生JavaScript</li>
<li>flex布局和rem适配方案</li>
<li>图片边框border-image</li>
<li>ES6模板字符</li>
<li>ECharts可视化库等等</li>
</ol>
<h1 id="ECharts简介"><a href="#ECharts简介" class="headerlink" title="ECharts简介"></a>ECharts简介</h1><ol>
<li>ECharts是一个使用JavaScript实现的开源可视化库，可以流畅的运行在PC和移动设备上，兼容当前绝大部分浏览器(IE8&#x2F;9&#x2F;10&#x2F;11，Chrome，Firefox，Safari等)，底层依赖矢量图形库ZRender，提供直观，交互丰富，可高度个性化定制的数据可视化图表</li>
<li>官网地址： <a href="https://echarts.apache.org/zh/index.html">https://echarts.apache.org/zh/index.html</a></li>
</ol>
<h2 id="ECharts使用五部曲"><a href="#ECharts使用五部曲" class="headerlink" title="ECharts使用五部曲"></a>ECharts使用五部曲</h2><ol>
<li><p>步骤一：下载并引入echarts.js文件 — 图表依赖这个js库</p>
</li>
<li><p>步骤二：准备一个具备大小的DOM容器 — 生成的图标会放入这个容器内</p>
<ul>
<li><code>&lt;div id=&quot;main&quot; style=&quot;width: 600px; height: 400px;&quot;&gt;&lt;/div&gt;</code></li>
</ul>
</li>
<li><p>步骤三：初始化echarts实例对象 — 实例化echarts</p>
<ul>
<li><code>var myCharts = echarts.init(document.getElementById(&#39;main&#39;));</code></li>
</ul>
</li>
<li><p>步骤四：指定配置项和数据（option） — 根据具体需求修改配置选项</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var option = &#123;</span><br><span class="line">  title: &#123;</span><br><span class="line">    text: &#x27;Echarts 入门示例&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  tooltip: &#123;&#125;,</span><br><span class="line">  legend: &#123;</span><br><span class="line">    date:[&#x27;销量&#x27;]</span><br><span class="line">  &#125;,</span><br><span class="line">  xAxis: &#123;</span><br><span class="line">    date: [&quot;衬衫&quot;, &quot;羊毛衫&quot;, &quot;雪纺衫&quot;, &quot;裤子&quot;, &quot;高跟鞋&quot;, &quot;袜子&quot;]</span><br><span class="line">  &#125;,</span><br><span class="line">  yAxis: &#123;&#125;,</span><br><span class="line">  series: [&#123;</span><br><span class="line">    name: &#x27;销量&#x27;,</span><br><span class="line">    type: &#x27;bar&#x27;,</span><br><span class="line">    data: [5, 20, 36, 10, 10, 20]</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>步骤五：将配置项设置给echarts实例对象 — 让echarts对象根据修改好的配置生效</p>
<ul>
<li>myCharts.setOption(option);</li>
</ul>
</li>
</ol>
<h2 id="相关配置讲解"><a href="#相关配置讲解" class="headerlink" title="相关配置讲解"></a>相关配置讲解</h2><ol>
<li>title：标题组件</li>
<li>tooltip：提示框组件</li>
<li>legend：图例组件</li>
<li>toolbox：工具栏</li>
<li>grid：直角坐标系grid中的x轴</li>
<li>xAxis：直角坐标系grid中的x轴</li>
<li>yAxis：直角坐标系grid中的y轴</li>
<li>series：系列列表，每个系列通过type决定自己的图表类型（什么类型的图表）</li>
<li>color：调色盘颜色列表</li>
<li>label：修饰饼形图文字相关的样式 label对象</li>
<li>labelLine：修饰引导线样式</li>
</ol>
]]></content>
      <categories>
        <category>eCharts</category>
      </categories>
      <tags>
        <tag>eCharts</tag>
      </tags>
  </entry>
  <entry>
    <title>flex布局</title>
    <url>/2022/08/01/flex%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h1 id="flex布局（重点）"><a href="#flex布局（重点）" class="headerlink" title="flex布局（重点）"></a>flex布局（重点）</h1><h2 id="传统布局与flex弹性布局"><a href="#传统布局与flex弹性布局" class="headerlink" title="传统布局与flex弹性布局"></a>传统布局与flex弹性布局</h2><ol>
<li>传统布局<ol>
<li>兼容性好</li>
<li>布局繁琐</li>
<li>局限性，不能再移动端很好布局</li>
</ol>
</li>
<li>flex弹性布局<ol>
<li>操作方便，布局极为简单，移动端应用广泛</li>
<li>PC端浏览器支持情况较差</li>
<li>IE 11或更低版本，不支持或仅部分支持</li>
</ol>
</li>
</ol>
<h2 id="布局原理"><a href="#布局原理" class="headerlink" title="布局原理"></a>布局原理</h2><ol>
<li>flex是flexible box的缩写，意为”弹性布局“，用来为盒状模型提供最大的灵活性，任何一个容器都可以指定为flex布局<ol>
<li>当我们为父盒子设为flex布局以后，子元素的float，clear和vertical-align属性将失效</li>
<li>伸缩布局 &#x3D; 弹性布局 &#x3D; 伸缩盒布局 &#x3D; flex布局</li>
</ol>
</li>
<li>采用flex布局的元素，称为flex容器（flex container），简称“容器”；它的所有子元素自动成为容器成员，称为flex项目，简称“项目”</li>
<li>总结flex布局原理：通过给父盒子添加flex属性，来控制子盒子的位置和排列方式</li>
</ol>
<h2 id="flex布局父项常见属性（重点）"><a href="#flex布局父项常见属性（重点）" class="headerlink" title="flex布局父项常见属性（重点）"></a>flex布局父项常见属性（重点）</h2><table>
<thead>
<tr>
<th>属性</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>flex-direction</td>
<td>设置主轴的方向</td>
</tr>
<tr>
<td>justify-content</td>
<td>设置主轴上的子元素排列方式</td>
</tr>
<tr>
<td>flex-wrap</td>
<td>设置子元素是否换行</td>
</tr>
<tr>
<td>align-content</td>
<td>设置侧轴上的子元素的排列方式（多行）</td>
</tr>
<tr>
<td>align-items</td>
<td>设置侧轴上的子元素排列方式（单行）</td>
</tr>
<tr>
<td>flex-flow</td>
<td>复合属性，相当于同时设置了flex-direction和flex-wrap</td>
</tr>
</tbody></table>
<h3 id="flex-direction设置主轴的方向"><a href="#flex-direction设置主轴的方向" class="headerlink" title="flex-direction设置主轴的方向"></a>flex-direction设置主轴的方向</h3><ol>
<li><p>主轴与侧轴</p>
<ol>
<li>在flex布局中，是分为主轴和侧轴两个方向，同样的叫法：行和列、x轴和y轴</li>
<li>默认主轴方向就是x轴方向，水平向右</li>
<li>默认侧轴方向就是y轴方向，水平向下</li>
</ol>
</li>
<li><p>属性值</p>
<ol>
<li><p>flex-direction属性决定主轴的方向（即项目的排列方向）</p>
</li>
<li><p>注意：主轴和侧轴是会变化的，就看flex-direction设置谁为主轴，剩下的就是侧轴；子元素是根据主轴来排列的</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>row</td>
<td>默认值从左到右</td>
</tr>
<tr>
<td>row-reverse</td>
<td>从右到左</td>
</tr>
<tr>
<td>column</td>
<td>从上到下（主轴为y轴，则x轴为侧轴）</td>
</tr>
<tr>
<td>column-reverse</td>
<td>从上到下</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ol>
<h3 id="justify-content设置主轴上的子元素排列方式（重点）"><a href="#justify-content设置主轴上的子元素排列方式（重点）" class="headerlink" title="justify-content设置主轴上的子元素排列方式（重点）"></a>justify-content设置主轴上的子元素排列方式（重点）</h3><ol>
<li><p>justify-content属性定义了项目在主轴上的子元素排列方式</p>
</li>
<li><p>注意：使用这个属性之前一定要确定好主轴是哪个</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>flex-start</td>
<td>默认值从头开始 如果主轴是x轴，则从左到右</td>
</tr>
<tr>
<td>flex-end</td>
<td>从尾部开始排列</td>
</tr>
<tr>
<td>center</td>
<td>在主轴居中对齐（如果主轴是x轴则水平居中）</td>
</tr>
<tr>
<td>space-around</td>
<td>平分剩余空间</td>
</tr>
<tr>
<td>space-between</td>
<td>先两边贴边 再平分剩余空间（重要）</td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="flex-wrap设置子元素是否换行"><a href="#flex-wrap设置子元素是否换行" class="headerlink" title="flex-wrap设置子元素是否换行"></a>flex-wrap设置子元素是否换行</h3><ol>
<li><p>默认情况下，项目都排在一条线（又称“轴线”）上，flex-wrap属性定义，flex布局中默认是不换行的</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>nowrap</td>
<td>默认值，不换行</td>
</tr>
<tr>
<td>wrap</td>
<td>换行</td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="align-items设置侧轴上的子元素的排列方式（单行）"><a href="#align-items设置侧轴上的子元素的排列方式（单行）" class="headerlink" title="align-items设置侧轴上的子元素的排列方式（单行）"></a>align-items设置侧轴上的子元素的排列方式（单行）</h3><ol>
<li><p>该属性是控制子项在侧轴（默认是y轴）上的排列方式 在子项为单项的时候使用</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>flex-start</td>
<td>从上到下</td>
</tr>
<tr>
<td>flex-end</td>
<td>从下到上</td>
</tr>
<tr>
<td>center</td>
<td>挤在一起居中（垂直居中）</td>
</tr>
<tr>
<td>stretch</td>
<td>拉伸（默认值）</td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="align-content设置侧轴上的子元素的排列方式（多行）"><a href="#align-content设置侧轴上的子元素的排列方式（多行）" class="headerlink" title="align-content设置侧轴上的子元素的排列方式（多行）"></a>align-content设置侧轴上的子元素的排列方式（多行）</h3><ol>
<li><p>设置子项在侧轴上的排列方式并且只能用于子项出行换行的情况（多行），在单行下是没有效果的</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>flex-start</td>
<td>默认值在侧轴的头部开始排列</td>
</tr>
<tr>
<td>flex-end</td>
<td>在侧轴的尾部开始排列</td>
</tr>
<tr>
<td>center</td>
<td>在侧轴中间显示</td>
</tr>
<tr>
<td>space-around</td>
<td>子项在侧轴平分剩余空间</td>
</tr>
<tr>
<td>space-between</td>
<td>子项在侧轴先分布在两头，再平分剩余空间</td>
</tr>
<tr>
<td>stretch</td>
<td>设置子项元素高度平分父元素高度</td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="flex-flow复合属性"><a href="#flex-flow复合属性" class="headerlink" title="flex-flow复合属性"></a>flex-flow复合属性</h3><ol>
<li><p>flex属性是flex-direction和flex-wrap属性的复合属性</p>
</li>
<li><p>演示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flex-direction: column;</span><br><span class="line">flex-wrap: wrap;</span><br></pre></td></tr></table></figure>

<ul>
<li>以上两句代码可以合并为一句代码：flex-flow: column wrap;</li>
</ul>
</li>
</ol>
<h2 id="flex布局子项常见属性"><a href="#flex布局子项常见属性" class="headerlink" title="flex布局子项常见属性"></a>flex布局子项常见属性</h2><h3 id="flex属性（重点）"><a href="#flex属性（重点）" class="headerlink" title="flex属性（重点）"></a>flex属性（重点）</h3><ol>
<li><p>flex属性定义子项分配剩余空间，用flex来表示占多少份数</p>
</li>
<li><p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  flex: &lt;number&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="align-self控制子项自己在侧轴上的排列方式"><a href="#align-self控制子项自己在侧轴上的排列方式" class="headerlink" title="align-self控制子项自己在侧轴上的排列方式"></a>align-self控制子项自己在侧轴上的排列方式</h3><ol>
<li><p>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性</p>
</li>
<li><p>默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch</p>
</li>
<li><p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">span: nth-child(2) &#123;</span><br><span class="line">  /* 设置自己在侧轴上的排列方式 */</span><br><span class="line">  align-self: flex-end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="order属性定义项目的排列顺序"><a href="#order属性定义项目的排列顺序" class="headerlink" title="order属性定义项目的排列顺序"></a>order属性定义项目的排列顺序</h3><ol>
<li>数值越小，排列越靠前，默认为0<ul>
<li>order: 2;</li>
</ul>
</li>
<li>注意：和z-index不一样</li>
</ol>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>instanceof与typeof的区别</title>
    <url>/2022/08/01/instanceof%E4%B8%8Etypeof%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="instanceof与typeof的区别"><a href="#instanceof与typeof的区别" class="headerlink" title="instanceof与typeof的区别"></a>instanceof与typeof的区别</h1><ol>
<li><p>typeof：用于判断数据类型，返回值为6个字符串，分别为string, boolean, number, function, object, undefined</p>
<ol>
<li><p>代码演示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a =[34,4,3,54],</span><br><span class="line">b =34,</span><br><span class="line">c =&#x27;adsfas&#x27;,</span><br><span class="line">d=function()&#123;console.log(&#x27;我是函数&#x27;)&#125;,</span><br><span class="line">e =true,</span><br><span class="line">f=null,</span><br><span class="line">g;</span><br><span class="line">console.log(typeof(a));  //object</span><br><span class="line">console.log(typeof(b));  //number</span><br><span class="line">console.log(typeof(c));  //string</span><br><span class="line">console.log(typeof(d));  //function</span><br><span class="line">console.log(typeof(e));  //boolean</span><br><span class="line">console.log(typeof(f));  //object</span><br><span class="line">console.log(typeof(g));  //undefined</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>instanceof：对象运算符，判断该对象是谁的实例，返回值为布尔值</p>
<ol>
<li>判断就是根据原型链进行搜寻</li>
<li>在对象obj1的原型链上如果存在另一个对象obj2的原型属性，那么表达式（obj1 instanceof obj2）返回值为true；否则返回false</li>
</ol>
</li>
<li><p>区别</p>
<ol>
<li>typeof判断所有变量的类型，返回值有number，boolean，string，function，object，undefined</li>
<li>typeof在判断null、array、object以及函数实例对象是得到的都是Object</li>
<li>instanceof用来判断对象，代码形式为obj1 instanceof obj2（obj1是否是obj2的实例），obj2必须为对象，否则会报错，其返回值为布尔值</li>
<li>instanceof可以对不同的对象实例进行判断，判断方法是根据对象的原型链依次向下查询，如果obj2的原型属性存在obj1的原型链上，（obj1 instanceof obj2）值为true</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>ES5</category>
      </categories>
      <tags>
        <tag>ES5</tag>
      </tags>
  </entry>
  <entry>
    <title>rem适配布局</title>
    <url>/2022/08/01/rem%E9%80%82%E9%85%8D%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h1 id="rem基础"><a href="#rem基础" class="headerlink" title="rem基础"></a>rem基础</h1><h2 id="rem单位"><a href="#rem单位" class="headerlink" title="rem单位"></a>rem单位</h2><ol>
<li>rem是一个相对单位，类似于em，em是父元素字体大小</li>
<li>不同的是rem的基准是相对于html元素的字体大小<ul>
<li>例：根元素（html）设置font-size: 12px; 非根元素设置width: 2rem; 则换成px表示就是24px；</li>
</ul>
</li>
<li>em相对于父元素的字体大小来讲</li>
<li>rem相对于html元素的字体大小来讲</li>
</ol>
<h2 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h2><h3 id="媒体查询（Media-Query）是CSS3新语法"><a href="#媒体查询（Media-Query）是CSS3新语法" class="headerlink" title="媒体查询（Media Query）是CSS3新语法"></a>媒体查询（Media Query）是CSS3新语法</h3><ol>
<li>使用@media查询，可以针对不同的媒体类型定义不同的样式</li>
<li>@media可以针对不同的屏幕尺寸设置不同的样式(主要价值)</li>
<li>当你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面</li>
<li>媒体查询一般按照从大到小或者从小到大的顺序来</li>
<li>目前针对很多苹果手机、Android手机，平板等设备都用得到多媒体查询</li>
</ol>
<h3 id="语法规范"><a href="#语法规范" class="headerlink" title="语法规范"></a>语法规范</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@media mediatype and | on | only (media feature) &#125;</span><br><span class="line">  CSS-code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>用@media开头 注意@符号</li>
<li>mediatype媒体类型</li>
<li>关键字 and not only</li>
<li>media feature 媒体特性 必须有小括号包含</li>
</ol>
<h3 id="mediatype查询类型"><a href="#mediatype查询类型" class="headerlink" title="mediatype查询类型"></a>mediatype查询类型</h3><ol>
<li><p>将不同的终端设备划分成不同的类型，称为媒体类型</p>
<table>
<thead>
<tr>
<th>值</th>
<th>解释说明</th>
</tr>
</thead>
<tbody><tr>
<td>all</td>
<td>用于所有设备</td>
</tr>
<tr>
<td>print</td>
<td>用于打印机和打印预览</td>
</tr>
<tr>
<td>screen</td>
<td>用于电脑屏幕 平板电脑 智能手机等</td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><ol>
<li>关键字将媒体类型或多个媒体特性连接到一起作为媒体查询的条件<ol>
<li>and：可以将多个媒体特性连接到一起，相当于“且”</li>
<li>not ：排除某个媒体类型，相当于“非”，可以省略</li>
<li>only：指定某个特定的媒体类型，可以省略</li>
</ol>
</li>
</ol>
<h3 id="媒体特性"><a href="#媒体特性" class="headerlink" title="媒体特性"></a>媒体特性</h3><ol>
<li><p>每种媒体类型都具有各自不同的特性，根据不同媒体类型的媒体特性设置不同的展示风格</p>
<table>
<thead>
<tr>
<th>值</th>
<th>解释说明</th>
</tr>
</thead>
<tbody><tr>
<td>width</td>
<td>定义输出设备中页面可见区域的宽度</td>
</tr>
<tr>
<td>min-width</td>
<td>定义输出设备中页面最小可见区域宽度（包含等于）</td>
</tr>
<tr>
<td>max-width</td>
<td>定义输出设备中页面最大可见区域宽度（包含等于）</td>
</tr>
</tbody></table>
</li>
<li><p>案例：屏幕尺寸改变屏幕背景颜色</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">&lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    @media screen and (max-width: 639px) &#123;</span><br><span class="line">        body &#123;</span><br><span class="line">            background-color: pink;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @media screen and (min-width: 640px) and (max-width: 799px) &#123;</span><br><span class="line">        body &#123;</span><br><span class="line">            background-color: skyblue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @media screen and (min-width: 800px) &#123;</span><br><span class="line">        body &#123;</span><br><span class="line">            background-color: tomato;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="媒体查询-rem实现元素动态大小变化"><a href="#媒体查询-rem实现元素动态大小变化" class="headerlink" title="媒体查询+rem实现元素动态大小变化"></a>媒体查询+rem实现元素动态大小变化</h3><ol>
<li><p>媒体查询+rem：可以实现不同的设备宽度，实现页面元素大小的动态变化</p>
</li>
<li><p>案例：屏幕尺寸改变字体大小</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">&lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    /* 屏幕尺寸小于639px时，html字体大小为50px */</span><br><span class="line">    @media screen and (max-width: 639px) &#123;</span><br><span class="line">      html &#123;</span><br><span class="line">        font-size: 50px;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 屏幕尺寸大于640px时，html字体大小为100px */</span><br><span class="line">    @media screen and (min-width: 640px) &#123;</span><br><span class="line">      html &#123;</span><br><span class="line">        font-size: 100px;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    div &#123;</span><br><span class="line">        height: 1rem;</span><br><span class="line">        font-size: .7rem;</span><br><span class="line">        color: #fff;</span><br><span class="line">        background-color: skyblue;</span><br><span class="line">        text-align: center;</span><br><span class="line">        line-height: 1rem;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;主页&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="引入资源"><a href="#引入资源" class="headerlink" title="引入资源"></a>引入资源</h3><ol>
<li><p>当样式比较繁多的时候，我们可以针对不同的媒体使用不同的stylesheets（样式表）</p>
</li>
<li><p>原理：直接在link中判断设备的尺寸，然后引入不同的css文件</p>
</li>
<li><p>建议：媒体查询最好的方法是从小到大</p>
</li>
<li><p>引入资源就是：针对于不同的屏幕尺寸，调用不同的css文件</p>
</li>
<li><p>演示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 建议：媒体查询最好的方法是从小到大</span><br><span class="line">    引入资源就是：针对于不同的屏幕尺寸，调用不同的css文件 --&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; media=&quot;screen and (min-width: 300px)&quot; href=&quot;style300.css&quot;&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; media=&quot;screen and (min-width: 800px)&quot; href=&quot;style800.css&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;1&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;2&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">/* style300.css文件 */</span><br><span class="line">div &#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 100px;</span><br><span class="line">&#125;</span><br><span class="line">div:nth-child(1) &#123;</span><br><span class="line">    background-color: pink;</span><br><span class="line">&#125;</span><br><span class="line">div:nth-child(2) &#123;</span><br><span class="line">    background-color: skyblue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* style800.css文件 */</span><br><span class="line">div &#123;</span><br><span class="line">    float: left;</span><br><span class="line">    width: 50%;</span><br><span class="line">    height: 100px;</span><br><span class="line">&#125;</span><br><span class="line">div:nth-child(1) &#123;</span><br><span class="line">    background-color: pink;</span><br><span class="line">&#125;</span><br><span class="line">div:nth-child(2) &#123;</span><br><span class="line">    background-color: skyblue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>语法规范<code>&lt;link rel=&quot;stylesheet&quot; media=&quot;mediatype and|not|only (media feature)&quot; href=&quot;style.css&quot;&gt;</code></p>
</li>
</ol>
<h2 id="less基础"><a href="#less基础" class="headerlink" title="less基础"></a>less基础</h2><h3 id="维护CSS的弊端"><a href="#维护CSS的弊端" class="headerlink" title="维护CSS的弊端"></a>维护CSS的弊端</h3><ol>
<li>css是一门非程序式语言，没有变量，函数，SCOPE（作用域）等概念<ol>
<li>CSS需要书写大量看似没有逻辑的代码，CSS冗余度是比较高的</li>
<li>不方便维护及扩展，不利于复用</li>
<li>CSS没有很好的计算能力</li>
<li>非前段开发工程师，往往会因为缺少CSS编写经验而很难写出组织良好且易于维护的CSS代码项目</li>
</ol>
</li>
</ol>
<h3 id="less介绍"><a href="#less介绍" class="headerlink" title="less介绍"></a>less介绍</h3><ol>
<li>Less ( Leaner Style Sheets的缩写)是一门CSS扩展语言,也成为CSS预处理器</li>
<li>做为CSS的一种形式的扩展，它并没有减少CSS的功能，而是在现有的CSS语法上，为CSS加入程序式语言的特性。</li>
<li>它在CSS的语法基础之上，引入了变量，Mixin(混入)，运算l以及函数等功能，大大简化了CSS的编写，并且降低了CSS的维护成本，就像它的名称所说的那样，Less可以让我们用更少的代码做更多的事情。</li>
<li>less中文网：<a href="http://lesscss.cn/">http://lesscss.cn/</a></li>
<li>常见的CSS与预处理器：Sass、Less、Stylus</li>
</ol>
<h3 id="less变量"><a href="#less变量" class="headerlink" title="less变量"></a>less变量</h3><ol>
<li>变量是指没有固定的值，可以改变的。因为我们CSS中的一些颜色和数值等经常使用<ul>
<li>@变量名: 值;</li>
</ul>
</li>
<li>变量命名规范<ol>
<li>必须有@为前缀</li>
<li>不能包含特殊字符</li>
<li>不能以数字开头</li>
<li>大小写敏感</li>
</ol>
</li>
</ol>
<h3 id="less编译"><a href="#less编译" class="headerlink" title="less编译"></a>less编译</h3><ol>
<li>Easy Less插件：用来把less文件编译为css文件</li>
</ol>
<h3 id="less嵌套"><a href="#less嵌套" class="headerlink" title="less嵌套"></a>less嵌套</h3><ol>
<li>less嵌套 子元素的样式直接写到父元素里面<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20210922015614.png" alt="img"></li>
<li>交集、伪类、伪元素选择器<ol>
<li>内层选择器的前面没有&amp;符号，则被解析为父选择器的后代</li>
<li>若有&amp;符号，则被解析为父元素自身或者父元素的伪类<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20210922015659.png" alt="img"></li>
</ol>
</li>
</ol>
<h3 id="less运算"><a href="#less运算" class="headerlink" title="less运算"></a>less运算</h3><ol>
<li>乘号（*）和除号（&#x2F;）</li>
<li>最新版本easy Less插件中，除法必须加括号</li>
<li>运算符的左右两侧必须用一个空格隔开</li>
<li>两个数参与运算 如果只有一个数有单位，则最后的结果就以这个单位为准</li>
<li>两个数参与运算，如果2个数都有单位，而且单位不一样，则以第一个单位为准</li>
</ol>
<h2 id="rem适配方案"><a href="#rem适配方案" class="headerlink" title="rem适配方案"></a>rem适配方案</h2><ol>
<li>让一些不能等比自适应的元素，达到当设备尺寸发生改变的时候，等比例适配当前设备</li>
<li>使用媒体查询根据不同设备按比例设置html的字体大小，然后页面元素使用rem做尺寸单位，当htmI字体大小变化元素尺寸也会发生变化，从而达到等比缩放的适配</li>
</ol>
<h3 id="rem适配方案技术使用（市场主流）"><a href="#rem适配方案技术使用（市场主流）" class="headerlink" title="rem适配方案技术使用（市场主流）"></a>rem适配方案技术使用（市场主流）</h3><ol>
<li>技术方案1<ol>
<li>less</li>
<li>媒体查询<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20210922020359.png" alt="img"></li>
<li>rem</li>
</ol>
</li>
<li>rem最终适配方案<ol>
<li>首先选一套标准尺寸，一般以750px为准</li>
<li>用屏幕尺寸除以划分的份数，得到了html里面的文字大小，但是我们知道不同屏幕下得到的文字大小是不一样的</li>
<li>页面元素的rem值 &#x3D; 页面元素在750像素下的px值 &#x2F; html里面的文字大小</li>
</ol>
</li>
<li>技术方案二（推荐）<ol>
<li>flexible.js</li>
<li>rem</li>
</ol>
</li>
</ol>
<h1 id="案例：苏宁首页"><a href="#案例：苏宁首页" class="headerlink" title="案例：苏宁首页"></a>案例：苏宁首页</h1><h2 id="适配方案一"><a href="#适配方案一" class="headerlink" title="适配方案一"></a>适配方案一</h2><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><ol>
<li>方案：采取单独制作移动页面方案</li>
<li>技术布局采取rem适配布局（less + rem + 媒体查询）</li>
<li>设计图：本设计图采用750px设计尺寸</li>
</ol>
<h3 id="设置公共common-less文件"><a href="#设置公共common-less文件" class="headerlink" title="设置公共common.less文件"></a>设置公共common.less文件</h3><ol>
<li>新建common.less设置好最常见的屏幕尺寸 ,利用媒体查询设置不同的html字体大小,因为除了首页其他页面也需要</li>
<li>我们关心的尺寸有320px、360px、 375px、 384px、 400px、 414px、 424px、 480px、 540px、 720px、 750px</li>
<li>划分的份数我们定为15等份</li>
<li>因为我们pc端也可以打开我们苏宁移动端首页,我们默认htm|字体大小为50px ,注意这句话写到最上面</li>
</ol>
<h3 id="import样式导入"><a href="#import样式导入" class="headerlink" title="import样式导入"></a>import样式导入</h3><ol>
<li>@import：把一个样式文件导入另外一个样式文件里面<ol>
<li>语法：<code>@import &quot;common(文件名，可以不加后缀)&quot;;</code></li>
</ol>
</li>
<li>link：把一个样式文件引入到html页面里面</li>
</ol>
<h3 id="body样式"><a href="#body样式" class="headerlink" title="body样式"></a>body样式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">    min-width: 320px;</span><br><span class="line">    width: 15rem;</span><br><span class="line">    margin: 0 auto;</span><br><span class="line">    line-height: 1.5;</span><br><span class="line">    font-family: Arial, Helvetica;</span><br><span class="line">    background: #f2f2f2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="新建index-less文件"><a href="#新建index-less文件" class="headerlink" title="新建index.less文件"></a>新建index.less文件</h3><ol>
<li>新建index.less，用于写首页样式</li>
<li>将设置好的common.less引入到index.less里面</li>
</ol>
<h2 id="适配方案二（推荐）"><a href="#适配方案二（推荐）" class="headerlink" title="适配方案二（推荐）"></a>适配方案二（推荐）</h2><h3 id="简洁高效的rem适配方案flexible-js"><a href="#简洁高效的rem适配方案flexible-js" class="headerlink" title="简洁高效的rem适配方案flexible.js"></a>简洁高效的rem适配方案flexible.js</h3><ol>
<li>手机淘宝团队出的简洁高效移动端适配库</li>
<li>再也不需要在写不同屏幕的媒体查询，因为里面js做了处理</li>
<li>它的原理是把当前设备划分为10等份，但是不同设备下，比例还是一致的</li>
<li>要做的就是确定好我们当前设备的html文字大小就可以；<ul>
<li>比如：当前设计稿是750px，那么我们只需要cssrem插件默认的html文字大小（基准值）为75px(750px &#x2F; 10)就可以得到里面页面元素rem值：页面元素的px值 &#x2F;75</li>
</ul>
</li>
<li>剩余的，让flexible.js来去算</li>
<li>flexible.js中的核心代码，修改这个值就可以利用flexible.js将屏幕分为几份；然后修改cssrem插件默认的html文字大小（基准值），基准值为：设计稿宽度 &#x2F; 屏幕份数<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20210922020648.png" alt="img"></li>
<li>flexible.js文件的github地址: <a href="https://github.com/amfe/lib-flexible">https://github.com/amfe/lib-flexible</a></li>
</ol>
<h3 id="引入flexible-js文件"><a href="#引入flexible-js文件" class="headerlink" title="引入flexible.js文件"></a>引入flexible.js文件</h3><ol>
<li>语法：<code>&lt;script src=&quot;js/flexible.js&quot;&gt;&lt;script&gt;</code></li>
</ol>
<h3 id="body样式-1"><a href="#body样式-1" class="headerlink" title="body样式"></a>body样式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  min-width: 320px;</span><br><span class="line">  max-width: 750px;</span><br><span class="line">  /* flexible.js给我们划分了10等份 */</span><br><span class="line">  width: 10rem;</span><br><span class="line">  margin: 0 auto;</span><br><span class="line">  line-height: 1.5;</span><br><span class="line">  font-family: Arial, Helvetica;</span><br><span class="line">  background: #f2f2f2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="cssrem插件px转换为rem"><a href="#cssrem插件px转换为rem" class="headerlink" title="cssrem插件px转换为rem"></a>cssrem插件px转换为rem</h3><ol>
<li>VScode安装插件重启即可</li>
<li>需要设置插件默认的html的字体大小基准值</li>
</ol>
<h3 id="修改插件默认的html文字大小"><a href="#修改插件默认的html文字大小" class="headerlink" title="修改插件默认的html文字大小"></a>修改插件默认的html文字大小</h3><ol>
<li>打开设置，在搜索框输入cssroot，然后修改rootfontsize值为75px</li>
</ol>
<h3 id="案例：把屏幕宽度约束在1024-1920之间有适配"><a href="#案例：把屏幕宽度约束在1024-1920之间有适配" class="headerlink" title="案例：把屏幕宽度约束在1024-1920之间有适配"></a>案例：把屏幕宽度约束在1024-1920之间有适配</h3><ol>
<li>设计稿是1920px</li>
<li>PC端适配：宽度在1024 - 1920px之间页面元素宽高自适应<ol>
<li>flexible.js 把屏幕分为24等份</li>
<li>cssrem插件的基准值是80px<ul>
<li>插件 – 配置按钮 – 配置扩展设置 – Root Font Size 里面设置</li>
<li>重启VScode软件</li>
</ul>
</li>
<li>要把屏幕宽度约束在1024 - 1920px之间有适配，实现代码：<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20210922021227.png" alt="img"></li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-router路由</title>
    <url>/2022/08/02/vue-router%E8%B7%AF%E7%94%B1/</url>
    <content><![CDATA[<h1 id="vue-router路由"><a href="#vue-router路由" class="headerlink" title="vue-router路由"></a>vue-router路由</h1><h2 id="前端渲染后端渲染和前端路由后端路由"><a href="#前端渲染后端渲染和前端路由后端路由" class="headerlink" title="前端渲染后端渲染和前端路由后端路由"></a>前端渲染后端渲染和前端路由后端路由</h2><h3 id="后端路由阶段"><a href="#后端路由阶段" class="headerlink" title="后端路由阶段"></a>后端路由阶段</h3><ol>
<li>早期的网站开发整个HTML页面是由服务器来渲染的<ol>
<li>服务器直接生产渲染好对应的HTML页面，返回给客户端进行展示</li>
</ol>
</li>
<li>但是，一个网站，这么多页面服务器如何处理呢<ol>
<li>一个页面有自己对应的网址，也就是URL</li>
<li>URL会发送到服务器，服务器会通过正则对该URL进行匹配，并且最后交给一个Controller进行处理</li>
<li>Controller进行各种处理，最终生成HTML或者数据，返回给前端</li>
</ol>
</li>
<li>这就完成了一个IO操作</li>
<li>上面的这种操作，就是后端路由<ol>
<li>当我们页面中需要请求不同的路径内容时，交给服务器来进行处理，服务器渲染好整个页面，并且将页面返回给客户顿</li>
<li>这种情况下渲染好的页面，不需要单独加载任何的js和css，可以直接交给浏览器展示，这样也有利于SEO的优化</li>
</ol>
</li>
<li>后端路由的缺点<ol>
<li>一种情况是整个页面的模块由后端人员来编写和维护的</li>
<li>另一种情况是前端开发人员如果要开发页面，需要通过PHP和Java等语言来编写页面代码</li>
<li>而且通常情况下HTML代码和数据以及对应的逻辑会混在一起，编写和维护都是非常糟糕的事情</li>
</ol>
</li>
</ol>
<h3 id="前端路由阶段"><a href="#前端路由阶段" class="headerlink" title="前端路由阶段"></a>前端路由阶段</h3><ol>
<li>前后端分离阶段<ol>
<li>随着Ajax的出现，有了前后端分离的开发模式</li>
<li>后端只提供API来返回数据，前端通过Ajax获取数据，并且可以通过JavaScript将数据渲染到页面中</li>
<li>这样做最大的优点就是前后端责任的清晰，后端专注于数据上，前端专注于交互和可视化上</li>
<li>并且当移动端（iOS&#x2F;Android）出现后，后端不需要进行任何处理，依然使用之前的一套API即可</li>
<li>目前很多的网站依然采用这种模式开发</li>
</ol>
</li>
<li>单页面富应用阶段<ol>
<li>其实SPA最主要的特点就是在前后端分离的基础上加了一层前端路由</li>
<li>也就是前端来维护下套路由规则</li>
</ol>
</li>
</ol>
<h2 id="路由的基本使用"><a href="#路由的基本使用" class="headerlink" title="路由的基本使用"></a>路由的基本使用</h2><h3 id="vue-router介绍"><a href="#vue-router介绍" class="headerlink" title="vue-router介绍"></a>vue-router介绍</h3><ol>
<li>vue-router是Vue.js官方的路由插件，它和vue.js是深度集成的，适合用于构建单页面应用</li>
<li>我们可以访问其官方网站对其进行学习： <a href="https://router.vuejs.org/zh/">https://router.vuejs.org/zh/</a></li>
<li>vue-router是基于路由和组件的<ol>
<li>路由用于设定访问路径，将路径和组件映射起来</li>
<li>在vue-router的单页面应用中，页面的路径的改变就是组件的切换</li>
</ol>
</li>
</ol>
<h3 id="安装vue-router"><a href="#安装vue-router" class="headerlink" title="安装vue-router"></a>安装vue-router</h3><ol>
<li>安装vue-router：npm install –save vue-router</li>
<li>使用版本<ol>
<li>Vue2使用<a href="mailto:vue-router@3.xx.xx">vue-router@3.xx.xx</a>版本</li>
<li>Vue3使用<a href="mailto:vue-router@4.xx.xx">vue-router@4.xx.xx</a>版本</li>
</ol>
</li>
</ol>
<h3 id="配置vue-router"><a href="#配置vue-router" class="headerlink" title="配置vue-router"></a>配置vue-router</h3><ol>
<li><p>第一步：导入路由对象，并且调用Vue.use(VueRouter)</p>
</li>
<li><p>第二步：创建并导出路由实例，并且配置路由映射（配置路由和组件之间的映射关系）</p>
</li>
<li><p>第三步：在Vue实例中挂载创建的路由实例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">// 导入路由对象</span><br><span class="line">import VueRouter from &#x27;vue-router&#x27;</span><br><span class="line"></span><br><span class="line">// 使用路由</span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line">// 创建并导出路由实例</span><br><span class="line">export default new VueRouer (&#123;</span><br><span class="line">    // 配置路由映射</span><br><span class="line">    routes: [</span><br><span class="line">        &#123;</span><br><span class="line">            // 配置路径</span><br><span class="line">            path: &#x27;/about&#x27;,</span><br><span class="line">            // 导入路由组件</span><br><span class="line">            component: () =&gt; import(&#x27;../views/About.vue&#x27;)</span><br><span class="line">        &#125;,</span><br><span class="line">        ...</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 在mian.js中将router进行挂载</span><br><span class="line">import router from &#x27;./router&#x27;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: h =&gt; h(App)</span><br><span class="line">&#125;).$mount(&#x27;#app&#x27;)</span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="使用vue-router"><a href="#使用vue-router" class="headerlink" title="使用vue-router"></a>使用vue-router</h3><ol>
<li><p>使用路由 — 通过<code>&lt;router-link&gt;</code>和<code>&lt;router-view&gt;</code></p>
<ol>
<li><p><code>&lt;router-link&gt;&lt;/router-link&gt;</code>：该标签是一个vue-router中已经内置的组件，它最终会被渲染成一个标签，该标签内使用to属性来指定跳转路径</p>
</li>
<li><p><code>&lt;router-view&gt;&lt;/router-view&gt;</code>：用于指定组件的展示位置。当路由跳转时，该路由对应的组件就会在该位置渲染，替换掉<code>&lt;router-view&gt;&lt;/router-view&gt;</code></p>
</li>
</ol>
<p><code>&lt;router-link to=&quot;/about&quot; active-class=&quot;active&quot;&gt;&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; // css样式，当标签中to属性指定的路由被使用时有效 .active &#123;    ... &#125; </code></p>
</li>
<li></li>
</ol>
<h3 id="router-link补充"><a href="#router-link补充" class="headerlink" title="router-link补充"></a>router-link补充</h3><ol>
<li><pre><code>&lt;router-link&gt;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">有关属性的补充</span><br><span class="line"></span><br><span class="line">1. to — 用于指定跳转的路径</span><br><span class="line"></span><br><span class="line">   - 例：`&lt;router-link to=&#x27;/home&#x27;&gt;`</span><br><span class="line"></span><br><span class="line">2. tag — tag可以指定</span><br><span class="line"></span><br></pre></td></tr></table></figure>
   &lt;router-link&gt;
   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   之后渲染成什么组件（比如按钮）</span><br><span class="line"></span><br><span class="line">   - 例：`&lt;router-link to=&#x27;/home&#x27; tag=&#x27;button&#x27;&gt;`</span><br><span class="line"></span><br><span class="line">3. replace — 用于控制路由跳转时操作浏览器历史记录的模式</span><br><span class="line"></span><br><span class="line">   1. 浏览器历史记录有两种写入方式：push和replace；push为追加历史记录，replace为替换当前记录，默认为push，使用replace属性则开启replace模式</span><br><span class="line">   2. 例：`&lt;router-link to=&#x27;/home&#x27; tag=&#x27;button&#x27; replace&gt;`</span><br><span class="line"></span><br><span class="line">4. active-class：当</span><br><span class="line"></span><br></pre></td></tr></table></figure>
   &lt;router-link&gt;
   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      对应的路由匹配成功时，会自动给当前元素设置一个router-link-active的类名，设置active-class的属性值可以修改默认类名</span><br><span class="line"></span><br><span class="line">      - 可以通过router-link-active类名给被正在使用路由的`&lt;router-link&gt;`标签书写css样式设置点击特效，如字体变色</span><br><span class="line"></span><br><span class="line">### 多级路由</span><br><span class="line"></span><br><span class="line">1. 实现嵌套路由有两个步骤：</span><br><span class="line"></span><br><span class="line">   1. 创建对应的子组件，并且在路由映射中配置对应的子路由</span><br><span class="line">   2. 在组件内部使用`&lt;router-view&gt;`标签</span><br><span class="line"></span><br><span class="line">2. 配置路由规则，使用children配置项</span><br><span class="line"></span><br><span class="line">3. 在子路由中的path配置项中，**配置的路径不要加/**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
routes: [
    &#123;
        // 配置路径
        path: &#39;/about&#39;,
        // 导入路由组件
        component: () =&gt; import(&#39;../views/About.vue&#39;),
        children: [
            &#123;
                path: &#39;user&#39;, // 此处千万不要写：/user
                component: () =&gt; import(&#39;../views/user.vue&#39;)
            &#125;
        ]
    &#125;,    
    ...
]
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">4. `&lt;router-link&gt;&lt;/router-link&gt;`中to指定的路径必须要写完整路由路径</span><br><span class="line"></span><br></pre></td></tr></table></figure>
&lt;router-link to=&quot;/about/user&quot;&gt;&lt;/router-link&gt;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 命名路由</span><br><span class="line"></span><br><span class="line">1. 作用：可以简化路由的跳转</span><br><span class="line"></span><br><span class="line">2. 使用代码如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
routes: [
    &#123;
        // 给该路由命名为guanyv
        name: &#39;guanyv&#39;,
        path: &#39;/about&#39;,
        component: () =&gt; import(&#39;../views/About.vue&#39;)
    &#125;,    
    ...
]
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 编程式路由导航</span><br><span class="line"></span><br><span class="line">1. 不借助`&lt;router-link&gt;`标签进行路由跳转</span><br><span class="line"></span><br><span class="line">2. $router属性是创建出的路由对象的属性，可以调用一些方法，进行**相关路由跳转**</span><br><span class="line"></span><br><span class="line">   1. **push()**：跳转到指定路径，采用push浏览器历史记录模式</span><br><span class="line"></span><br></pre></td></tr></table></figure>
   this.$router.push(&#39;/home&#39;)
   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. **repalce()：**跳转到指定路径，采用replace浏览器历史记录模式</span><br><span class="line"></span><br></pre></td></tr></table></figure>
   this.$router.replace(&#39;/home&#39;)
   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. **back()：**跳转到前一个路由</span><br><span class="line"></span><br></pre></td></tr></table></figure>
   this.$router.back()
   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">4. **forward()：**跳转到后一个路由</span><br><span class="line"></span><br></pre></td></tr></table></figure>
   this.$router.forward()
   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">5. **go()**：跳转到前几个路由，或后几个路由</span><br><span class="line"></span><br></pre></td></tr></table></figure>
   // 跳转到前一个路由
   this.$router.go(-1)
   // 跳转到后一个路由
   this.$router.go(1)
   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 路由缓存</span><br><span class="line"></span><br><span class="line">1. 作用：让不展示的路由组件保持挂载，不被销毁</span><br><span class="line"></span><br><span class="line">2. 使用`&lt;keep-alive&gt;&lt;/keep-alive&gt;`标签实现路由缓存，使用该标签包裹`&lt;router-view&gt;&lt;/router-view&gt;`标签，可以使通过路由在`&lt;router-view&gt;&lt;/router-view&gt;`位置处展示的组件全部进行缓存</span><br><span class="line"></span><br><span class="line">3. 在实际开发中只需要将部分组件进行缓存，通过`&lt;keep-alive&gt;&lt;/keep-alive&gt;`标签中的include属性实现，指定include属性的属性值为需要进行缓存的组件名即可；</span><br><span class="line"></span><br><span class="line">4. 若需要指定多个进行缓存的组件，将include属性的属性值为数组，在数组中放入组件名即可</span><br><span class="line"></span><br></pre></td></tr></table></figure>
// 缓存在&lt;router-view&gt;&lt;/router-view&gt;位置处展示的所有组件
&lt;keep-alive&gt;
    &lt;router-view&gt;&lt;/router-view&gt;
&lt;/keep-alive&gt;

// 缓存在&lt;router-view&gt;&lt;/router-view&gt;位置处展示的单个指定组件
&lt;keep-alive include=&quot;组件名&quot;&gt;
    &lt;router-view&gt;&lt;/router-view&gt;
&lt;/keep-alive&gt;

// 缓存在&lt;router-view&gt;&lt;/router-view&gt;位置处展示的多个指定组件
&lt;keep-alive include=&quot;[&#39;组件名1&#39;, &#39;组件名2&#39;]&quot;&gt;
    &lt;router-view&gt;&lt;/router-view&gt;
&lt;/keep-alive&gt;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### meta配置项</span><br><span class="line"></span><br><span class="line">1. meta被称为路由元信息，是路由中携带的信息，可以通过自定义meta来实现一些路由时的功能</span><br><span class="line"></span><br><span class="line">2. 使用场景：比如给每一个路由对应的页面设置标题、以及判断某个页面是否需要进行权限校验</span><br><span class="line"></span><br></pre></td></tr></table></figure>
routes: [
    &#123;
        // 给该路由命名为guanyv
        name: &#39;guanyv&#39;,
        path: &#39;/about&#39;,
        component: () =&gt; import(&#39;../views/About.vue&#39;)
        // 自定义title属性和isAuth属性，用于在路由导航守卫中使用，给页面设置标题和权限校验
        meta: &#123; title: &#39;关于&#39;, isAuth: true&#125;
    &#125;,    
    ...
]
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### activated与deactivated</span><br><span class="line"></span><br><span class="line">1. 两个生命周期钩子，是路由所独有的生命周期钩子，用于捕获路由组件的激活和失活状态</span><br><span class="line"></span><br><span class="line">2. **activated**：路由组件被激活时触发</span><br><span class="line"></span><br><span class="line">3. **deactivated**：路由组件失活时触发</span><br><span class="line"></span><br></pre></td></tr></table></figure>
activated () &#123;
    ....
&#125;,
deactivated () &#123;
    ...
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 路由守卫</span><br><span class="line"></span><br><span class="line">### 全局路由守卫 - 前置、后置</span><br><span class="line"></span><br><span class="line">1. 全局前置路由守卫**beforeEach**：进行初始化时执行，**在每一次路由切换前执行**</span><br><span class="line"></span><br><span class="line">   1. router.beforeEach(to, form, next)</span><br><span class="line">   2. 三个参数解析</span><br><span class="line">      - **to**：即将要进入的目标的路由对象</span><br><span class="line">      - **from**：当前导航即将要离开的路由对象</span><br><span class="line">      - **next**：调用该方法后，才能进入下一个钩子(相当于放行) — next()：放行，next(‘/login’)：强制跳转</span><br><span class="line"></span><br><span class="line">2. 全局后置路由守卫**afterEach**：进行初始化时执行，**在每一次路由切换后执行**</span><br><span class="line"></span><br><span class="line">   1. router.beforeEach(to, form, next)</span><br><span class="line">   2. 参数同上</span><br><span class="line"></span><br><span class="line">3. 例：使用全局前置路由守卫对页面进行鉴权、使用全局前置路由守卫修改页面标题</span><br><span class="line"></span><br></pre></td></tr></table></figure>
// 路由配置文件中
routes: [
    &#123;
        // 给该路由命名为guanyv
        name: &#39;guanyv&#39;,
        path: &#39;/about&#39;,
        component: () =&gt; import(&#39;../views/About.vue&#39;)
        // 自定义title属性和isAuth属性，用于在路由导航守卫中使用，给页面设置标题和权限校验
        meta: &#123; title: &#39;关于&#39;, isAuth: true&#125;
    &#125;,    
    ...
]

// 使用全局前置路由守卫对页面进行鉴权
router.beforeEach((to, form, next) =&gt; &#123;
    // 通过判断是否需要进行鉴权
    if (to.meta.isAuth) &#123;
        if (localStroage.getItem(&#39;token&#39;) === &#39;xxxx&#39;) &#123;
            // 符合条件，放行进入下一路由
            next()
        &#125; else &#123;
            console.log(&#39;校验失败&#39;)
        &#125;
    &#125;
&#125;)

// 使用全局前置路由守卫修改页面标题
router.afterEach((to, form, next) =&gt; &#123;
    // 判断即将进入的页面路由元信息中是否有title属性
    if (form.meta.title) &#123;
        document.title = to.meta.title // 修改网页标题
    &#125;
&#125;)
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 独享路由守卫</span><br><span class="line"></span><br><span class="line">1. **beforeEnter**：某一个组件路由单独使用的路由守卫，在进入该组件之前进行调用</span><br><span class="line"></span><br></pre></td></tr></table></figure>
routes: [
    &#123;
        name: &#39;guanyv&#39;,
        path: &#39;/about&#39;,
        component: () =&gt; import(&#39;../views/About.vue&#39;)
        // 自定义title属性和isAuth属性，用于在路由导航守卫中使用，给页面设置标题和权限校验
        meta: &#123; title: &#39;关于&#39;, isAuth: true&#125;
        beforeEnter: (to, form, next) &#123;
            // 通过判断是否需要进行鉴权
            if (to.meta.isAuth) &#123;
                if (localStroage.getItem(&#39;token&#39;) === &#39;xxxx&#39;) &#123;
                    // 符合条件，放行进入当前组件路由
                    next()
                &#125; else &#123;
                    console.log(&#39;校验失败&#39;)
                &#125;
            &#125;
        &#125;
    &#125;,    
    ...
]
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 组件内路由守卫 - 前置、后置</span><br><span class="line"></span><br><span class="line">1. 组件前置路由守卫**beforeRouteEnter**：通过路由规则进入该组件时调用</span><br><span class="line"></span><br><span class="line">   1. router.beforeRouteEnter (to, form, next)</span><br><span class="line"></span><br><span class="line">2. 组件后置路由守卫**beforeRouteLeave**：通过路由规则离开该组件时调用</span><br><span class="line"></span><br><span class="line">   1. router.beforeRouteLeave (to, form, next)</span><br><span class="line"></span><br><span class="line">3. 在需要使用的组件中进行使用</span><br><span class="line"></span><br></pre></td></tr></table></figure>
export default &#123;
    data() &#123;
        return &#123;&#125;
    &#125;,
    methods: &#123;&#125;,
    beforeRouteEnter(to, form, next) &#123;&#125;,
    beforeRouteLeave(to, form, next) &#123;&#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 路由传参</span><br><span class="line"></span><br><span class="line">1. 配置路由映射</span><br><span class="line"></span><br></pre></td></tr></table></figure>
&#123;
  // 映射路径
  path: &#39;/payWait&#39;,
  // 组件名
  name: &#39;payWait&#39;, 
  // 组件位置
  component: () =&gt; import(&#39;@/views/canteenRecharge/payWait&#39;),
  // title路由元信息自定义的属性，通过全局后置导航守卫为页面添加标题
  meta: &#123; title: &#39;食堂码&#39; &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. 当需要将参数从一个组件传递到另外一个组件时，可以参考以下</span><br><span class="line"></span><br><span class="line">   1. 通过路由传值有两种方式：**params和query**，两者区别如下</span><br><span class="line"></span><br><span class="line">   2. **param传参**</span><br><span class="line"></span><br><span class="line">      - **相当于post请求**，参数不会再地址栏中显示</span><br><span class="line"></span><br><span class="line">      - 需要使用命名路由，即需要配置 name: ‘xxx’；因为params只能用name来引入路由，如果这里写成了path，接收参数页面会是undefined</span><br><span class="line"></span><br><span class="line">      - 被传参的页面若跳到别的页面或者刷新页面的时候**参数会丢失**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
     // 通过params传参
     this.$router.push(&#123;
         name: &quot;newPage&quot;, // params对应路由跳转命名路由
         params: &#123;
             id: this.id
         &#125;
     &#125;);
     
     // 另外一个页面使用params接收参数
     console.log(this.$route.params.id)
     <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. **query传参**</span><br><span class="line"></span><br><span class="line">   - **相当于get请求**，页面跳转的时候，可以在地址栏看到请求参数</span><br><span class="line"></span><br><span class="line">   - 需要配置 path: ‘xxx’；通过路径进行跳转传参</span><br><span class="line"></span><br><span class="line">   - 使用query接受参数</span><br><span class="line"></span><br></pre></td></tr></table></figure>
     // 通过query传参
     this.$router.push(&#123;
         path: &quot;/newPage&quot;, // query对应路由跳转为path方式
         query: &#123;
             id: this.id
         &#125;
     &#125;);
     
     // 另外一个页面使用query接收参数
     console.log(this.$route.query.id)
     <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 路由懒加载的使用</span><br><span class="line"></span><br><span class="line">1. 懒加载：用到的时候再加载</span><br><span class="line"></span><br><span class="line">2. 认识路由的懒加载</span><br><span class="line"></span><br><span class="line">   1. 首先，我们知道路由中通常会定义很多不同的页面</span><br><span class="line"></span><br><span class="line">   2. 一般情况下，是打包放在一 个js文件中</span><br><span class="line"></span><br><span class="line">   3. 但是，页面这么多放在一个js文件中，必然会造成这个页面非常的大</span><br><span class="line"></span><br><span class="line">   4. 如果我们一次性从服务器请求下来这个页面，可能需要花费一 定的时间，甚至用户的电脑上还出现了短暂空白的情况</span><br><span class="line"></span><br><span class="line">   5. 因此就需要用到懒加载，只有路由被访问时，才加载对应组件</span><br><span class="line"></span><br></pre></td></tr></table></figure>
   routes: [
       &#123;
           name: &#39;guanyv&#39;
           path: &#39;/about&#39;,
           // 路由懒加载
           component: () =&gt; import(&#39;../views/About.vue&#39;)
       &#125;,    
   ]
</code></pre>
</li>
</ol>
<h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><ol>
<li>在某些情况下，一个页面的path路径可能是不确定的，比如我们进入用户界面时，希望是如下的路径：<ol>
<li>&#x2F;user&#x2F;aaaa或&#x2F;user&#x2F;bbbb</li>
<li>除了有前面的&#x2F;user之外，后面还跟上了用户的ID</li>
<li>这种path和Component的匹配关系，称为动态路由（也是路由传递数据的一种方式）</li>
</ol>
</li>
<li>实现方法<ol>
<li>首先创建一个User路由组件<br><img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211012001140.png" alt="img"></li>
<li>然后在index.js里面配置路由映射<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211012001158.png" alt="img"></li>
<li>在App.vue中使用路由<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211012001216.png" alt="img"></li>
</ol>
</li>
<li>需求：将data数据中的userId渲染在页面上<ol>
<li>利用计算属性获取当前活跃的组件的参数userId<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211012001233.png" alt="img"></li>
</ol>
</li>
</ol>
<h3 id="路由的默认路径及重定向和修改为history模式"><a href="#路由的默认路径及重定向和修改为history模式" class="headerlink" title="路由的默认路径及重定向和修改为history模式"></a>路由的默认路径及重定向和修改为history模式</h3><ol>
<li>需要实现当打开网页是，路径默认跳到首页，就需要多配置一个映射</li>
<li>配置解析<ol>
<li>我们在routes中又配置了一个映射</li>
<li>path配置的是根路径：&#x2F;</li>
<li>redirect是重定向，也就是我们将路径重定向到&#x2F;home的路径下<br><img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211012001022.png" alt="img"></li>
</ol>
</li>
<li>修改为history模式<br><img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211012001044.png" alt="img"></li>
</ol>
<h3 id="打包文件的解析"><a href="#打包文件的解析" class="headerlink" title="打包文件的解析"></a>打包文件的解析</h3><ol>
<li>在项目开发完毕后，进行npm run build，会在dist文件夹中进行分包</li>
<li>在js文件夹中会被分为三个包<ol>
<li>app开头的js文件：当前应用程序开发的所有代码（业务代码）</li>
<li>manifest开头的js文件：为打包的代码做底层支撑</li>
<li>vendor开头的js文件：vendor（第三方）提供的内容</li>
</ol>
</li>
</ol>
<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><ol>
<li>参数传递<ol>
<li>第一步：创建新的组件，如profile.vue</li>
<li>第二步：配置路由映射</li>
<li>第三步：添加跳转的<code>&lt;router-link&gt;</code></li>
</ol>
</li>
<li>传递参数主要有两种类型：params和query<ol>
<li>params类型（前面的动态路由即采用的这种方式）<ul>
<li>配置路由格式：&#x2F;router&#x2F;:id</li>
<li>传递的方式：在path后面跟上对应的值</li>
<li>传递后形成的路径：如&#x2F;router&#x2F;123, &#x2F;router&#x2F;abc</li>
</ul>
</li>
<li>query方式（大量数据选择）<ul>
<li>配置路由格式：&#x2F;router，也就是普通配置</li>
<li>传递的方式：对象中使用query（查询）的key作为传递方式</li>
<li>传递后形成的路径：如&#x2F;router?id&#x3D;123, &#x2F;router?id&#x3D; abc</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="文件路径引用问题"><a href="#文件路径引用问题" class="headerlink" title="文件路径引用问题"></a>文件路径引用问题</h3><ol>
<li>当开发一个项目时，会经常需要引入文件，当文件夹嵌套过多时，引入文件的路径就会非常的繁琐，而且很容易弄错；并且当文件移动到其他位置时，之前引入该文件的路径也需要全部修改，非常麻烦</li>
<li>解决方法：给文件起别名<ol>
<li>用到webpack的一个配置文件：webpack.base.cong.js<img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211012001443.png" alt="img"></li>
<li>注意：在html标签内引入的路径使用文件的别名时，需要在路径的最前面加”~”</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vw和vh</title>
    <url>/2022/08/01/vw%E5%92%8Cvh/</url>
    <content><![CDATA[<h1 id="vw和vh"><a href="#vw和vh" class="headerlink" title="vw和vh"></a>vw和vh</h1><h2 id="vw和vh是什么"><a href="#vw和vh是什么" class="headerlink" title="vw和vh是什么"></a>vw和vh是什么</h2><ol>
<li>vw&#x2F;vh是一个相对单位（类似em和rem相对单位）<ol>
<li>vw是：viewport width 视口宽度单位</li>
<li>vh是：viewport height 视口高度单位</li>
</ol>
</li>
<li>相对视口的尺寸计算结果<ol>
<li>1vw &#x3D; 1&#x2F;100视口宽度</li>
<li>1vh &#x3D; 1&#x2F;100视口高度</li>
</ol>
</li>
<li>例如：当前屏幕视口是375像素，则1vw就是3.75像素，如果当前屏幕视口为414,则1vw为4.14px</li>
<li>与百分比的区别<ol>
<li>百分比是相对于父元素，而vw和vh总是针对于当前视口</li>
</ol>
</li>
</ol>
<h2 id="vw和vh使用"><a href="#vw和vh使用" class="headerlink" title="vw和vh使用"></a>vw和vh使用</h2><ol>
<li>例：我们设计稿按照iPhone678来设计，有个盒子是50像素* 50像素的，如何使用vw呢</li>
<li>分析：<ol>
<li>设计稿参照iPhone678，所以视口宽度尺寸是375像素（像素切换到2x模式）</li>
<li>那么1vw是多少像素<ul>
<li>375px &#x2F; 100 &#x3D; 3.75px</li>
</ul>
</li>
<li>元素的目标是多少像素<ul>
<li>50px * 50px</li>
</ul>
</li>
<li>那么50px * 50px是多少个vw<ul>
<li>50 &#x2F; 3.75 &#x3D; 13.3333</li>
</ul>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>响应式布局和Bootstrap</title>
    <url>/2022/08/01/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%E5%92%8CBootstrap/</url>
    <content><![CDATA[<h1 id="响应式开发"><a href="#响应式开发" class="headerlink" title="响应式开发"></a>响应式开发</h1><h2 id="响应式开发布局原理"><a href="#响应式开发布局原理" class="headerlink" title="响应式开发布局原理"></a>响应式开发布局原理</h2><ol>
<li><p>使用媒体查询针对不同宽度的设备进行布局和样式的设置，从而适配不同设备的目的</p>
<table>
<thead>
<tr>
<th>设备划分</th>
<th>尺寸区间</th>
</tr>
</thead>
<tbody><tr>
<td>超小屏幕（手机）</td>
<td>&lt;768px</td>
</tr>
<tr>
<td>小屏设备（平板）</td>
<td>&gt;&#x3D;768px ~ 992px</td>
</tr>
<tr>
<td>中等屏幕（桌面显示器）</td>
<td>&gt;&#x3D;992px ~ &lt;1200px</td>
</tr>
<tr>
<td>宽屏设备（大桌面显示器）</td>
<td>&gt;&#x3D;1200px</td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="响应式布局容器"><a href="#响应式布局容器" class="headerlink" title="响应式布局容器"></a>响应式布局容器</h2><h3 id="响应式尺寸划分"><a href="#响应式尺寸划分" class="headerlink" title="响应式尺寸划分"></a>响应式尺寸划分</h3><ol>
<li>超小屏幕（手机 小于768px）：设置宽度为100%</li>
<li>小屏幕（平板 大于等于768px）：设置宽度为750px</li>
<li>中等屏幕（桌面显示器 大于等于992px）：宽度设置为970px</li>
<li>大屏幕（大桌面显示器 大于等于1200px）：宽度设置为1170px</li>
</ol>
<h1 id="Bootstrap前端开发框架"><a href="#Bootstrap前端开发框架" class="headerlink" title="Bootstrap前端开发框架"></a>Bootstrap前端开发框架</h1><h2 id="Bootstrap简介"><a href="#Bootstrap简介" class="headerlink" title="Bootstrap简介"></a>Bootstrap简介</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ol>
<li>Bootstrap来自Twitter（推特），是目前最受欢迎的前端框架</li>
<li>Bootstrap是基于HTML，CSS和JavaScript的，简洁灵活，使web开发更加快捷</li>
<li>官网： <a href="http://getbootstrap.com/">http://getbootstrap.com/</a></li>
<li>中文官网： <a href="http://www.bootcss.com/">http://www.bootcss.com/</a></li>
<li>推荐使用： <a href="https://v3.bootcss.com/">https://v3.bootcss.com/</a></li>
</ol>
<h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><ol>
<li>一套架构，有一套比较完整的网页功能解决方案，而且控制权在框架本身，有预制样式库、组件和插件；使用者要按照框架所规定的某种规范进行开发</li>
<li>优点<ol>
<li>标准化的html + css编码规范</li>
<li>提供了一套简洁、直观、强悍的组件</li>
<li>有自己的生态圈，不断的更新迭代台</li>
<li>让开发更简单，提高了开发的效率</li>
</ol>
</li>
</ol>
<h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><ol>
<li>2.x.x：停止维护,兼容性好代码不够简洁,功能不够完善。</li>
<li>3.x.x：目前使用最多,稳定,但是放弃了IE6-IE7。对IE8支持但是界面效果不好，偏向用于开发响应式布局、移动设备优先的WEB项目</li>
<li>4.x.x：最新版,目前还不是很流行</li>
</ol>
<h2 id="Bootstrap使用"><a href="#Bootstrap使用" class="headerlink" title="Bootstrap使用"></a>Bootstrap使用</h2><ol>
<li><p>Bootstrap使用四部曲：</p>
<ol>
<li><p>创建文件夹结构<br><img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20210923001002.png" alt="img"></p>
</li>
<li><p>创建html骨架结构<br><img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20210923000921.png" alt="img"></p>
</li>
<li><p>引入相关样式文件<br><img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20210923001036.png" alt="img"></p>
</li>
<li><p>书写内容</p>
<ul>
<li><p>可以利用我们自己写的样式覆盖原先的样式</p>
</li>
<li><p>如果书写样式后，发现没有效果，可能是权重不够，加权即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">&lt;!--[if lt IE 9]&gt;</span><br><span class="line">    .解决ie9以下浏览器对html5新增标签的不识别,并导致CSS不起作用的问题</span><br><span class="line">    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">解决ie9以下浏览器对Css3 Media Query的不识别</span><br><span class="line">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;![endif]--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 引入Bootstrap样式文件 --&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;Bootstrap/css/bootstrap.min.css&quot;&gt;</span><br><span class="line">&lt;title&gt;Bootstrap使用&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">    /* 可以利用我们自己写的样式覆盖原先的样式 */</span><br><span class="line">    .login &#123;</span><br><span class="line">        width: 200px;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;button type=&quot;button&quot; class=&quot;btn btn-primary login&quot;&gt;Primary&lt;/button&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="布局容器"><a href="#布局容器" class="headerlink" title="布局容器"></a>布局容器</h2><ol>
<li>Bootstrap需要为页面内容和栅格系统包裹一个.container容器，Bootstarp预定义好了这个类，叫.container，它提供了两个做此作用的类</li>
<li>容器分类<ul>
<li>container 两边有留白的宽度</li>
<li>container-fluid 每一种设备都是100%宽度</li>
</ul>
</li>
</ol>
<h2 id="container类"><a href="#container类" class="headerlink" title="container类"></a>container类</h2><ol>
<li>响应式布局的容器固定宽度</li>
<li>大屏(&gt;&#x3D;1200px) 宽度定为1170px</li>
<li>中屏(&gt;&#x3D;992px) 宽度定为970px</li>
<li>小屏(&gt;&#x3D;768px) 宽度定为750px</li>
<li>超小屏(100%)</li>
</ol>
<h2 id="container-fluid类"><a href="#container-fluid类" class="headerlink" title="container-fluid类"></a>container-fluid类</h2><ol>
<li>流式布局容器百分百宽度</li>
<li>占据全部视口(viewport)的容器</li>
<li>适合于单独做移动端开发</li>
</ol>
<h1 id="Bootstrap栅格系统"><a href="#Bootstrap栅格系统" class="headerlink" title="Bootstrap栅格系统"></a>Bootstrap栅格系统</h1><h2 id="栅格系统"><a href="#栅格系统" class="headerlink" title="栅格系统"></a>栅格系统</h2><h3 id="栅格系统原理"><a href="#栅格系统原理" class="headerlink" title="栅格系统原理"></a>栅格系统原理</h3><ol>
<li>栅格系统英文为”grid systems” ，也有人翻译为“网格系统”，它是指将页面布局划分为等宽的列，然后通过列数的定义来模块化页面布局</li>
<li>Bootstrap提供了一套响应式、移动设备优先的流式栅格系统，随着屏幕或视口( viewport )尺寸的增加，系统会自动分为最多12列</li>
<li>Bootstrap里面container宽度是固定的，但是不同屏幕下，container的宽度不同，我们再把container划分为12等份</li>
</ol>
<h2 id="栅格系统使用"><a href="#栅格系统使用" class="headerlink" title="栅格系统使用"></a>栅格系统使用</h2><h3 id="栅格选项参数"><a href="#栅格选项参数" class="headerlink" title="栅格选项参数"></a>栅格选项参数</h3><ol>
<li><p>栅格系统用于通过一系列的行（row）与列（column）的组合来创建页面布局，内容就可以放入这些创建好的布局中</p>
<table>
<thead>
<tr>
<th>.</th>
<th>超小屏幕（手机）</th>
<th>小屏设备（平板）</th>
<th>中等屏幕（桌面显示器）</th>
<th>宽屏设备（大桌面显示器）</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;768px</td>
<td>&gt;&#x3D;768px</td>
<td>&gt;&#x3D;992px</td>
<td>&gt;&#x3D;1200px</td>
<td></td>
</tr>
<tr>
<td>.container 最大宽度</td>
<td>自动（100%）</td>
<td>750px</td>
<td>970px</td>
<td>1170px</td>
</tr>
<tr>
<td>类前缀</td>
<td>.col-xs-</td>
<td>.col-sm-</td>
<td>.col-md-</td>
<td>.col-lg-</td>
</tr>
<tr>
<td>列数</td>
<td>12</td>
<td>12</td>
<td>12</td>
<td>12</td>
</tr>
</tbody></table>
<ol>
<li><p>行（row）必须放到container布局容器里面<br><img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20210923002908.png" alt="img"></p>
</li>
<li><p>实现列的平均划分需要给列添加类前缀<br><img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20210923002952.png" alt="img"></p>
</li>
<li><p>如果孩子的份数相加等于12则：孩子能占满整个的container的宽度</p>
</li>
<li><p>如果孩子的份数相加小于12则：占不满整个container 的宽度会有空白</p>
</li>
<li><p>如果孩子的份数相加大于12则：多于的那一列会另起一行显示</p>
</li>
<li><p>每一列默认有左右15像素的padding，可以通过自己写样式进行覆盖：padding: 0;</p>
</li>
<li><p>可以同时为一列指定多个设备的类名，以便划分不同份数，例如class&#x3D;”col-md-4 col-sm-6”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;!--[if lt IE 9]&gt;</span><br><span class="line">        .解决ie9以下浏览器对html5新增标签的不识别,并导致CSS不起作用的问题</span><br><span class="line">        &lt;script src=&quot;https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">        解决ie9以下浏览器对Css3 Media Query的不识别</span><br><span class="line">        &lt;script src=&quot;https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;![endif]--&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 引入Bootstrap样式文件 --&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;Bootstrap/css/bootstrap.min.css&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        [class^=&quot;col&quot;] &#123;</span><br><span class="line">            border: 1px solid black;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .container .row:last-child &#123;</span><br><span class="line">            background-color: pink;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">        &lt;!-- 行（row）必须放到container布局容器里面 --&gt;</span><br><span class="line">        &lt;div class=&quot;row&quot;&gt;</span><br><span class="line">            &lt;div class=&quot;col-lg-3&quot;&gt;1&lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;col-lg-3&quot;&gt;2&lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;col-lg-3&quot;&gt;3&lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;col-lg-3&quot;&gt;4&lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 如果孩子的份数相加等于12则：孩子能占满整个的container的宽度 --&gt;</span><br><span class="line">        &lt;div class=&quot;row&quot;&gt;</span><br><span class="line">            &lt;div class=&quot;col-lg-6&quot;&gt;1&lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;col-lg-2&quot;&gt;2&lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;col-lg-2&quot;&gt;3&lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;col-lg-2&quot;&gt;4&lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 如果孩子的份数相加小于12则：占不满整个container 的宽度会有空白 --&gt;</span><br><span class="line">        &lt;div class=&quot;row&quot;&gt;</span><br><span class="line">            &lt;div class=&quot;col-lg-4&quot;&gt;1&lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;col-lg-2&quot;&gt;2&lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;col-lg-2&quot;&gt;3&lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;col-lg-2&quot;&gt;4&lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 如果孩子的份数相加大于12则：多于的那一列会另起一行显示 --&gt;</span><br><span class="line">        &lt;div class=&quot;row&quot;&gt;</span><br><span class="line">            &lt;div class=&quot;col-lg-4&quot;&gt;1&lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;col-lg-4&quot;&gt;2&lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;col-lg-3&quot;&gt;3&lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;col-lg-3&quot;&gt;4&lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 可以同时为一列指定多个设备的类名以便划分不同份数，例如class=”col-md-4 col-sm-6&quot; --&gt;</span><br><span class="line">        &lt;div class=&quot;row&quot;&gt;</span><br><span class="line">            &lt;div class=&quot;col-lg-3 col-md-4 col-sm-6 col-xs-12&quot;&gt;1&lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;col-lg-3 col-md-4 col-sm-6 col-xs-12&quot;&gt;2&lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;col-lg-3 col-md-4 col-sm-6 col-xs-12&quot;&gt;3&lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;col-lg-3 col-md-4 col-sm-6 col-xs-12&quot;&gt;4&lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="列嵌套"><a href="#列嵌套" class="headerlink" title="列嵌套"></a>列嵌套</h3><ol>
<li>栅格系统内置的栅格系统将内容再次嵌套；简单理解就是一个列内再分成若干份小列；我们可以通过添加一个新的.row元素和一系列.col-sm-*元素到已经存在的.col-sm-*元素内<br><img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20210923003521.png" alt="img"></li>
<li>列嵌套最好加1个行row这样可以取消父元素的padding值而且高度自动和父级一样高<br><img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20210923003615.png" alt="img"></li>
</ol>
<h3 id="列偏移"><a href="#列偏移" class="headerlink" title="列偏移"></a>列偏移</h3><ol>
<li>使用.col-md-offset-<em>类可以将列向右侧偏移。这些类实际是通过使用</em>选择器为当前元素增加了左侧的边距（margin）<br><img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20210923003702.png" alt="img"></li>
</ol>
<h3 id="列排序"><a href="#列排序" class="headerlink" title="列排序"></a>列排序</h3><ol>
<li>通过使用.col-md-push-*和.col-md-pull-*类就可以很容易的改变列（column）的顺序<ol>
<li>pull：拉</li>
<li>push：推<br><img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20210923003822.png" alt="img"></li>
</ol>
</li>
</ol>
<h2 id="响应式工具"><a href="#响应式工具" class="headerlink" title="响应式工具"></a>响应式工具</h2><ol>
<li><p>为了加快对移动设备友好的页面开发工作，利用媒体查询功能，并使用这些工具类可以方便的针对不同设备展示或隐藏页面内容</p>
<ol>
<li><p>隐藏</p>
<table>
<thead>
<tr>
<th>类名</th>
<th>超小屏</th>
<th>小屏</th>
<th>中屏</th>
<th>大屏</th>
</tr>
</thead>
<tbody><tr>
<td>.hidden-xs</td>
<td>隐藏</td>
<td>可见</td>
<td>可见</td>
<td>可见</td>
</tr>
<tr>
<td>.hidden-sm</td>
<td>可见</td>
<td>隐藏</td>
<td>可见</td>
<td>可见</td>
</tr>
<tr>
<td>.hidden-md</td>
<td>可见</td>
<td>可见</td>
<td>隐藏</td>
<td>可见</td>
</tr>
<tr>
<td>.hidden-lg</td>
<td>可见</td>
<td>可见</td>
<td>可见</td>
<td>隐藏</td>
</tr>
</tbody></table>
</li>
<li><p>可见</p>
<table>
<thead>
<tr>
<th>类名</th>
<th>超小屏</th>
<th>小屏</th>
<th>中屏</th>
<th>大屏</th>
</tr>
</thead>
<tbody><tr>
<td>.visible-xs</td>
<td>可见</td>
<td>隐藏</td>
<td>隐藏</td>
<td>隐藏</td>
</tr>
<tr>
<td>.visible-sm</td>
<td>隐藏</td>
<td>可见</td>
<td>隐藏</td>
<td>隐藏</td>
</tr>
<tr>
<td>.visible-md</td>
<td>隐藏</td>
<td>隐藏</td>
<td>可见</td>
<td>隐藏</td>
</tr>
<tr>
<td>.visible-lg</td>
<td>隐藏</td>
<td>隐藏</td>
<td>隐藏</td>
<td>可见</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>本地存储</title>
    <url>/2022/08/01/%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<h1 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h1><ol>
<li>随着互联网的快速发展，基于网页的应用越来越普遍，同时也变的越来越复杂，为了满足各种各样的需求，会经常性在本地存储大量的数据，HTML5规范提出了相关解决方案</li>
</ol>
<h2 id="本地存储特性"><a href="#本地存储特性" class="headerlink" title="本地存储特性"></a>本地存储特性</h2><ol>
<li>数据存储在用户浏览器中</li>
<li>设置、读取方便、甚至页面刷新不失数据</li>
<li>容量较大，sessionStorage约5M、localStorage约20M</li>
<li>只能存储字符串，可以将对象JSON.stringify()编码后存储</li>
</ol>
<h2 id="sessionStorage和localStorage"><a href="#sessionStorage和localStorage" class="headerlink" title="sessionStorage和localStorage"></a>sessionStorage和localStorage</h2><h3 id="sessionStorage概述"><a href="#sessionStorage概述" class="headerlink" title="sessionStorage概述"></a>sessionStorage概述</h3><ol>
<li>生命周期为关闭浏览器窗口</li>
<li>在同一个窗口（页面）下数据可以共享</li>
<li>以键值对的形式存储使用</li>
</ol>
<h3 id="sessionStorage方法（重点）"><a href="#sessionStorage方法（重点）" class="headerlink" title="sessionStorage方法（重点）"></a>sessionStorage方法（重点）</h3><ol>
<li><p>存储数据：sessionStorage.setItem(key, value);</p>
</li>
<li><p>获取数据：sessionStorage.getItem(key);</p>
</li>
<li><p>删除数据：sessionStorage.removeItem(key);</p>
</li>
<li><p>删除所有数据：sessionStorage.clear();</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot;&gt;</span><br><span class="line">    &lt;button class=&quot;set&quot;&gt;存储数据&lt;/button&gt;</span><br><span class="line">    &lt;button class=&quot;get&quot;&gt;获取数据&lt;/button&gt;</span><br><span class="line">    &lt;button class=&quot;remove&quot;&gt;删除数据&lt;/button&gt;</span><br><span class="line">    &lt;button class=&quot;clear&quot;&gt;删除所有数据&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        console.log(localStorage.getItem(&#x27;uname&#x27;));</span><br><span class="line"></span><br><span class="line">        var ipt = document.querySelector(&#x27;input&#x27;)</span><br><span class="line">        var set = document.querySelector(&#x27;.set&#x27;);</span><br><span class="line">        var get = document.querySelector(&#x27;.get&#x27;);</span><br><span class="line">        var remove = document.querySelector(&#x27;.remove&#x27;);</span><br><span class="line">        var clear = document.querySelector(&#x27;.clear&#x27;);</span><br><span class="line">        // 存储数据</span><br><span class="line">        set.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">            var v_set = ipt.value;</span><br><span class="line">            sessionStorage.setItem(&#x27;uname&#x27;, v_set);</span><br><span class="line">            sessionStorage.setItem(&#x27;pwd&#x27;, v_set);</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        // 获取数据</span><br><span class="line">        get.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">            var v_get = sessionStorage.getItem(&#x27;uname&#x27;);</span><br><span class="line">            console.log(v_get);</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        // 删除数据</span><br><span class="line">        remove.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">            sessionStorage.removeItem(&#x27;uname&#x27;);</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        // 删除所有数据</span><br><span class="line">        clear.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">            sessionStorage.clear();</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="localStorage概述"><a href="#localStorage概述" class="headerlink" title="localStorage概述"></a>localStorage概述</h3><ol>
<li>生命周期永久生效，除非手动删除，否则关闭页面也会存在</li>
<li>可以多窗口（页面）共享（同一浏览器可以共享）</li>
<li>以键值对的形式存储使用</li>
</ol>
<h3 id="localStorage方法（重点）"><a href="#localStorage方法（重点）" class="headerlink" title="localStorage方法（重点）"></a>localStorage方法（重点）</h3><ol>
<li><p>存储数据：localStorage.setItem(key, value);</p>
</li>
<li><p>获取数据：localStorage.getItem(key);</p>
</li>
<li><p>删除数据：localStorage.removeItem(key);</p>
</li>
<li><p>删除所有数据：localStorage.clear();</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot;&gt;</span><br><span class="line">    &lt;button class=&quot;set&quot;&gt;存储数据&lt;/button&gt;</span><br><span class="line">    &lt;button class=&quot;get&quot;&gt;获取数据&lt;/button&gt;</span><br><span class="line">    &lt;button class=&quot;remove&quot;&gt;删除数据&lt;/button&gt;</span><br><span class="line">    &lt;button class=&quot;clear&quot;&gt;删除所有数据&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var ipt = document.querySelector(&#x27;input&#x27;)</span><br><span class="line">        var set = document.querySelector(&#x27;.set&#x27;);</span><br><span class="line">        var get = document.querySelector(&#x27;.get&#x27;);</span><br><span class="line">        var remove = document.querySelector(&#x27;.remove&#x27;);</span><br><span class="line">        var clear = document.querySelector(&#x27;.clear&#x27;);</span><br><span class="line">        // 存储数据</span><br><span class="line">        set.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">            var v_set = ipt.value;</span><br><span class="line">            localStorage.setItem(&#x27;uname&#x27;, v_set);</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        // 获取数据</span><br><span class="line">        get.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">            var v_get = localStorage.getItem(&#x27;uname&#x27;);</span><br><span class="line">            console.log(v_get);</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        // 删除数据</span><br><span class="line">        remove.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">            localStorage.removeItem(&#x27;uname&#x27;);</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        // 删除所有数据</span><br><span class="line">        clear.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">            localStorage.clear();</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>流式布局</title>
    <url>/2022/08/01/%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h1 id="流式布局"><a href="#流式布局" class="headerlink" title="流式布局"></a>流式布局</h1><ol>
<li>流式布局，即百分比布局，也称非固定像素布局</li>
<li>通过盒子和宽度设置 成百分比来根据屏幕的宽度来进行伸缩，不受固定像素的限制，内容向两侧填充</li>
<li>流式布局的方式是移动web开发使用的比较常见的布局方式</li>
</ol>
<h2 id="body设置"><a href="#body设置" class="headerlink" title="body设置"></a>body设置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">​```</span><br><span class="line">body &#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">  min-width: 320px;</span><br><span class="line">  max-width: 640px;</span><br><span class="line">  margin: 0 auto;</span><br><span class="line">  font-size: 14px;</span><br><span class="line">  font-family: -apple-system, Helvetica, sans-serif;</span><br><span class="line">  color: #666;</span><br><span class="line">  line-height: 1.5;</span><br><span class="line">&#125;</span><br><span class="line">​```</span><br></pre></td></tr></table></figure>

<h2 id="二倍精灵图做法"><a href="#二倍精灵图做法" class="headerlink" title="二倍精灵图做法"></a>二倍精灵图做法</h2><ol>
<li>在ps中里面把精灵图等比例缩放为原来的一半</li>
<li>根据大小测量坐标</li>
<li>注意代码里面background-size也要写：精灵图原来宽度的一半</li>
</ol>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>构造函数和原型</title>
    <url>/2022/08/01/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E5%8E%9F%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="构造函数和原型"><a href="#构造函数和原型" class="headerlink" title="构造函数和原型"></a>构造函数和原型</h1><h2 id="构造函数和原型-1"><a href="#构造函数和原型-1" class="headerlink" title="构造函数和原型"></a>构造函数和原型</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol>
<li><p>在典型的OOP的语言中（如Java），都存在类的概念，类就是对象的模板，对象就是类的实例，但在ES6之前，JS中并没有引入类的概念</p>
</li>
<li><p>ES6，全称ECMAScript6.0，2015.06发版。但是目前浏览器的JavaScript是ES5版本，大多数高版本的浏览器也支持ES6，不过只实现了ES6的部分特性和功能</p>
</li>
<li><p>在ES6之前，对象不是基于类创建的而是用一种称为构造函数的特殊函数来定义对象和特征</p>
</li>
<li><p>创建对象可以通过以下三种方式</p>
<ol>
<li><p>对象字面量</p>
</li>
<li><p>new Object()</p>
</li>
<li><p>自定义构造函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  // 方式一：通过字面量创建对象</span><br><span class="line">  var dog = &#123;</span><br><span class="line">    name: &#x27;熊二&#x27;,</span><br><span class="line">    type: &#x27;金毛&#x27;,</span><br><span class="line">    showFlie: function () &#123;</span><br><span class="line">      console.log(&#x27;hello world!&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  // 利用object创建对象</span><br><span class="line">  var cat = new Object();</span><br><span class="line">  cat.name = &#x27;熊大&#x27;;</span><br><span class="line">  cat.type = &#x27;英短&#x27;;</span><br><span class="line">  cat.showFlie = function () &#123;</span><br><span class="line">    console.log(&#x27;hello world!&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 利用构造函数创建对象</span><br><span class="line">  function Star(name, sex) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.sex = sex;</span><br><span class="line">    this.showFlie = function () &#123;</span><br><span class="line">      console.log(&#x27;hello world!&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ol>
<li>构造函数是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与new一起使用；我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面</li>
<li>new在执行时会做四件事情<ol>
<li>在内存中创建一个新的空对象</li>
<li>让this指向这个新的对象</li>
<li>执行构造函数里面的代码，给这个新对象添加属性和方法</li>
<li>返回这个新对象（所以构造函数里面不需要return）</li>
</ol>
</li>
</ol>
<h3 id="实例成员和静态成员（重点）"><a href="#实例成员和静态成员（重点）" class="headerlink" title="实例成员和静态成员（重点）"></a>实例成员和静态成员（重点）</h3><ol>
<li><p>构造函数中的属性和方法称为成员，成员可以添加，且有两大类</p>
<ol>
<li>实例成员</li>
<li>静态成员</li>
</ol>
</li>
<li><p>实例成员</p>
<ol>
<li>实例对象是构造函数内部通过this添加的成员</li>
<li>实例成员只能通过实例化对象来访问，不能通过构造函数来访问</li>
</ol>
</li>
<li><p>静态成员</p>
<ol>
<li><p>静态成员是函数本身上添加的成员</p>
</li>
<li><p>静态成员只能通过构造函数来访问，不能通过实例化对象访问</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  // 构造函数</span><br><span class="line">  function Star(name, age) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.sing = function (song) &#123;</span><br><span class="line">      console.log(song);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var ldh = new Star(&#x27;刘德华&#x27;, 47);</span><br><span class="line">  // 实例成员：构造函数内部通过this添加的成员 --- name，age，sing()</span><br><span class="line">  // 只能通过实例化对象来访问</span><br><span class="line">  console.log(ldh.name); // 刘德华</span><br><span class="line">  console.log(ldh.age); // 47</span><br><span class="line">  ldh.sing(&#x27;冰雨&#x27;); // 冰雨</span><br><span class="line">  // 不能通过构造函数来访问</span><br><span class="line">  console.log(Star.age); // undefined</span><br><span class="line"></span><br><span class="line">  // 静态成员：是函数本身上添加的成员</span><br><span class="line">  Star.sex = &#x27;男&#x27;;</span><br><span class="line">  // 只能通过构造函数来访问</span><br><span class="line">  console.log(Star.sex); // 男</span><br><span class="line">  // 不能通过实例化对象访问</span><br><span class="line">  console.log(ldh.sex); // undefined</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="构造函数的问题"><a href="#构造函数的问题" class="headerlink" title="构造函数的问题"></a>构造函数的问题</h3><ol>
<li>构造函数方法创建对象虽然很好用，但是存在一个内存浪费的问题</li>
<li>因为在构造函数中往往会存在方法，每当对象进行实例化时，就会为实例化对象的方法开辟一个空间，当实例化对象数量多了以后，就会为同一个函数创建多个空间，造成内存浪费</li>
<li>解决方法：构造函数原型 prototype</li>
</ol>
<h3 id="构造函数原型-prototype（重点）"><a href="#构造函数原型-prototype（重点）" class="headerlink" title="构造函数原型 prototype（重点）"></a>构造函数原型 prototype（重点）</h3><ol>
<li><p>构造函数通过原型分配的函数是所有对象所共享的</p>
</li>
<li><p>JavaScript规定，每一个构造函数都有一个prototype属性，指向另一个对象。注意这个prototype就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有</p>
</li>
<li><p>可以把这些不变的方法，直接定义在prototype对象上，这样所有对象的实例就可以共享这些方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Star(name, age) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 构造函数原型</span><br><span class="line">Star.prototype.sing = function () &#123;</span><br><span class="line">  console.log(&#x27;唱歌&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">Star.prototype.dance = function () &#123;</span><br><span class="line">  console.log(&#x27;跳舞&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>问答：</p>
<ol>
<li>原型是什么？<ul>
<li>一个对象，我们也称为prototype为原型对象</li>
</ul>
</li>
<li>原型的作用是什么？<ul>
<li>共享方法</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="对象原型-proto-（前后两个下划线）（重点）"><a href="#对象原型-proto-（前后两个下划线）（重点）" class="headerlink" title="对象原型__proto__（前后两个下划线）（重点）"></a>对象原型<code>__proto__</code>（前后两个下划线）（重点）</h3><ol>
<li><p>对象都会有一个属性<code>__proto__</code>指向构造函数的prototype原型对象，之所以我们对象可以使用构造函数prototype原型对象的属性和方法，就是因为对象有<code>__proto__</code>原型的存在</p>
</li>
<li><p>在对象上系统会自动添加一个<code>__proto__</code>，指向构造函数的原型对象</p>
</li>
<li><p><code>__proto__</code>对象原型和构造函数原型对象prototype是等价的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Star(name, age) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 构造函数原型</span><br><span class="line">Star.prototype.sing = function () &#123;</span><br><span class="line">  console.log(&#x27;唱歌&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">Star.prototype.dance = function () &#123;</span><br><span class="line">  console.log(&#x27;跳舞&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">var ldh = new Star(&#x27;刘德华&#x27;, 47);</span><br><span class="line">// ldh.__proto__: 对象原型     Star.prototype: 构造函数原型对象</span><br><span class="line">console.log(ldh.__proto__ === Star.prototype); // true</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>__proto__</code>对象原型的意义就在于为对象的查找机制提供一个方向，或者说一条线路，但是它是一个非标准属性，因此实际开发中，不可以使用这个属性，它只是内部指向原型对象prototype<br><img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211007003736.png" alt="img"></p>
</li>
<li><p>方法的查找规则</p>
<ol>
<li>首先看实例化对象中是否有需要的方法，如果有就执行这个对象上的方法</li>
<li>如果没有这个需要的方法，因为有<code>__proto__</code>的存在，就去构造函数原型对象prototype中去查找需要的方法</li>
</ol>
</li>
</ol>
<h3 id="constructor指回构造函数"><a href="#constructor指回构造函数" class="headerlink" title="constructor指回构造函数"></a>constructor指回构造函数</h3><ol>
<li><p>对象原型（<code>__proto__</code>）和构造函数（prototype）原型对象里面都有一个属性constructor属性，constructor称为构造函数，因为它指回构造函数本身</p>
</li>
<li><p>很多情况下，需要手动利用constructor这个属性指回原来的构造函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  function Star(name, age) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 修改Star的构造函数原型对象，并且给构造函数原型对象赋值为一个对象，这个对象就会覆盖原来的原型对象，因此需要手动利用constructor指回原来的构造函数</span><br><span class="line">  Star.prototype = &#123;</span><br><span class="line">    // 手动利用constructor这个属性指回原来的构造函数</span><br><span class="line">    constructor: Star,</span><br><span class="line">    sing: function () &#123;</span><br><span class="line">      console.log(&#x27;唱歌&#x27;);</span><br><span class="line">    &#125;,</span><br><span class="line">    dance: function () &#123;</span><br><span class="line">      console.log(&#x27;跳舞&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  var ldh = new Star(&#x27;张学友&#x27;, 50);</span><br><span class="line">  // 对象的原型</span><br><span class="line">  console.log(ldh.__proto__);</span><br><span class="line">  // 构造函数原型对象</span><br><span class="line">  console.log(Star.prototype);</span><br><span class="line">  // 对象原型（__proto__）和构造函数（prototype）原型对象里面都有一个属性constructor属性</span><br><span class="line">  console.log(ldh.__proto__.constructor);</span><br><span class="line">  console.log(Star.prototype.constructor);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="构造函数、原型对象、实例对象之间的关系"><a href="#构造函数、原型对象、实例对象之间的关系" class="headerlink" title="构造函数、原型对象、实例对象之间的关系"></a>构造函数、原型对象、实例对象之间的关系</h3><p><img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211007004449.png" alt="img"></p>
<h3 id="原型链（面试必问重点）"><a href="#原型链（面试必问重点）" class="headerlink" title="原型链（面试必问重点）"></a>原型链（面试必问重点）</h3><p><img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211007004537.png" alt="img"></p>
<h3 id="JavaScript的成员查找机制（规则）"><a href="#JavaScript的成员查找机制（规则）" class="headerlink" title="JavaScript的成员查找机制（规则）"></a>JavaScript的成员查找机制（规则）</h3><ol>
<li>当访问一个对象的属性(包括方法)时，首先查找这个对象自身有没有该属性</li>
<li>如果没有就查找它的原型(也就是<code>__proto__</code>指向的prototype原型对象)</li>
<li>如果还没有就查找原型对象的原型( Object的原型对象)</li>
<li>依此类推一直找到Object为止 (null)</li>
<li><code>__proto__</code>对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线</li>
</ol>
<h3 id="原型对象this指向"><a href="#原型对象this指向" class="headerlink" title="原型对象this指向"></a>原型对象this指向</h3><ol>
<li>原型对象和构造函数中的this指向的都是实例对象</li>
</ol>
<h3 id="原型对象典型应用-—-扩展内置对象"><a href="#原型对象典型应用-—-扩展内置对象" class="headerlink" title="原型对象典型应用 — 扩展内置对象"></a>原型对象典型应用 — 扩展内置对象</h3><ol>
<li><p>可以通过原型对象，对原来的内置对象进行扩展自定义的方法；比如给数组增加自定义求和的功能</p>
</li>
<li><p>注意：数组和字符串内置对象不能给原型对象覆盖操作Array.prototype &#x3D; {}，只能是Array.prototype.方法名 &#x3D; function(){}的方式</p>
</li>
<li><p>例：给数组增加自定义求和的功能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    // 给数组对象添加内置对象sum</span><br><span class="line">    Array.prototype.sum = function () &#123;</span><br><span class="line">      var sum = 0;</span><br><span class="line">      for (var i = 0; i &lt; this.length; i++) &#123;</span><br><span class="line">        sum += this[i];</span><br><span class="line">      &#125;</span><br><span class="line">      return sum;</span><br><span class="line">    &#125;</span><br><span class="line">    var arr = new Array(1, 2, 3);</span><br><span class="line">    console.log(arr.sum());</span><br><span class="line">    console.log(Array.prototype);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>ES5</category>
      </categories>
      <tags>
        <tag>ES5</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2022/08/01/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol>
<li>正则表达式：用于匹配字符串中字符组合的模式，在JavaScript中，正则表达式也是对象</li>
<li>正则表通常被用来检索、替换那些符合某个模式（规则）的文本，例如验证表单：用户名表单只能输入英文字母、数字或者下划线，昵称输入框中可以输入中文（匹配）；此外，正则表达式还常用于过滤掉页面内容中的一些敏感词（替换) ，或从字符串中获取我们想要的特定部分（提取）等</li>
</ol>
<h2 id="正则表达式特点"><a href="#正则表达式特点" class="headerlink" title="正则表达式特点"></a>正则表达式特点</h2><ol>
<li>灵活性、逻辑性和功能性非常的强</li>
<li>可以迅速地用极简单的方式达到字符串的复杂控制</li>
<li>对于刚接触的人来说，比较晦涩难懂</li>
<li>实际开发，一般都是直接复制写好的正则表达式但是要求会使用正则表达式并且根据实际情况修改正则表达式</li>
</ol>
<h2 id="正则表达式的使用"><a href="#正则表达式的使用" class="headerlink" title="正则表达式的使用"></a>正则表达式的使用</h2><h3 id="创建正则表达式"><a href="#创建正则表达式" class="headerlink" title="创建正则表达式"></a>创建正则表达式</h3><ol>
<li>在JavaScript中，可以通过两种方式创建一个正则表达式</li>
<li>方式一：通过调用RegExp对象的构造函数创建<ul>
<li>var 变量名 &#x3D; new RegExp(&#x2F;表达式&#x2F;);</li>
</ul>
</li>
<li>方式二：通过字面量创建<ul>
<li>var 变量名 &#x3D; &#x2F;表达式&#x2F;;</li>
</ul>
</li>
<li>&#x2F;&#x2F;注释中间放表达式就是正则字面量</li>
</ol>
<h3 id="测试正则表达式test"><a href="#测试正则表达式test" class="headerlink" title="测试正则表达式test"></a>测试正则表达式test</h3><ol>
<li><p>test()正则对象方法，用于检测字符串是否符合该规则，该对象会返回true或false，参数是测试字符串</p>
</li>
<li><p>语法</p>
<ul>
<li>regexObj.test(str)</li>
</ul>
<ol>
<li>regexObj：写的正则表达式</li>
<li>str：要测试的文本</li>
<li>检测str文本是否符合写的正则表达式规范</li>
</ol>
</li>
</ol>
<h2 id="正则表达式中特殊字符"><a href="#正则表达式中特殊字符" class="headerlink" title="正则表达式中特殊字符"></a>正则表达式中特殊字符</h2><ol>
<li>一个正则表达式可以由简单的字符构成，比如&#x2F;abc&#x2F;，也可以是简单和特殊字符的组合，比如&#x2F;ab*c&#x2F;。其中特殊字符也被称为元字符，在正则表达式中是最具有特殊意义的专用符号，如^、$、+等</li>
</ol>
<h3 id="边界符"><a href="#边界符" class="headerlink" title="边界符"></a>边界符</h3><ol>
<li><p>正则表达式里面不需要加引号，不管是数字型还是字符串型</p>
</li>
<li><p>正则表达式中的边界符（位置符）用来提示字符串所处的位置，主要有两个字符</p>
<table>
<thead>
<tr>
<th>边界符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>表示匹配行首的文本（以谁开始）；若写在中括号内部，表示取反，不为边界符</td>
</tr>
<tr>
<td>$</td>
<td>表示匹配行尾的文本（以谁结束）</td>
</tr>
</tbody></table>
</li>
<li><p>如果^和$一起使用，表示必须是精确匹配；如&#x2F;^abc$&#x2F;，表示必须是abc</p>
</li>
</ol>
<h3 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h3><ol>
<li>字符类[]：表示有一系列字符可以供选择，只要匹配其中一个就可以<ol>
<li>例：&#x2F;[abc]&#x2F; — 只要包含a或b或c都成立</li>
</ol>
</li>
<li>在实际开发中一般都会加上限定符，如&#x2F;^[abc]$&#x2F;，表示只有a或b或c其中一个</li>
<li>字符类[-]，表示范围；如&#x2F;^[a-z]$&#x2F;，表示a-z之间26个字母中任意一个</li>
<li>字符组合<ul>
<li>&#x2F;^[a-zA-Z0-9_-]$&#x2F;，表示26个英文字母（大小写均可）其中任何一个都可</li>
</ul>
</li>
<li>取反符：将^写在中括号内部</li>
</ol>
<h3 id="量词符"><a href="#量词符" class="headerlink" title="量词符"></a>量词符</h3><ol>
<li><p>量词符用来设定某个模式出现的次数</p>
<table>
<thead>
<tr>
<th>量词</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>*</code></td>
<td>重复零次或更多次</td>
</tr>
<tr>
<td>.</td>
<td>匹配除换行符\n之外的任何单字符，要匹配 . ，请使用\ .</td>
</tr>
<tr>
<td><code>+</code></td>
<td>重复一次或更多次</td>
</tr>
<tr>
<td>？</td>
<td>重复零次或一次</td>
</tr>
<tr>
<td>{n}</td>
<td>重复n次</td>
</tr>
<tr>
<td>{n,}</td>
<td>重复n次或更多次</td>
</tr>
<tr>
<td>{n,m}</td>
<td>重复n到m次，中间不要有空格</td>
</tr>
</tbody></table>
</li>
<li><p>例：</p>
<ol>
<li>&#x2F;^[a-zA-Z0-9_-]{6,16}$&#x2F; — 表示让26个英文字母（大小写均可），重复6-16次</li>
<li>&#x2F;^abc{6}$&#x2F; — 让c重复六次</li>
</ol>
</li>
</ol>
<h3 id="括号总结"><a href="#括号总结" class="headerlink" title="括号总结"></a>括号总结</h3><ol>
<li>中括号：字符集合，匹配中括号中的任意字符</li>
<li>大括号：量词符，里面表示重复次数</li>
<li>小括号：表示优先级，例：&#x2F;^(abc){6}$&#x2F; — 让abc重复6次</li>
</ol>
<h3 id="菜鸟工具"><a href="#菜鸟工具" class="headerlink" title="菜鸟工具"></a>菜鸟工具</h3><ol>
<li>在线测试正则表达式，里面还有很多其他工具，不限于正则<ul>
<li><a href="https://c.runoob.com/">https://c.runoob.com/</a></li>
</ul>
</li>
</ol>
<h3 id="预定义类"><a href="#预定义类" class="headerlink" title="预定义类"></a>预定义类</h3><ol>
<li><p>预定义类指的是某些常见模式的简写方式</p>
<table>
<thead>
<tr>
<th>预定类</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>\d</td>
<td>匹配0-9之间的任一数字，相当于[0-9]</td>
</tr>
<tr>
<td>\D</td>
<td>除所有0-9以外的字符，相当于[^0-9]</td>
</tr>
<tr>
<td>\w</td>
<td>匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]</td>
</tr>
<tr>
<td>\W</td>
<td>除所有字母、数字和下划线以外的字符，相当于[^A-Za-z0-9_]</td>
</tr>
<tr>
<td>\s</td>
<td>匹配空格（包括换行符、制表符、空格符等），相当于[\t\r\n\v\f]</td>
</tr>
<tr>
<td>\S</td>
<td>匹配非空格的字符，相当于[^\t\r\n\v\f]</td>
</tr>
</tbody></table>
</li>
<li><p>正则表达式中或符号为： |</p>
</li>
</ol>
<h2 id="正则表达式中的替换"><a href="#正则表达式中的替换" class="headerlink" title="正则表达式中的替换"></a>正则表达式中的替换</h2><h3 id="replace替换"><a href="#replace替换" class="headerlink" title="replace替换"></a>replace替换</h3><ol>
<li><p>replace()方法可以实现替换字符串操作，用来替换的参数可以是一个字符串或是一个正则表达式</p>
<ul>
<li>stringObject.replace(regexp&#x2F;substr, replacement)</li>
</ul>
<ol>
<li>regexp：被替换的字符串或者正则表达式</li>
<li>replacement：替换为的字符串</li>
<li>返回值是一个替换完毕的新字符串</li>
</ol>
</li>
<li><p>正则表达式参数</p>
<ul>
<li>&#x2F;表达式&#x2F;<code>[switch]</code></li>
</ul>
<ol>
<li>switch也称为修饰符，按照什么样的模式来匹配，有三种值：<ul>
<li>g：全局匹配</li>
<li>i：忽略大小写</li>
<li>gi：全局匹配 + 忽略大小写</li>
</ul>
</li>
</ol>
</li>
<li><p>例：敏感词替换</p>
<ul>
<li>str.replace(&#x2F;激情|gay&#x2F;g, ‘**’);</li>
</ul>
<ol>
<li>将激情字眼或者gay字眼，全局替换为**</li>
</ol>
</li>
</ol>
<h2 id="利用正则表达式进行搜索"><a href="#利用正则表达式进行搜索" class="headerlink" title="利用正则表达式进行搜索"></a>利用正则表达式进行搜索</h2><h3 id="match-方法"><a href="#match-方法" class="headerlink" title="match()方法"></a>match()方法</h3><ol>
<li><p>使用match()方法进行字符串查找，相比于includes()区分大小写（见ES6-Array的扩展方法），可以<strong>根据参数来决定是否区分大小写</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 创建一个正则表达式对象</span><br><span class="line">// 参数一：需要匹配的字符串；参数二：i -- 不区分大小写 g -- 全局匹配</span><br><span class="line">var reg = new RegExp(&quot;huawei&quot;, &#x27;ig&#x27;);</span><br><span class="line">var agent = &#123;[], [], []&#125;</span><br><span class="line">// 被搜索的对象</span><br><span class="line">// reg：正则表达式</span><br><span class="line">var isHuawei = agent.match(reg);</span><br></pre></td></tr></table></figure>
</li>
<li><p>两者区别</p>
<ol>
<li>match()可以对<strong>正则表达式</strong>进行匹配，也可以对<strong>字符串</strong>进行匹配，但<strong>不可以对变量</strong>进行匹配</li>
<li>includes()可以对<strong>字符串</strong>进行匹配，也可以对变量进行匹配，但<strong>不可以对正则表达式</strong>进行匹配</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>ES5</category>
      </categories>
      <tags>
        <tag>ES5</tag>
      </tags>
  </entry>
  <entry>
    <title>移动端的网页特效</title>
    <url>/2022/08/01/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84%E7%BD%91%E9%A1%B5%E7%89%B9%E6%95%88/</url>
    <content><![CDATA[<h1 id="触屏事件"><a href="#触屏事件" class="headerlink" title="触屏事件"></a>触屏事件</h1><h2 id="触屏事件概述"><a href="#触屏事件概述" class="headerlink" title="触屏事件概述"></a>触屏事件概述</h2><ol>
<li>移动端浏览器兼容性较好，我们不需要考虑以前JS的兼容性问题，可以放心的使用原生JS书写效果，但是移动端也有自己独特的地方；比如触屏事件touch(也称触摸事件)，Android和IOS都有</li>
</ol>
<h3 id="常见触屏事件"><a href="#常见触屏事件" class="headerlink" title="常见触屏事件"></a>常见触屏事件</h3><table>
<thead>
<tr>
<th>触屏touch事件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>touchstart</td>
<td>手指触摸到一个DOM元素时触发</td>
</tr>
<tr>
<td>touchmove</td>
<td>手指在一个DOM元素上滑动时触发</td>
</tr>
<tr>
<td>touchend</td>
<td>手指从一个DOM元素上移开时触发</td>
</tr>
</tbody></table>
<h2 id="触摸事件对象"><a href="#触摸事件对象" class="headerlink" title="触摸事件对象"></a>触摸事件对象</h2><ol>
<li><p>touchEvent是一类描述手指在触摸平面(触摸屏、触摸板等)的状态变化的事件；这类事件用于描述一个或多个触点，使开发者可以检测触点的移动，触点的增加和减少，等等</p>
<table>
<thead>
<tr>
<th>触摸列表</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>touches</td>
<td>正在触摸屏幕的所有手指的列表</td>
</tr>
<tr>
<td>targetTouches</td>
<td>正在触摸当前DOM元素上的手指的列表</td>
</tr>
<tr>
<td>changedTouches</td>
<td>手指状态发生了改变的列表，从无到有，从有到无变化</td>
</tr>
</tbody></table>
<ol>
<li>由于平时都是给元素注册触摸事件，所以重点记住：targetTocuhes</li>
<li>注意：<ul>
<li>如果侦听的是一个DOM元素，touches和targetTouches两个是一样的</li>
<li>changedTouches是指手指状态发生了改变的列表，从无到有或者从有到无</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="移动端拖动元素"><a href="#移动端拖动元素" class="headerlink" title="移动端拖动元素"></a>移动端拖动元素</h2><ol>
<li><p>touchstart、touchmove、touchend可以实现拖动元素</p>
</li>
<li><p>拖动元素需要当前手指的坐标值，可以使用targetTouches[0]里面的pageX和pageY</p>
</li>
<li><p>移动端拖动的原理：手指移动中，计算出手指移动的距离。然后用盒子原来的位置+手指移动的距离</p>
</li>
<li><p>手指移动的距离：手指滑动中的位置减去手指刚开始触摸的位置</p>
</li>
<li><p>拖动三部曲</p>
<ol>
<li>触摸元素touchstart：获取手指初始坐标，同时获得盒子原来的位置</li>
<li>移动手指touchmove：计算手指的滑动距离，并且移动盒子</li>
<li>离开手指touchend</li>
</ol>
</li>
<li><p>注意：手指移动也会触发滚动屏幕所以这里要阻止默认的屏幕滚动e.preventDefault();</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var div = document.querySelector(&#x27;div&#x27;);</span><br><span class="line">        // 设置手指坐标变量</span><br><span class="line">        var pageX = 0;</span><br><span class="line">        var pageY = 0;</span><br><span class="line">        // 设置盒子坐标变量</span><br><span class="line">        var x = 0;</span><br><span class="line">        var y = 0;</span><br><span class="line"></span><br><span class="line">        // 触摸元素touchstart</span><br><span class="line">        div.addEventListener(&#x27;touchstart&#x27;, function (e) &#123;</span><br><span class="line">            // 获取手指触摸坐标</span><br><span class="line">            pageX = e.targetTouches[0].pageX;</span><br><span class="line">            pageY = e.targetTouches[0].pageY;</span><br><span class="line">            // 获取盒子初始坐标</span><br><span class="line">            x = this.style.left;</span><br><span class="line">            y = this.style.top;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        // 移动手指touchmove</span><br><span class="line">        div.addEventListener(&#x27;touchmove&#x27;, function (e) &#123;</span><br><span class="line">            //获得手指移动的距离</span><br><span class="line">            var moveX = e.targetTouches[0].pageX - pageX;</span><br><span class="line">            var moveY = e.targetTouches[0].pageY - pageY;</span><br><span class="line">            // 将手指移动的距离给盒子，从而移动盒子</span><br><span class="line">            this.style.left = x + moveX + &#x27;px&#x27;;</span><br><span class="line">            this.style.top = y + moveY + &#x27;px&#x27;;</span><br><span class="line"></span><br><span class="line">            // 手指移动也会触发滚动屏幕所以这里要阻止默认的屏幕滚动</span><br><span class="line">            e.preventDefault();</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="案例：移动端轮播图"><a href="#案例：移动端轮播图" class="headerlink" title="案例：移动端轮播图"></a>案例：移动端轮播图</h2><h3 id="自动播放功能"><a href="#自动播放功能" class="headerlink" title="自动播放功能"></a>自动播放功能</h3><ol>
<li>开启定时器</li>
<li>移动端移动，可以使用translate移动，千万不要忘记加单位px</li>
<li>想要图片优雅的移动，添加过渡效果</li>
<li>索引号从第一张有效图片开始计算，克隆至第一张的最后一张图片不算；因此第一张有效图片的索引号为0，以此类推</li>
</ol>
<h3 id="自动播放功能-无缝滚动"><a href="#自动播放功能-无缝滚动" class="headerlink" title="自动播放功能 - 无缝滚动"></a>自动播放功能 - 无缝滚动</h3><ol>
<li>注意：判断条件是等到图片滚动完毕再去判断，就是过渡完成后再判断<ol>
<li>此时需要添加检测过渡完成事件（transitionend）<ul>
<li>Ul.addEventListener(‘transitionend’, function() {})</li>
</ul>
</li>
</ol>
</li>
<li>判断条件：如果索引号等于3说明走到最后一张图片，此时索引号要复原为0<ol>
<li>此时图片去掉过渡效果，然后移动</li>
</ol>
</li>
</ol>
<h3 id="classList属性"><a href="#classList属性" class="headerlink" title="classList属性"></a>classList属性</h3><ol>
<li>classList属性是HTML5新增的一个属性，返回元素的类名，但是ie10以上版本支持</li>
<li>返回的形式是一个伪数组</li>
<li>三大功能：添加类名、删除类名、切换类<ol>
<li>添加类名：在后面追加类名不会覆盖以前的类名，注意添加的类前面不需要加.<ul>
<li>element.classList.add(‘类名’);</li>
</ul>
</li>
<li>删除功能<ul>
<li>element.classList.remove(‘类名’);</li>
</ul>
</li>
<li>切换类：如果该元素拥有这个类，则删除这个类；若该元素没有这个类，则添加这个类<ul>
<li>element.classList.toggle(‘类名’);</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="小圆点跟随变化效果"><a href="#小圆点跟随变化效果" class="headerlink" title="小圆点跟随变化效果"></a>小圆点跟随变化效果</h3><ol>
<li>把ol里面li带有current类名的选出来去掉类名 — classList.remove</li>
<li>让当前索引号的小li加上current — classList.add</li>
<li>等着过渡结束之后变化，所以这个写到transitionend事件里面</li>
</ol>
<h3 id="手指滑动轮播图"><a href="#手指滑动轮播图" class="headerlink" title="手指滑动轮播图"></a>手指滑动轮播图</h3><ol>
<li>本质就是ul跟随手指移动，简单说就是移动端拖动元素</li>
<li>手指触摸的时候就停止定时器</li>
<li>触摸元素touchstart：获取手指初始坐标</li>
<li>移动手指touchmove：计算手指的滑动距离，并且移动盒子</li>
<li>移动盒子：盒子原来的位置 + 手指移动的距离</li>
<li>手指拖动的时候，不需要动画效果，所以要取消过渡效果</li>
<li>手指离开，根据移动距离去判断是回弹还是播放上一张下一张</li>
<li>若移动距离小于某个像素就回弹原来位置</li>
<li>若移动距离大于某个像素就上一张下一张滑动<ol>
<li>距离需要用绝对值：Math.abs();</li>
<li>如果是右滑就是播放上一张，moveX是正值</li>
<li>如果是左滑就是播放下一张，moveX是负值</li>
</ol>
</li>
<li>根据用户手指是否移动过我们再去判断否则不做效果</li>
<li>手指接触然后离开，需要重新开启定时器，开启定时器之前需要清除定时器，保证只有一个定时器在运行<ol>
<li>clearInterval();</li>
</ol>
</li>
<li>阻止滚动屏幕的行为：e.prevnetDefault();</li>
</ol>
<h1 id="移动端常见特效"><a href="#移动端常见特效" class="headerlink" title="移动端常见特效"></a>移动端常见特效</h1><h2 id="click延时解决方案"><a href="#click延时解决方案" class="headerlink" title="click延时解决方案"></a>click延时解决方案</h2><ol>
<li>移动端click事件会有300ms的延时，原因是移动端屏幕双击会缩放(double tap to zoom)页面，在进行点击后，屏幕会等待300ms看有没有第二次点击</li>
</ol>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol>
<li>禁用缩放：浏览器禁用默认的双击缩放行为并且去掉300ms的点击延迟<ul>
<li><code>&lt;meta name=&quot;viewport&quot; content= &quot;user-scalable=no&quot;&gt;</code></li>
</ul>
</li>
<li>利用touch事件封装这个事件解决300ms延迟<ol>
<li>原理<ul>
<li>当我们手指触摸屏幕，记录当前触摸时间</li>
<li>当我们手指离开屏幕，用离开的时间减去触摸的时间</li>
<li>如果时间小于150ms，并且没有滑动过屏幕，那么我们就定义为点击</li>
</ul>
</li>
</ol>
</li>
</ol>
<h1 id="移动端常用开发插件"><a href="#移动端常用开发插件" class="headerlink" title="移动端常用开发插件"></a>移动端常用开发插件</h1><h2 id="什么是插件"><a href="#什么是插件" class="headerlink" title="什么是插件"></a>什么是插件</h2><ol>
<li>移动端要求的是快速开发，所以我们经常会借助于一些插件来帮我完成操作，那么什么是插件呢?</li>
<li>JS插件是js文件，它遵循一定规范编写，方便程序展示效果，拥有特定功能且方便调用，如轮播图和瀑布流插件</li>
<li>特点：它一般是为了解决某个问题而专门存在，其功能单一，并且比较小</li>
<li>以前写的animate.js也算一个最简单的插件</li>
</ol>
<h2 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h2><h3 id="fastclick插件"><a href="#fastclick插件" class="headerlink" title="fastclick插件"></a>fastclick插件</h3><ol>
<li><p>插件功能：解决click双击延时</p>
</li>
<li><p>将fastclick.js插件下载准备好</p>
</li>
<li><p>在html文件中引入js插件</p>
</li>
<li><p>复制粘贴使用插件的初始化代码，放在script表圈内最顶部，最好挨<code>&lt;/body&gt;</code></p>
<p>标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        div &#123;</span><br><span class="line">            width: 50px;</span><br><span class="line">            height: 50px;</span><br><span class="line">            background-color: pink;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;script src=&quot;fastclick.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        if (&#x27;addEventListener&#x27; in document) &#123;</span><br><span class="line">            document.addEventListener(&#x27;DOMContentLoaded&#x27;, function() &#123;</span><br><span class="line">                FastClick.attach(document.body);</span><br><span class="line">            &#125;, false);</span><br><span class="line">        &#125;</span><br><span class="line">        var div = document.querySelector(&#x27;div&#x27;);</span><br><span class="line">        div.addEventListener(&#x27;click&#x27;, function() &#123;</span><br><span class="line">            alert(11);</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Swiper插件使用"><a href="#Swiper插件使用" class="headerlink" title="Swiper插件使用"></a>Swiper插件使用</h3><ol>
<li>中文官网地址： <a href="https://www.swiper.com.cn/">https://www.swiper.com.cn/</a></li>
<li>使用方法<ol>
<li>引入插件相关文件：相关css文件和js文件</li>
<li>按照规定语法使用<ul>
<li>打开Swiper提供的相关html网页，查看网页源代码，将相关内容复制到自己的程序中</li>
<li>第一步：复制相关结构html代码复制过来 （不要修改里面的结构和类名）</li>
<li>第二步：复制相关css文件</li>
<li>第三步：复制相关js文件的初始化代码（初始化代码最好挨着标签，如果不能写在html内容后面，则需要在页面加载完成后再初始化 — load或DOMContentLoaded）</li>
</ul>
</li>
</ol>
</li>
<li>其他移动端常见插件<ol>
<li>superslide： <a href="http://www.superslide2.com/">http://www.superslide2.com/</a></li>
<li>iscroll： <a href="https://github.com/cubiq/iscroll">https://github.com/cubiq/iscroll</a></li>
</ol>
</li>
</ol>
<h1 id="移动端常用开发框架"><a href="#移动端常用开发框架" class="headerlink" title="移动端常用开发框架"></a>移动端常用开发框架</h1><ol>
<li>框架，顾名思义就是一套架构，它会基于自身的特点向用户提供一套较为完整的解决方案；框架的控制权在框架本身，使用者要按照框架所规定的某种规范进行开发</li>
<li>前端常用的框架有Bootstrap、Vue、Angular、React等，既能开发PC端，也能开发移动端</li>
</ol>
<h2 id="框架和插件的区别"><a href="#框架和插件的区别" class="headerlink" title="框架和插件的区别"></a>框架和插件的区别</h2><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><ol>
<li>基于自身的特点向用户提供一套较为完整的解决方案；框架的控制权在框架本身，使用者要按照框架所规定的某种规范进行开发</li>
<li>大而全，一整套解决方案</li>
</ol>
<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><ol>
<li>插件一般是为了解决某个问题而专门存在，其功能单一，并目比较小</li>
<li>小而专一，某个功能的解决方案</li>
</ol>
<h2 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h2><ol>
<li>Bootstrap是一个简洁、直观、强悍的前端开发框架，它让web开发更迅速、简单</li>
<li>它可以开发PC端，也可以开发移动端</li>
<li>Bootstrap - js插件使用步骤<ol>
<li>引入相关js文件</li>
<li>复制HTML结构</li>
<li>修改对应样式</li>
<li>修改相应JS参数</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>浅拷贝和深拷贝</title>
    <url>/2022/08/01/%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<h1 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h1><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><ol>
<li>浅拷贝只是拷贝一层，更深层次对象级别的只拷贝引用</li>
<li>浅拷贝原理<ol>
<li>把原来对象里面的复杂数据类型的地址拷贝给目标对象</li>
<li>会覆盖目标对象的里面的数据</li>
<li>目标拷贝对象里面的值会随着原来对象的改变而改变，因为他们指向同一个地址</li>
</ol>
</li>
<li>Object.assign(targer, sources) — es6新增方法可以浅拷贝<ol>
<li>targer：拷贝的目标对象</li>
<li>sources：拷贝谁</li>
</ol>
</li>
</ol>
<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><ol>
<li><p>深拷贝拷贝多层，每一级别的数据都会拷贝</p>
</li>
<li><p>深拷贝原理</p>
<ol>
<li>把原来对象里面的数据完全复制一份给目标对象</li>
<li>会覆盖目标对象的里面的数据</li>
<li>若其中有不冲突的属性，会合并到一起，比如目标对象中的对象的属性age和原来对象中的对象的属性name</li>
<li>目标拷贝对象里面的值不会随着原来对象的改变而改变</li>
</ol>
</li>
<li><p>代码实现深拷贝</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">script&gt;</span><br><span class="line">    var obj = &#123;</span><br><span class="line">        name: &#x27;熊大&#x27;,</span><br><span class="line">        sex: &#x27;男&#x27;,</span><br><span class="line">        age: &#123;</span><br><span class="line">            one: 7,</span><br><span class="line">            two: 6</span><br><span class="line">        &#125;,</span><br><span class="line">        friend: [&#x27;吉吉&#x27;, &#x27;毛毛&#x27;, &#x27;蹦蹦&#x27;]</span><br><span class="line">    &#125;</span><br><span class="line">    var o = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // 封装深拷贝函数</span><br><span class="line">    function deepClone(newObj, oldObj) &#123;</span><br><span class="line">        for (var k in oldObj) &#123;</span><br><span class="line">            // 获取属性值，k为属性名，oldObj[k]为属性值</span><br><span class="line">            var item = oldObj[k];</span><br><span class="line">            // 当属性值为数组时</span><br><span class="line">            // 判断数组必须放在判断对象之前，因为数组也为对象</span><br><span class="line">            if (item instanceof Array) &#123;</span><br><span class="line">                // newObj[k]为新对象的属性值</span><br><span class="line">                newObj[k] = [];</span><br><span class="line">                deepClone(newObj[k], item);</span><br><span class="line">            &#125; else if (item instanceof Object) &#123;</span><br><span class="line">                // 当属性值为对象时</span><br><span class="line">                newObj[k] = &#123;&#125;;</span><br><span class="line">                deepClone(newObj[k], item);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 当属性值为简单数据类型时</span><br><span class="line">                newObj[k] = item;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    deepClone(o, obj);</span><br><span class="line">    console.log(o);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>ES5</category>
      </categories>
      <tags>
        <tag>ES5</tag>
      </tags>
  </entry>
  <entry>
    <title>继承</title>
    <url>/2022/08/01/%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><ol>
<li>ES6之前并没有给我们提供extends继承。我们可以通过构造函数+原型对象模拟实现继承，被称为组合继承</li>
</ol>
<h2 id="借用父构造函数继承属性和方法"><a href="#借用父构造函数继承属性和方法" class="headerlink" title="借用父构造函数继承属性和方法"></a>借用父构造函数继承属性和方法</h2><h3 id="借用父构造函数继承属性"><a href="#借用父构造函数继承属性" class="headerlink" title="借用父构造函数继承属性"></a>借用父构造函数继承属性</h3><ol>
<li><p>核心原理：通过call()把父类型的this指向子类型的this，这样就可以实现子类型继承父类型的属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  function Father(uname, age) &#123;</span><br><span class="line">    this.uname = uname;</span><br><span class="line">    this.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  function son(uname, age, sex) &#123;</span><br><span class="line">    // 借用父构造函数继承属性</span><br><span class="line">    Father.call(this, uname, age);</span><br><span class="line">    this.sex = sex;</span><br><span class="line">  &#125;</span><br><span class="line">  var son = new son(&#x27;张三&#x27;, 15, &#x27;女&#x27;);</span><br><span class="line">  console.log(son);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="借用父构造函数继承方法"><a href="#借用父构造函数继承方法" class="headerlink" title="借用父构造函数继承方法"></a>借用父构造函数继承方法</h3><ol>
<li><p>因为构造函数的方法会放在原型对象中，因此父构造函数的方法放在父原型对象内部，若子构造函数的实例对象要想继承使用父原型对象内部的方法，则进行如下过程</p>
<ol>
<li>将父构造函数实例化，让子原型对象指向父实例化对象，因为父实例化对象的原型（<code>__proto__</code>）为父原型对象，因此父实例化对象可以使用父原型对象中的方法，从而让指向父实例对象的子原型对象继承到父原型对象中的方法</li>
<li>注意：让子原型对象指向父实例对象后，会让父实例对象覆盖子原型对象，此时需要利用constructor指回子构造函数</li>
</ol>
</li>
<li><p>注意：千万不可直接将父原型对象直接赋值给子原型对象，这样会让子原型对象直接指向父原型对象，导致一旦给子原型对象添加方法，会让父原型对象同时添加这个方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    function Father(uname, age) &#123;</span><br><span class="line">      this.uname = uname;</span><br><span class="line">      this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    function Son(uname, age, sex) &#123;</span><br><span class="line">      // 借用父构造函数继承属性</span><br><span class="line">      Father.call(this, uname, age);</span><br><span class="line">      this.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 在父原型对象中添加方法</span><br><span class="line">    Father.prototype.money = function () &#123;</span><br><span class="line">      console.log(&#x27;赚钱赚钱&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 千万不可直接将父原型对象直接赋值给子原型对象，这样会让子原型对象直接指向父原型对象，导致一旦给子原型对象添加方法，会让父原型对象同时添加这个方法</span><br><span class="line">    Son.prototype = Father.prototype;</span><br><span class="line"></span><br><span class="line">    // 借用父构造函数继承方法</span><br><span class="line">    // 父构造函数实例化，让子原型对象指向父实例化对象</span><br><span class="line">    Son.prototype = new Father();</span><br><span class="line">    // 因为new Father()创建了一个对象，覆盖了子原型对象，因此需要让子原型对象手动指回构造函数</span><br><span class="line">    Son.prototype.constructor = Son;</span><br><span class="line"></span><br><span class="line">    // 子原型对象成功继承父原型对象中的方法</span><br><span class="line">    Son.prototype.money(); // 输出：赚钱赚钱</span><br><span class="line">    console.log(Son.prototype); // 子原型对象指向父实例对象</span><br><span class="line">    console.log(Son.prototype.constructor); // 指向子构造函数</span><br><span class="line"></span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><img src="https://twentyseven.oss-cn-guangzhou.aliyuncs.com/20211007005323.png" alt="img"></p>
]]></content>
      <categories>
        <category>ES5</category>
      </categories>
      <tags>
        <tag>ES5</tag>
      </tags>
  </entry>
  <entry>
    <title>移动端的基础和布局</title>
    <url>/2022/08/01/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84%E5%9F%BA%E7%A1%80%E5%92%8C%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h1 id="移动端基础"><a href="#移动端基础" class="headerlink" title="移动端基础"></a>移动端基础</h1><h3 id="移动端调试方法"><a href="#移动端调试方法" class="headerlink" title="移动端调试方法"></a>移动端调试方法</h3><ol>
<li>Chrome DevTools (谷歌浏览器)的模拟手机调试</li>
<li>搭建本地web服务器,手机和服务器个局域网内,通过手机访问服务器</li>
<li>使用外网服务器,直接IP或域名访问</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>移动端浏览器我们主要对webkit内核进行兼容</li>
<li>我们现在开发的移动端主要针对手机端开发</li>
<li>现在移动端碎片化比较严重,分辨率和屏幕尺寸大小不一</li>
<li>学会用谷歌浏览器模拟手机界面以及调试</li>
</ol>
<h2 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h2><ol>
<li>视口（viewport）就是浏览器显示页面内容的屏幕区域。视口可以分为布局视口，视觉视口，理想视口</li>
</ol>
<h3 id="布局视口-layout-viewport"><a href="#布局视口-layout-viewport" class="headerlink" title="布局视口 layout viewport"></a>布局视口 layout viewport</h3><ol>
<li>一般移动设备的浏览器都默认设置 了一个布局视口,用于解决早期的PC端页面在手机上显示的问题</li>
<li>iOS, Android基本都将这个视口分辨率设置为980px ,所以PC上的网页大多都能在手机上呈现，只不过元素看上去很小，一般默认可以通过手动缩放网页</li>
</ol>
<h3 id="视觉视口-visual-viewport"><a href="#视觉视口-visual-viewport" class="headerlink" title="视觉视口 visual viewport"></a>视觉视口 visual viewport</h3><ol>
<li>指用户正在看到的网站的区域，注意：是网站的区域</li>
<li>可以通过缩放去操作视觉视口，但不会影响布局视口，布局视口仍保持原来的宽度</li>
</ol>
<h3 id="理想视口-ideal-viewport"><a href="#理想视口-ideal-viewport" class="headerlink" title="理想视口 ideal viewport"></a>理想视口 ideal viewport</h3><ol>
<li>为了使网站在移动端有最理想的浏览和阅读宽度而设定</li>
<li>理想视口,对设备来讲,是最理想的视口尺寸</li>
<li>需要手动添写meta视口标签通知浏览器操作</li>
<li>meta视口标签的主要目的:布局视口的宽度应该与理想视口的宽度一致,简单理解就是设备有多宽,我们布局的视口就多宽</li>
</ol>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol>
<li>视口就是浏览器显示页面内容的屏幕区域</li>
<li>视口分为布局视口、视觉视口和理想视口</li>
<li>移动端布局想要的是理想视口就是手机屏幕有多宽,我们的布局视口就有多宽想要理想视口</li>
<li>需要给我们的移动端页面添加meta视口标签</li>
</ol>
<h2 id="meta视口标签"><a href="#meta视口标签" class="headerlink" title="meta视口标签"></a>meta视口标签</h2><h3 id="标签属性"><a href="#标签属性" class="headerlink" title="标签属性"></a>标签属性</h3><ol>
<li><pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   | 属性          | 解释说明                                             |</span><br><span class="line">   | ------------- | ---------------------------------------------------- |</span><br><span class="line">   | width         | 宽度设置的是viewport宽度，可以设置device-width特殊值 |</span><br><span class="line">   | user-scalable | 用户是否可以缩放，yes或no（1或0）                    |</span><br><span class="line">   | initial-scale | 初始缩放比，大于0的数字                              |</span><br><span class="line">   | maximum-scale | 最大缩放比，大于0的数字                              |</span><br><span class="line">   | minimum-scale | 最小缩放比，大于0的数字                              |</span><br><span class="line"></span><br><span class="line">### 标准viewport设置</span><br><span class="line"></span><br><span class="line">1. 视口宽度和设备保持一致</span><br><span class="line">2. 视口的默认缩放比例1.0</span><br><span class="line">3. 不允许用户自行缩放</span><br><span class="line">4. 最大允许的缩放比例1.0</span><br><span class="line">5. 最小允许的缩放比例1.0</span><br><span class="line"></span><br><span class="line">## 二倍图</span><br><span class="line"></span><br><span class="line">### 物理像素和物理像素比</span><br><span class="line"></span><br><span class="line">1. 物理像素点指的是屏幕显示的最小颗粒，是物理真实存在的。这是厂商在出厂时就设置好的</span><br><span class="line">2. 我们开发时候的1px不是一定等于1个物理像素的</span><br><span class="line">3. PC端页面，1个px等于1个物理像素的，但是移动端就不尽相同</span><br><span class="line">4. 一个px的能显示的物理像素点的个数，称为物理像素比或屏幕像素比</span><br><span class="line">5. PC端和早前的手机屏幕/普通手机屏幕: 1CSS像素= 1 物理像素的</span><br><span class="line">6. Retina (视网膜屏幕)是一种显示技术，可以将把更多的物理像素点压缩至一块屏幕里，从而达到更高的分辨率，并提高屏幕显示的细腻程度</span><br><span class="line"></span><br><span class="line">### 背景缩放 background-size</span><br><span class="line"></span><br><span class="line">1. background-size: 背景图片宽度 背景图片高度；</span><br><span class="line"></span><br><span class="line">   1. 单位：长度 | 百分比 | cover | contain</span><br><span class="line"></span><br><span class="line">   2. cover把背景图片扩展至足够大，使背景图像完全覆盖背景区域</span><br><span class="line"></span><br><span class="line">   3. contain把图像扩展至最大尺寸，使其宽度和高度完全适应内容区域</span><br><span class="line"></span><br></pre></td></tr></table></figure>
   &lt;head&gt;
       &lt;meta charset=&quot;UTF-8&quot;&gt;
       &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
       &lt;meta name=&quot;viewport&quot;
           content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot;&gt;
       &lt;title&gt;Document&lt;/title&gt;
       &lt;style&gt;
           div &#123;
               width: 400px;
               height: 400px;
               border: 2px solid pink;
               background: url(../images/dog.jpg) no-repeat;
               /* 
               1.单位：长度  若只写一个参数，则为省略高度，会进行等比缩放
               background-size: 400px 400px;
               background-size: 400px;
               */
   
               /* 
               2.单位：百分比 相对于父盒子的百分比 
               background-size: 50%;
               */
   
               /* 
               3.单位：cover 等比例拉伸 要完全覆盖div盒子 可能有部分背景图片显示不完全 
               background-size: cover;
               */
   
               /*
               4.单位： contain 高度和宽度等比例拉伸，当宽度或者高度铺满div盒子就不再进行拉伸 可能有部分空白区域*/
               background-size: contain;
           &#125;
       &lt;/style&gt;
   &lt;/head&gt;
</code></pre>
</li>
</ol>
<h1 id="移动端开发"><a href="#移动端开发" class="headerlink" title="移动端开发"></a>移动端开发</h1><h2 id="移动端开发选择"><a href="#移动端开发选择" class="headerlink" title="移动端开发选择"></a>移动端开发选择</h2><h3 id="单独移动端页面（主流）"><a href="#单独移动端页面（主流）" class="headerlink" title="单独移动端页面（主流）"></a>单独移动端页面（主流）</h3><ol>
<li>通常情况下，网址域名前面加m（mobile）可以打开移动端。通过判断设备，如果是移动设备打开，则跳到移动端页面<ol>
<li>流式布局（百分比布局）</li>
<li>flex弹性布局（强烈推荐）</li>
<li>less + rem + 媒体查询布局</li>
<li>混合布局</li>
</ol>
</li>
</ol>
<h3 id="响应式兼容PC移动端"><a href="#响应式兼容PC移动端" class="headerlink" title="响应式兼容PC移动端"></a>响应式兼容PC移动端</h3><ol>
<li>通过判断屏幕的宽度来改变样式，以适应不同终端</li>
<li>缺点：制作麻烦，需要花很大精力去调兼容性问题<ol>
<li>媒体查询</li>
<li>bootstarp</li>
</ol>
</li>
</ol>
<h2 id="移动端技术解决方案"><a href="#移动端技术解决方案" class="headerlink" title="移动端技术解决方案"></a>移动端技术解决方案</h2><h3 id="CSS3盒子模型"><a href="#CSS3盒子模型" class="headerlink" title="CSS3盒子模型"></a>CSS3盒子模型</h3><ol>
<li>CSS3中的盒子模型，padding和border不会撑大盒子<ul>
<li>box-sizing: border-box;</li>
</ul>
</li>
<li>传统盒子模型(默认不写)<ul>
<li>box-sizing： content-box；</li>
</ul>
</li>
</ol>
<h3 id="如何选择使用"><a href="#如何选择使用" class="headerlink" title="如何选择使用"></a>如何选择使用</h3><ol>
<li>移动端可以全部使用CSS3盒子模型</li>
<li>PC端如果需要兼容，就使用传统模式，不考虑兼容性则选择CSS3盒子模型</li>
</ol>
<h3 id="特殊样式（重点）"><a href="#特殊样式（重点）" class="headerlink" title="特殊样式（重点）"></a>特殊样式（重点）</h3><ol>
<li>CSS3盒子模型<ul>
<li>-webkit-box-sizing: border-box;</li>
</ul>
</li>
<li>点击高亮我们需要进行清除 设置为transparent 完成透明<ul>
<li>*{-webket-tap-highlight-color: transparent;}</li>
</ul>
</li>
<li>在移动端浏览器默认的外观在ios上加上这个属性才能给按钮和输入框自定义样式<ul>
<li>input {-webkit-appearance: none;}</li>
</ul>
</li>
<li>禁用长按页面时的弹出菜单<ul>
<li>img, a {-webkit-touch-callout: none;}</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>闭包</title>
    <url>/2022/08/01/%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><ol>
<li>变量根据作用域的不同分为两种：全局变量和局部变量</li>
<li>函数内部可以使用全局变量</li>
<li>函数外部不可以使用局部变量</li>
<li>当函数执行完毕后，本作用域内的局部变量会被销毁</li>
</ol>
<h2 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h2><ol>
<li>闭包（closure）指有权访问另一个函数作用域中变量的函数</li>
<li>简单理解：一个作用域可以访问另外一个函数内部的局部变量，则这个被访问的局部变量所在的函数就是闭包</li>
<li>闭包的主要作用：延伸了变量的作用范围</li>
<li>闭包是一种保护私有变量的机制，在函数执行时形成私有的作用域，保护里面的私有变量不受外界干扰</li>
<li>直观的说就是形成一个不销毁的栈环境</li>
</ol>
<h2 id="闭包应用"><a href="#闭包应用" class="headerlink" title="闭包应用"></a>闭包应用</h2><ol>
<li><p>循环注册点击事件</p>
<ol>
<li><p>经典面试题：利用闭包的方式得到当前小li的索引号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;li&gt;1&lt;/li&gt;</span><br><span class="line">&lt;li&gt;2&lt;/li&gt;</span><br><span class="line">&lt;li&gt;3&lt;/li&gt;</span><br><span class="line">&lt;li&gt;4&lt;/li&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  var lis = document.querySelectorAll(&#x27;li&#x27;);</span><br><span class="line">  for (var i = 0; i &lt; lis.length; i++) &#123;</span><br><span class="line">      // 利用for循环创建了四个立即执行函数</span><br><span class="line">      // 立即执行函数是一个小闭包，因为立即执行函数里面任何一个函数都可以使用它的i变量 </span><br><span class="line">      (function (i) &#123;</span><br><span class="line">          lis[i].onclick = function () &#123;</span><br><span class="line">              console.log(i);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;)(i);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>循环中的setTimeout()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line"> &lt;li&gt;1&lt;/li&gt;</span><br><span class="line"> &lt;li&gt;2&lt;/li&gt;</span><br><span class="line"> &lt;li&gt;3&lt;/li&gt;</span><br><span class="line"> &lt;li&gt;4&lt;/li&gt;</span><br><span class="line"> &lt;script&gt;</span><br><span class="line">     var lis = document.querySelectorAll(&#x27;li&#x27;);</span><br><span class="line">     // for循环为同步任务</span><br><span class="line">     for (var i = 0; i &lt; lis.length; i++) &#123;</span><br><span class="line">         (function (i) &#123;</span><br><span class="line">             // 定时器为异步任务</span><br><span class="line">             setTimeout(function () &#123;</span><br><span class="line">                 console.log(i);</span><br><span class="line">             &#125;, 2000)</span><br><span class="line">         &#125;)(i);</span><br><span class="line">     &#125;</span><br><span class="line"> &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>ES5</category>
      </categories>
      <tags>
        <tag>ES5</tag>
      </tags>
  </entry>
</search>
